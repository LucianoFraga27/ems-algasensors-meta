1.1 Boas Vindas
1.2 Alinhando expectativas
1.3 Por que arquitetura Ã© importante?
1.4 O que Ã© Arquitetura de software?
- Arquitetura de software inclui caracterÃ­sticas, padrÃµes e princÃ­pios do Sistema
- Requisitos Funcionais;
- Requisitos nÃ£o funcionais;

Na arquitetura de software, os "ILities" (tambÃ©m chamados de "ilities" ou qualidades da arquitetura) sÃ£o caracterÃ­sticas nÃ£o-funcionais que ajudam a avaliar e guiar decisÃµes arquiteturais. Eles geralmente terminam em â€œ-ilidadeâ€ (em portuguÃªs) ou â€œ-ilityâ€ (em inglÃªs), daÃ­ o apelido. SÃ£o importantes porque definem como o sistema se comporta sob vÃ¡rias condiÃ§Ãµes, em vez de o que o sistema faz.

Aqui estÃ£o os principais ILities da arquitetura de software:

ğŸ¯ 1. Escalabilidade (Scalability)
Capacidade do sistema de lidar com aumento de carga (mais usuÃ¡rios, dados ou transaÃ§Ãµes).

Escalabilidade vertical: melhorar hardware.

Escalabilidade horizontal: adicionar mais mÃ¡quinas.

ğŸ” 2. Manutenibilidade (Maintainability)
Facilidade de corrigir erros, adicionar funcionalidades ou atualizar tecnologias.

Influenciada por boas prÃ¡ticas, modularidade, e documentaÃ§Ã£o clara.

ğŸ”„ 3. Reusabilidade (Reusability)
Capacidade de reutilizar componentes ou mÃ³dulos do sistema em outros contextos.

Favorece a produtividade e consistÃªncia.

âš™ï¸ 4. Confiabilidade (Reliability)
Capacidade do sistema de funcionar corretamente por longos perÃ­odos sem falhas.

Inclui mecanismos de tolerÃ¢ncia a falhas e redundÃ¢ncia.

ğŸ•’ 5. Disponibilidade (Availability)
Percentual de tempo que o sistema estÃ¡ operacional e acessÃ­vel.

EstÃ¡ relacionada Ã  confiabilidade, mas foca na disponibilidade percebida.

ğŸ” 6. SeguranÃ§a (Security)
Capacidade de proteger dados e funcionalidades contra acesso nÃ£o autorizado.

Inclui autenticaÃ§Ã£o, autorizaÃ§Ã£o, criptografia e auditoria.

ğŸ“ 7. Usabilidade (Usability)
Facilidade de uso e aprendizado do sistema pelos usuÃ¡rios finais.

ğŸš€ 8. Desempenho (Performance)
Resposta do sistema sob carga: tempo de resposta, throughput, latÃªncia, etc.

ğŸ§ª 9. Testabilidade (Testability)
Facilidade de testar os componentes do sistema de forma automatizada e confiÃ¡vel.

ğŸ“¦ 10. Portabilidade (Portability)
Facilidade de mover o sistema entre ambientes (diferentes sistemas operacionais, servidores, etc).

â™»ï¸ 11. Flexibilidade / Extensibilidade (Flexibility / Extensibility)
Facilidade de adaptar o sistema a mudanÃ§as nos requisitos ou ambiente.

ğŸ“š 12. Auditabilidade (Auditability)
Capacidade de rastrear atividades e eventos dentro do sistema, Ãºtil para conformidade e seguranÃ§a.

1.5 As leis da arquitetura de software

Primeira Lei: Toda decisÃ£o arquitetural Ã© um tradeoff (Toda escolha que vocÃª faz na arquitetura melhora alguns aspectos do sistema e piora outros)
Segunda Lei: Tudo depende do contexto. (O "porquÃª" Ã© mais importante que o "como")
Terceira Lei: A arquitetura evolui.
Quarta Lei: NÃ£o otimize prematuramente.
Quinta Lei: Simplifique.

1.6 As responsabilidades e perfil do arquiteto de software

O arquiteto de software Ã© o profissional responsÃ¡vel por definir e manter a estrutura tÃ©cnica de sistemas, guiando decisÃµes estratÃ©gicas sobre tecnologias, padrÃµes, integraÃ§Ãµes, e atributos de qualidade
- Tomar decisÃµes arquiteturais
- Analisar continuamente a arquitetura
- Acompanhar tendÃªncias e inovaÃ§Ãµes
- Garantir a conformidade com decisÃµes arquiteturais
- Ter experiÃªncia diversificada
- Bom lÃ­der
- Saber defender seus pontos arquiteturais

1.7 O que Ã© arquitetura de soluÃ§Ã£o?

-  Ã© o projeto tÃ©cnico de uma soluÃ§Ã£o de TI completa â€” que integra sistemas, tecnologias, dados, infraestrutura e seguranÃ§a â€” para atender a um objetivo de negÃ³cio especÃ­fico.
O arquiteto de soluÃ§Ã£o define:
- As tecnologias a serem usadas (Java + Angular + PostgreSQL)
- Como o sistema se comunica com a SEFAZ (web service, certificados A1/A3)
- Como serÃ¡ a seguranÃ§a (OAuth2, Keycloak)
- Como serÃ¡ a integraÃ§Ã£o com os ERPs da empresa
- Onde vai rodar (Kubernetes, AWS, on-premise, etc.)
- Como serÃ¡ o monitoramento e a escalabilidade

"A arquitetura de soluÃ§Ã£o Ã© onde a visÃ£o do negÃ³cio encontra a execuÃ§Ã£o tÃ©cnica"

1.8 O que design de software? 

Ã© o projeto interno do sistema: como os mÃ³dulos, classes, mÃ©todos, dados e fluxos interagem para cumprir os requisitos.

"O design de software Ã© como vocÃª organiza os blocos dentro da arquitetura"

1.9 O que Ã© design de cÃ³digo?

Ã© o cuidado com a escrita do cÃ³digo-fonte para tornÃ¡-lo claro, limpo, reutilizÃ¡vel, testÃ¡vel e fÃ¡cil de manter.

"O design de cÃ³digo Ã© o cuidado com os detalhes que fazem o cÃ³digo viver bem com outros desenvolvedores"

1.10 Estilos arquiteturais, padrÃµes  e padrÃµes de projeto

ğŸ›ï¸ 1. Estilos Arquiteturais (Architectural Styles)
ğŸ”¹ SÃ£o modelos amplos que descrevem como os componentes de um sistema se organizam e interagem entre si.
ğŸ”¹ NÃ£o sÃ£o soluÃ§Ãµes detalhadas, mas sim abstraÃ§Ãµes de alto nÃ­vel.
Exemplos:
MonolÃ­tico	Toda a aplicaÃ§Ã£o em um Ãºnico bloco (backend, frontend, regras, etc.)
Camadas (Layered)	OrganizaÃ§Ã£o em camadas (UI, lÃ³gica de negÃ³cio, persistÃªncia)
Cliente-Servidor	ComunicaÃ§Ã£o entre cliente e servidor via rede
Microservices	Sistema dividido em pequenos serviÃ§os independentes
Event-Driven	ComunicaÃ§Ã£o via eventos (publicaÃ§Ã£o e assinatura)
Orientado a ServiÃ§os (SOA)	ExposiÃ§Ã£o de funcionalidades como serviÃ§os reutilizÃ¡veis


ğŸ§© 2. PadrÃµes Arquiteturais (Architectural Patterns)
ğŸ”¸ SÃ£o soluÃ§Ãµes reutilizÃ¡veis e comprovadas para problemas arquiteturais comuns.
ğŸ”¸ Mais especÃ­ficos do que estilos, mas ainda em alto nÃ­vel.
MVC (Model-View-Controller)	Separa visualizaÃ§Ã£o, controle e modelo (usado em Web e Desktop)
MVVM (Model-View-ViewModel)	Similar ao MVC, comum em apps mobile/desktop modernos
CQRS (Command Query Responsibility Segregation)	SeparaÃ§Ã£o entre leitura (query) e escrita (command)
Event Sourcing	PersistÃªncia baseada em eventos ao invÃ©s de estados
Hexagonal (Ports & Adapters)	Foco na independÃªncia entre regras de negÃ³cio e tecnologias externas
Broker	Intermedia comunicaÃ§Ã£o entre mÃ³dulos (ex: sistemas distribuÃ­dos com mensageria)


ğŸ§  3. PadrÃµes de Projeto (Design Patterns)
ğŸ”¹ SÃ£o soluÃ§Ãµes detalhadas e reutilizÃ¡veis para problemas recorrentes no nÃ­vel de cÃ³digo.
ğŸ”¹ Organizam como classes, objetos e mÃ©todos se relacionam.
Exemplos (segundo o livro Design Patterns, GoF):
Criacionais	Singleton, Factory Method, Abstract Factory, Builder, Prototype
Estruturais	Adapter, Composite, Proxy, Decorator, Facade
Comportamentais	Strategy, Observer, Command, State, Chain of Responsibility

ğŸ§­ Resumo em nÃ­veis:
Alto nÃ­vel	Estilo Arquitetural	Estrutura geral do sistema
MÃ©dio nÃ­vel	PadrÃ£o Arquitetural	SoluÃ§Ã£o especÃ­fica para organizaÃ§Ã£o interna
Baixo nÃ­vel	PadrÃ£o de Projeto	Estrutura do cÃ³digo e relaÃ§Ã£o entre classes/objetos


1.11 Diagramas arquiteturais formais

â€œO diagrama deve ter um propÃ³sito e gerar valor.â€

Diagramas sÃ£o representaÃ§Ãµes visuais da arquitetura de um sistema. Servem para comunicar, documentar e alinhar o entendimento tÃ©cnico entre stakeholders (desenvolvedores, arquitetos, analistas, gestores etc.).

ğŸ”¹ Diagramas Formais
SÃ£o baseados em notaÃ§Ãµes padronizadas, como UML ou C4, com semÃ¢ntica clara e reprodutÃ­vel.

ğŸ§© UML (Unified Modeling Language)
Diagrama de Classes	Mostra classes, atributos, mÃ©todos e seus relacionamentos (heranÃ§a, composiÃ§Ã£o, etc.)
Diagrama de SequÃªncia	Mostra a interaÃ§Ã£o entre componentes no tempo (fluxo de chamadas entre objetos ou serviÃ§os)

ğŸ§± C4 Model (por Simon Brown)
O C4 divide a arquitetura em quatro nÃ­veis progressivos de detalhe:
C1	Context	VisÃ£o geral do sistema no seu ambiente (usuÃ¡rios, sistemas externos)
C2	Container	Mostra os â€œcontainersâ€ (ex: app web, banco de dados, APIs, serviÃ§os)
C3	Component	Mostra os componentes internos de um container (ex: controllers, services, repositÃ³rios)
C4	Code	Zoom no cÃ³digo, com classes ou estruturas especÃ­ficas

ğŸ”¹ Diagramas Livres (Ad hoc)
SÃ£o diagramas criados sem seguir uma notaÃ§Ã£o formal. Ãšteis para brainstorms, apresentaÃ§Ãµes rÃ¡pidas ou comunicaÃ§Ã£o nÃ£o tÃ©cnica.

ğŸ“Œ Ex: fluxos de usuÃ¡rio, arquitetura simplificada de um MVP, fluxos de dependÃªncia em sistemas legados.

âœ… Guidelines para uma boa diagramaÃ§Ã£o
Para garantir que os diagramas realmente comuniquem com clareza, siga boas prÃ¡ticas:
ğŸ¯ PropÃ³sito claro: cada diagrama deve responder uma pergunta (ex: â€œComo os sistemas se comunicam?â€).
ğŸ“Œ TÃ­tulo e legenda: contextualize o diagrama.
ğŸ§­ NÃ­vel adequado: nÃ£o misture nÃ­veis de abstraÃ§Ã£o (ex: nÃ£o coloque cÃ³digo e sistemas externos no mesmo diagrama).
ğŸ“ Linhas bem definidas: evite sobreposiÃ§Ã£o ou conexÃµes ambÃ­guas.
ğŸ”  Nomeclaturas padronizadas: use nomes coerentes com o cÃ³digo ou domÃ­nio de negÃ³cio.
ğŸ”„ AtualizaÃ§Ã£o frequente: diagramas desatualizados causam confusÃ£o.

ğŸ› ï¸ Ferramentas recomendadas
Ferramenta	Tipo	Destaques
StarUML	Formal	Suporte completo a UML e C4
Whimsical	Livre	Interface visual moderna, ideal para brainstorming
Miro	Livre	ColaboraÃ§Ã£o em tempo real, Ã³timo para times remotos
Excalidraw	Livre	Estilo manuscrito, ideal para apresentaÃ§Ãµes visuais leves
Draw.io (diagrams.net)	Misto	GrÃ¡tis, suporta tanto diagramas formais quanto livres
Eraser.io	Livre	Visual limpo, excelente para wireframes e fluxos leves


1.12 DocumentaÃ§Ãµes arquiteturais: Design Docs e ADRs

A documentaÃ§Ã£o arquitetural Ã© essencial para registrar decisÃµes tÃ©cnicas, justificativas e impactos de longo prazo em sistemas de software. Ela ajuda times a manterem alinhamento, facilita onboarding e evita a repetiÃ§Ã£o de discussÃµes tÃ©cnicas jÃ¡ resolvidas.

ğŸ§¾ Design Docs (Design Documents)
ğŸ”¹ Documento que descreve como serÃ¡ construÃ­da uma soluÃ§Ã£o tÃ©cnica antes da implementaÃ§Ã£o.

âœ… Objetivos:
Comunicar ideias tÃ©cnicas com clareza.
Discutir abordagens e validar decisÃµes.
Antecipar riscos, impactos e alternativas.
Servir como plano de referÃªncia para desenvolvimento.

ğŸ“‘ Estrutura comum de um Design Doc:
TÃ­tulo e autores	Nome do documento e responsÃ¡veis pela proposta
Contexto	DescriÃ§Ã£o do problema ou necessidade
Objetivos e escopo	O que serÃ¡ resolvido e o que estÃ¡ fora do escopo
Proposta tÃ©cnica	SoluÃ§Ã£o detalhada, tecnologias envolvidas, fluxos
Alternativas consideradas	Outras opÃ§Ãµes analisadas e por que foram descartadas
Riscos	Riscos tÃ©cnicos, de negÃ³cio ou operacionais
Plano de implementaÃ§Ã£o	Etapas, entregas e responsÃ¡veis
Anexos	Diagramas, links, POCs, benchmarks, etc.

ğŸ“Œ Quando usar:
Projetos mÃ©dios/grandes.
Novas integraÃ§Ãµes ou mudanÃ§as arquiteturais relevantes.
RefatoraÃ§Ãµes com impacto em mÃºltiplos mÃ³dulos.


ğŸ§  ADRs (Architecture Decision Records) *um histÃ³rico
ğŸ”¸ SÃ£o registros curtos e objetivos de decisÃµes arquiteturais importantes.

âœ… Objetivos:
Documentar o que foi decidido, por que e quando.
Manter histÃ³rico tÃ©cnico.
Facilitar o entendimento futuro das decisÃµes.

ğŸ“‘ Estrutura tÃ­pica de um ADR:
SeÃ§Ã£o	DescriÃ§Ã£o
TÃ­tulo	Nome da decisÃ£o
Status	Proposto, Aceito, Rejeitado, etc.
Contexto	SituaÃ§Ã£o que levou Ã  necessidade da decisÃ£o
DecisÃ£o	O que foi decidido
ConsequÃªncias	Resultados esperados e efeitos colaterais

ğŸ“Œ Quando usar:
Toda vez que uma decisÃ£o tÃ©cnica importante for tomada.
SubstituiÃ§Ã£o de tecnologias, padrÃµes ou integraÃ§Ãµes.
MudanÃ§as de regras ou diretrizes tÃ©cnicas.

ğŸ› ï¸ Ferramentas Ãºteis para manter Design Docs e ADRs:
Google Docs / Notion (colaborativo, fÃ¡cil de versionar).
Markdown + Git (rastreÃ¡vel, versionado com cÃ³digo).
ADR Tools: adr-tools, adr-log.

1.13 O que Ã© System Design e System Design Interview ?

System Design (ou projeto de sistemas) Ã© o processo de planejar a arquitetura de um sistema de software complexo, considerando escalabilidade, desempenho, disponibilidade, seguranÃ§a, manutenibilidade e custos.

Ã‰ usado principalmente em sistemas distribuÃ­dos, aplicaÃ§Ãµes web em larga escala, sistemas crÃ­ticos, etc.

ğŸ” Envolve decisÃµes como:
Componentes principais: serviÃ§os, bancos de dados, filas, cache, APIs etc.
Como se comunicam: REST, gRPC, eventos, mensageria...
Onde sÃ£o implantados: cloud, containers, regiÃµes geogrÃ¡ficas...
Como escalam: balanceadores de carga, particionamento (sharding), replicaÃ§Ã£o...
Como sÃ£o tolerantes a falhas: retries, circuit breaker, redundÃ¢ncia...
Monitoramento, seguranÃ§a, backups, deploy contÃ­nuo, etc.

ğŸ§± Exemplos de sistemas a projetar:
Um clone do Instagram
Um serviÃ§o de encurtador de URL
Uma API de feed em tempo real
Um sistema de filas como o Uber
Uma arquitetura de microserviÃ§os para um e-commerce

ğŸ§ª O que Ã© a System Design Interview?
Ã‰ um tipo de entrevista tÃ©cnica muito comum em empresas de tecnologia, principalmente em grandes empresas (Big Techs), para cargos de engenheiro de software, tech lead e arquiteto.

ğŸ“š O que Ã© avaliado na entrevista:
CritÃ©rio	O que esperam
Clareza de pensamento	Entender o problema antes de sair desenhando
Capacidade de abstraÃ§Ã£o	Quebrar o sistema em partes significativas
DecisÃµes arquiteturais	Escolher tecnologias e justificar
Design escalÃ¡vel e resiliente	Planejar para crescimento e falhas
ComunicaÃ§Ã£o	Conseguir explicar e colaborar com entrevistador

ğŸ§© Estrutura tÃ­pica da entrevista:
Recebe o problema â€“ Ex: â€œProjete um serviÃ§o de mensagens como o WhatsAppâ€.
Faz perguntas de escopo â€“ Quem sÃ£o os usuÃ¡rios? Volume? LatÃªncia?
Define requisitos funcionais e nÃ£o funcionais
Desenha um diagrama de alto nÃ­vel
Detalha componentes â€“ banco, cache, fila, storage, balanceamento...
Fala sobre escalabilidade, seguranÃ§a, tradeoffs e gargalos
(Opcional): monitoraÃ§Ã£o, deploy, logging, fallback...


â€œSystem Design Ã© sobre resolver problemas do mundo real com software confiÃ¡vel, escalÃ¡vel e compreensÃ­vel.â€

ğŸ“Œ Dica para estudar:
Leia livros como â€œDesigning Data-Intensive Applicationsâ€ (Martin Kleppmann)

Pratique com sites como:
System Design Primer (GitHub) https://github.com/donnemartin/system-design-primer
ByteByteGo https://www.bytebytego.com/
ExercÃ­cios de system design no LeetCode Discuss https://leetcode.com/discuss/interview-question/system-design
FaÃ§a diagramas no papel ou ferramentas como Draw.io



2.1 â€“ Conhecendo a Arquitetura MonolÃ­tica e os MonÃ³litos ClÃ¡ssicos

ğŸ›ï¸ O que Ã© uma Arquitetura MonolÃ­tica?
Uma arquitetura monolÃ­tica Ã© aquela em que todo o sistema Ã© desenvolvido, implantado e executado como uma Ãºnica aplicaÃ§Ã£o. Todas as funcionalidades (mÃ³dulos, camadas, serviÃ§os) sÃ£o acopladas em um Ãºnico artefato binÃ¡rio.

ğŸ§± CaracterÃ­sticas do MonÃ³lito ClÃ¡ssico
ImplantaÃ§Ã£o Ãºnica	Um Ãºnico pacote (JAR, WAR, .EXE) que contÃ©m toda a aplicaÃ§Ã£o
Compartilhamento de memÃ³ria	Todos os mÃ³dulos compartilham o mesmo espaÃ§o de execuÃ§Ã£o
Tight coupling (alto acoplamento)	MudanÃ§as em um mÃ³dulo frequentemente afetam outros
Escalabilidade vertical	A escala Ã© feita aumentando o poder da mÃ¡quina onde o sistema roda
Facilidade inicial	FÃ¡cil de desenvolver e testar no inÃ­cio do projeto
Desafios de manutenÃ§Ã£o	Cresce rapidamente e se torna difÃ­cil de entender e evoluir

ğŸ“Œ Vantagens:
âœ… Simples de desenvolver e implantar inicialmente
âœ… DepuraÃ§Ã£o e testes facilitados no comeÃ§o
âœ… Menor complexidade operacional (um Ãºnico artefato para deploy)
âœ… IntegraÃ§Ã£o simples entre componentes (chamada direta, sem rede)

âš ï¸ Desvantagens:
âŒ Dificuldade de escalar partes especÃ­ficas da aplicaÃ§Ã£o
âŒ Lenta inicializaÃ§Ã£o e testes conforme cresce
âŒ Deploys arriscados: qualquer mudanÃ§a exige reimplantaÃ§Ã£o total
âŒ Baixa flexibilidade para adoÃ§Ã£o de novas tecnologias
âŒ Pode virar um â€œBig Ball of Mudâ€ (bola de lama) â€“ difÃ­cil de manter e entender


ğŸ“– Termo relacionado: Monolito Modulare
Ã‰ possÃ­vel ter um monÃ³lito organizado, com boa separaÃ§Ã£o de responsabilidades por meio de mÃ³dulos internos bem definidos, o que ajuda a manter a clareza e a evolutividade.
â¡ï¸ Isso Ã© diferente de um monolito bagunÃ§ado, sem separaÃ§Ã£o de responsabilidades.


ğŸ§± Tipos de MonÃ³litos
# MonÃ³lito Ruim (ou Big Ball of Mud)
Sem organizaÃ§Ã£o clara.
Baixa separaÃ§Ã£o de responsabilidades.
Classes gigantes e interdependentes.
Alta chance de bugs quando qualquer parte muda.
DifÃ­cil de testar e evoluir.
âš ï¸ Exemplo tÃ­pico de cÃ³digo legado difÃ­cil de manter.

# MonÃ³lito Modular
Organizado internamente em mÃ³dulos ou camadas bem definidas.
Utiliza princÃ­pios de design como DDD, camadas (controller/service/repository) ou hexagonal.
Embora esteja num Ãºnico artefato, cada mÃ³dulo tem limites claros de responsabilidade.
Mais fÃ¡cil de entender, manter e eventualmente migrar para microserviÃ§os, se necessÃ¡rio.
âœ… Boa prÃ¡tica em muitos projetos menores e mÃ©dios.

# MonÃ³lito DistribuÃ­do (ou "pseudosserviÃ§os")
Aparentemente dividido em pacotes/layers/comunicaÃ§Ã£o via REST ou mensageria dentro da mesma aplicaÃ§Ã£o.
Tenta imitar microserviÃ§os sem realmente separar em processos independentes.
Pode introduzir complexidade desnecessÃ¡ria sem os benefÃ­cios reais da arquitetura distribuÃ­da.
âš ï¸ Muito comum quando se tenta "forÃ§ar" microserviÃ§os dentro de um monÃ³lito.

# MonÃ³lito com Frontend e Backend Acoplados
Interface do usuÃ¡rio e backend estÃ£o no mesmo repositÃ³rio, servidor e ciclo de deploy.
Pode ser simples de manter no inÃ­cio, mas traz desafios para times separados e evoluÃ§Ã£o do frontend.
Muito comum em sistemas antigos com JSP, JSF, PHP puro, ASP.NET clÃ¡ssico, etc.

# MonÃ³lito com Gateway Modular
Um estilo onde o monÃ³lito Ã© estruturado com mÃ³dulos de domÃ­nio desacoplados, mas controlado por um gateway central que orquestra as chamadas.
Ajuda a manter a coesÃ£o e controlar melhor a responsabilidade dos domÃ­nios.
Pode ser evoluÃ­do facilmente para microserviÃ§os.

2.2. OrganizaÃ§Ã£o de equipes e a Lei de Conway

ğŸ§  O que diz a Lei de Conway?
"As organizaÃ§Ãµes que projetam sistemas sÃ£o limitadas a produzir designs que sÃ£o cÃ³pias da estrutura de comunicaÃ§Ã£o dessas organizaÃ§Ãµes."
â€” Melvin Conway, 1967
Ou seja:
A forma como sua equipe se comunica e se organiza influencia diretamente na estrutura do software que ela constrÃ³i.

ğŸ“¦ Exemplificando na prÃ¡tica:
Se uma organizaÃ§Ã£o tem 3 equipes isoladas, o sistema provavelmente terÃ¡ 3 mÃ³dulos principais mal integrados.
Se o time de frontend e backend mal se comunicam, o sistema resultarÃ¡ em interfaces engessadas e APIs mal projetadas.
Se hÃ¡ departamentos burocrÃ¡ticos separados, o software serÃ¡ acoplado e inflexÃ­vel, refletindo essa lentidÃ£o.

ğŸ—ï¸ ImplicaÃ§Ãµes arquiteturais
A arquitetura de software deve espelhar conscientemente a estrutura das equipes â€” ou seja:
Arquitetura orientada a times: cada equipe Ã© responsÃ¡vel por um mÃ³dulo ou domÃ­nio de negÃ³cio.
Facilita ownership (propriedade de cÃ³digo) e autonomia.
Reduz dependÃªncias e gargalos de comunicaÃ§Ã£o.
Cria interfaces mais coesas e limites de contexto mais claros (ex: DDD e Bounded Contexts).

ğŸ§© Lei de Conway vs. InversÃ£o de Conway (Conway's Law Inverted)
Lei de Conway (tradicional): estrutura da equipe influencia o design do sistema.
InversÃ£o da Lei de Conway (ou Arquitetura Direcionando Times):
VocÃª propositalmente estrutura a equipe de acordo com a arquitetura desejada.
"Se vocÃª quer uma arquitetura modular e escalÃ¡vel, estruture seus times modular e escalavelmente."

ğŸ‘¥ Tipos de times (modelo Team Topologies)
Stream-aligned	Foco em fluxo de valor (produto ou domÃ­nio)
Platform	Suporte aos demais times com infraestrutura
Enabling	Apoia outros times em conhecimento tÃ©cnico
Complicated Subsystem	Especialistas em lÃ³gica de alto nÃ­vel tÃ©cnico

A adoÃ§Ã£o de arquiteturas como microserviÃ§os sÃ³ Ã© sustentÃ¡vel com times que seguem esse tipo de divisÃ£o inteligente.

ğŸ§­ Dica para arquitetos:
Antes de desenhar seu sistema, observe como os times estÃ£o organizados.
Melhor ainda: ajude a organizar os times para refletir a arquitetura desejada.


2.3. Arquitetura monolÃ­tica nÃ£o Ã© legado!

Mito: â€œSe Ã© monolito, Ã© legado, velho ou ruim.â€
Verdade: "MonÃ³lito â‰  legado.
MonÃ³lito Ã© apenas um estilo arquitetural. Ele pode ser moderno, bem projetado, performÃ¡tico e escalÃ¡vel."

âœ… Quando o monolito Ã© uma boa escolha?
Projetos pequenos ou mÃ©dios, com uma equipe menor.
Quando a velocidade de entrega Ã© importante.
Para evitar complexidade prematura dos microserviÃ§os.
Quando se deseja manter a simplicidade de deploy e monitoramento.

â€œStart monolithic, break apart when necessÃ¡rioâ€
â€” PrincÃ­pio comum em arquiteturas evolutivas.

âš ï¸ Por que microserviÃ§os nÃ£o sÃ£o soluÃ§Ã£o mÃ¡gica?
MicroserviÃ§os exigem maturidade organizacional (infraestrutura, devops, observabilidade, times dedicados).
Aumentam a complexidade de deploy, versionamento e comunicaÃ§Ã£o.
AplicaÃ§Ãµes simples se tornam overengineered se forem quebradas em microsserviÃ§os sem necessidade.

â— Ser monolÃ­tico nÃ£o Ã© um problema.
O problema Ã© ser mal estruturado, confuso e difÃ­cil de manter â€” isso sim Ã© legado.


2.4 Pesadelo dos monÃ³litos: quando tudo sai do controle ( Monolithic Hell)

â€œO problema nÃ£o Ã© o monÃ³lito em si, e sim quando ele se torna um monolito monstro, inchado, acoplado e impossÃ­vel de mudar.â€

ğŸ§¨ O que Ã© o "Monolithic Hell"?
Ã‰ quando o monÃ³lito foge do controle, causando dor e paralisia na evoluÃ§Ã£o do sistema.

âš ï¸ Sinais claros do inferno monolÃ­tico:
ğŸ˜± Deploys demorados e arriscados	Um pequeno ajuste exige subir o sistema inteiro, com alto risco de quebra.
ğŸ”„ Tudo depende de tudo	MÃ³dulos fortemente acoplados, difÃ­ceis de testar ou modificar isoladamente.
ğŸ§© CÃ³digo duplicado e confuso	Falta de coesÃ£o, com funcionalidades repetidas e mal organizadas.
ğŸ› ï¸ ManutenÃ§Ã£o se torna terror	Alterar uma regra de negÃ³cio pode quebrar funcionalidades em Ã¡reas nÃ£o relacionadas.
ğŸ§± Camadas mal definidas	Front, serviÃ§o e repositÃ³rios misturados; regras de negÃ³cio espalhadas.
ğŸŒ Time se move devagar	O sistema Ã© tÃ£o complexo que atÃ© tarefas simples levam semanas.
ğŸ¤ Falta de ownership	Todos mexem em tudo; ninguÃ©m Ã© dono de nada.
ğŸ˜µâ€ğŸ’« Dificuldade de escalar times	VÃ¡rias pessoas trabalhando no mesmo mÃ³dulo geram conflitos constantes.

ğŸ’£ Causas comuns:
Falta de modularizaÃ§Ã£o interna.
DesorganizaÃ§Ã£o de camadas e responsabilidades.
Acoplamento entre funcionalidades nÃ£o relacionadas.
Crescimento desgovernado do sistema, sem refatoraÃ§Ãµes.
NegligÃªncia com prÃ¡ticas de design e arquitetura.


ğŸš‘ Como fugir do pesadelo:
ğŸ§¹ Refatorar e modularizar	Organiza responsabilidades e melhora o entendimento do cÃ³digo.
ğŸ§ª Investir em testes automatizados	Reduz medo de mudanÃ§as e regressÃµes.
ğŸ§­ Adotar arquitetura em camadas ou DDD	Melhora separaÃ§Ã£o de responsabilidades.
ğŸ§± Criar Bounded Contexts	Isola domÃ­nios de negÃ³cio que crescem separadamente.
ğŸ§ª Dividir o deploy por Ã¡reas de negÃ³cio	Rumo a uma arquitetura distribuÃ­da, como microsserviÃ§os ou mÃ³dulos independentes.

ğŸ’¡ ConclusÃ£o:
O monÃ³lito pode ser saudÃ¡vel, mas sem disciplina arquitetural, ele cresce como uma bola de neve desgovernada.
Quando chega nesse ponto, o custo de manter supera o custo de evoluir para algo mais modular.

2.5 Conhecendo a arquitetura de microsserviÃ§os

A arquitetura de microsserviÃ§os Ã© um estilo onde o sistema Ã© dividido em serviÃ§os pequenos, independentes e autÃ´nomos, que comunicam entre si por meio de redes (geralmente HTTP/REST, gRPC, mensageria etc).

Cada microsserviÃ§o Ã© focado em uma Ãºnica responsabilidade de negÃ³cio.

ğŸ¯ Objetivo principal
Permitir que cada parte da aplicaÃ§Ã£o evolua, escale e seja implantada de forma independente.

ğŸ§± CaracterÃ­sticas principais
ğŸ¯ Foco em domÃ­nio Ãºnico	Cada microsserviÃ§o cuida de uma parte especÃ­fica do negÃ³cio.
ğŸ› ï¸ Deploys independentes	Um serviÃ§o pode ser atualizado sem afetar os outros.
ğŸŒ ComunicaÃ§Ã£o via rede	REST, gRPC, mensageria (RabbitMQ, Kafka etc.).
ğŸ’¾ Banco de dados independente	Cada serviÃ§o gerencia seu prÃ³prio banco (desacoplamento de dados).
ğŸ‘¥ Times independentes	Time pode ser dono de um ou mais microsserviÃ§os.
ğŸ§ª ResiliÃªncia e tolerÃ¢ncia a falhas	Cada serviÃ§o lida com suas falhas isoladamente.


ğŸ§ª Vantagens
ğŸ“¦ Escalabilidade individual por serviÃ§o.
ğŸš€ Agilidade no desenvolvimento e deploy.
ğŸ”„ Facilidade de manter e evoluir partes especÃ­ficas.
ğŸ” Observabilidade clara por serviÃ§o (logs, mÃ©tricas, tracing).
ğŸ§­ AdoÃ§Ã£o mais fÃ¡cil de DDD e Bounded Contexts.

âš ï¸ Desvantagens / Desafios
ğŸ“¡ Complexidade de comunicaÃ§Ã£o	Redes sÃ£o mais frÃ¡geis que chamadas locais.
ğŸ”€ Gerenciamento de transaÃ§Ãµes distribuÃ­das	Evitar commit em mÃºltiplos bancos Ã© difÃ­cil.
ğŸ¯ GovernanÃ§a e versionamento de APIs	ServiÃ§os mudam e precisam manter compatibilidade.
ğŸ“¦ Infraestrutura robusta exigida	Precisa de CI/CD, containers (Docker), orquestraÃ§Ã£o (Kubernetes), etc.
ğŸ” Observabilidade e rastreamento	NecessÃ¡rio investir em logs centralizados, tracing, dashboards etc.

âœ… Quando vale a pena usar?
Projeto com grande escala ou mÃºltiplos domÃ­nios complexos.
OrganizaÃ§Ã£o com mÃºltiplos times trabalhando de forma paralela.
Necessidade de alta disponibilidade e escalabilidade granular.
JÃ¡ existe maturidade em infraestrutura (DevOps, automaÃ§Ã£o, observabilidade).


2.6 MicrosserviÃ§os possuem seus prÃ³prios estados

ğŸ¯ PrincÃ­pio fundamental dos microsserviÃ§os:
Cada microsserviÃ§o Ã© responsÃ¡vel por seu prÃ³prio estado e dados.

Isso significa que cada serviÃ§o possui e controla sua prÃ³pria base de dados, sem compartilhamento direto com outros serviÃ§os.

ğŸ§± Por que isso Ã© importante?
ğŸ”— Desacoplamento	ServiÃ§os nÃ£o dependem de bancos de dados externos.
ğŸš€ Deploys independentes	VocÃª pode alterar um banco sem afetar outros serviÃ§os.
ğŸ“Š Escalabilidade separada	Cada serviÃ§o pode otimizar sua base de dados conforme a necessidade.
ğŸ”’ Isolamento de falhas	Se um banco falhar, os demais continuam funcionando.

âš ï¸ AntipadrÃ£o a evitar: Banco de dados compartilhado
Se vÃ¡rios microsserviÃ§os acessam o mesmo banco de dados, vocÃª tem um banco monolÃ­tico, nÃ£o microsserviÃ§os de verdade.

ğŸ’¬ Como os serviÃ§os se comunicam entÃ£o?
A comunicaÃ§Ã£o entre serviÃ§os acontece via APIs ou mensageria, e nunca diretamente via banco de dados.

Exemplo:
OrderService precisa de dados do UserService â†’ faz uma chamada HTTP ou envia um evento.
Nunca faz um SELECT direto na base do UserService.

ğŸ“¦ TransaÃ§Ãµes distribuÃ­das? Cuidado!
Evite dependÃªncia de transaÃ§Ãµes ACID entre serviÃ§os. Em vez disso, use:
âœ… Eventual consistency (consistÃªncia eventual).
âœ… Sagas para orquestrar mÃºltiplas etapas entre serviÃ§os.
âœ… Eventos assÃ­ncronos para manter os dados atualizados entre domÃ­nios.

ğŸ§  Cada serviÃ§o, seu prÃ³prio modelo
AlÃ©m do banco, cada microsserviÃ§o pode ter seu prÃ³prio modelo de dados (linguagem, formato, estrutura), ideal para aquele domÃ­nio especÃ­fico.

MicrosserviÃ§o deve..
Ter sua prÃ³pria base de dados:	Garante independÃªncia e escalabilidade.
Controlar seu estado interno:	Evita dependÃªncia cruzada.
Expor dados via API ou eventos:	MantÃ©m contratos bem definidos.

2.7 MicrosserviÃ§os se comunicam via rede em uma arquitetura distribuÃ­da

ğŸŒ VisÃ£o geral
Na arquitetura de microsserviÃ§os, cada serviÃ§o Ã© executado de forma independente e se comunica com os demais atravÃ©s da rede, formando uma arquitetura distribuÃ­da.

ğŸ”— O que Ã© uma arquitetura distribuÃ­da?
Ã‰ uma arquitetura onde mÃºltiplos serviÃ§os autÃ´nomos estÃ£o espalhados em diferentes ambientes (containers, VMs, servidores) e interagem entre si via rede.

Cada microsserviÃ§o pode estar:
- Em mÃ¡quinas diferentes
- Em data centers diferentes
- Em nÃ³s diferentes de um cluster Kubernetes

ğŸ“¡ Formas de comunicaÃ§Ã£o entre microsserviÃ§os
Tipo	DescriÃ§Ã£o	Exemplo
ğŸ” SÃ­ncrona (sincrÃ´nica)	A chamada espera a resposta.	REST (HTTP), gRPC
ğŸ” AssÃ­ncrona	A chamada Ã© enviada e processada depois.	Mensageria (RabbitMQ, Kafka)

ğŸ“¶ Protocolos comuns
HTTP/HTTPS (REST) â†’ mais comum, simples e legÃ­vel
gRPC â†’ mais rÃ¡pido, binÃ¡rio, ideal para alta performance
AMQP/Kafka â†’ comunicaÃ§Ã£o assÃ­ncrona por eventos


ğŸ§© ImplicaÃ§Ãµes da comunicaÃ§Ã£o via rede
ImplicaÃ§Ã£o	ExplicaÃ§Ã£o
âŒ A rede falha	ComunicaÃ§Ã£o pode cair, deve haver retry e fallback
â±ï¸ LatÃªncia	Chamadas sÃ£o mais lentas que chamadas locais
ğŸ”’ SeguranÃ§a	Deve-se usar autenticaÃ§Ã£o, criptografia e controle de acesso
ğŸ•µï¸â€â™‚ï¸ Observabilidade	Logs, tracing e mÃ©tricas sÃ£o fundamentais para entender o trÃ¡fego entre serviÃ§os
ğŸ“ Versionamento de APIs	MudanÃ§as em contratos afetam outros serviÃ§os

ğŸ§  Boas prÃ¡ticas
âœ… Usar circuit breakers (como Resilience4j, Hystrix)
âœ… Implementar timeout e retries
âœ… Preferir comunicaÃ§Ã£o assÃ­ncrona quando possÃ­vel (eventos)
âœ… Usar APIs bem definidas e versionadas
âœ… Monitorar com logs centralizados, tracing distribuÃ­do, dashboards


2.8 MicrosserviÃ§os sÃ£o autÃ´nomos e independentes

Em uma arquitetura de microsserviÃ§os, cada serviÃ§o Ã© uma unidade independente, que pode ser desenvolvido, testado, implantado, escalado e mantido separadamente dos demais.

Autonomia	| IndependÃªncia
Cada serviÃ§o toma decisÃµes sozinho	| Pode ser executado sem precisar dos outros
Tem sua lÃ³gica de negÃ³cio isolada	| Ã‰ desenvolvido e versionado separadamente
Gerencia seu prÃ³prio banco de dados | Pode ser implantado de forma individual
ExpÃµe sua prÃ³pria API	| Pode ser escalado conforme sua demanda

ğŸ“¦ Exemplo prÃ¡tico
Imagine um sistema de e-commerce com trÃªs microsserviÃ§os:
UserService â€“ gerencia usuÃ¡rios
OrderService â€“ gerencia pedidos
ProductService â€“ gerencia produtos

Cada um:

Tem sua base de dados prÃ³pria
Possui repositÃ³rio de cÃ³digo separado
Pode ser implantado de forma independente
Se comunica com os outros via APIs ou eventos

âš™ï¸ BenefÃ­cios dessa independÃªncia
BenefÃ­cio	DescriÃ§Ã£o
ğŸš€ Deploys independentes	VocÃª atualiza um serviÃ§o sem afetar os outros
ğŸ§ª Testabilidade	Pode testar cada serviÃ§o isoladamente
ğŸ”„ Ciclo de vida separado	Cada equipe pode manter seu serviÃ§o com autonomia
ğŸ“ˆ Escalabilidade sob demanda	Escala somente o serviÃ§o que precisa
ğŸ” ResiliÃªncia	Uma falha em um serviÃ§o nÃ£o derruba o sistema todo

âš ï¸ Desafios a considerar
Desafio	Abordagem recomendada
ğŸ¤ IntegraÃ§Ã£o entre serviÃ§os	APIs bem definidas + eventos
ğŸ“‰ DependÃªncia indesejada	Evitar chamadas cruzadas em excesso
ğŸ” Observabilidade distribuÃ­da	Usar tracing, logs centralizados e mÃ©tricas
ğŸš§ GerÃªncia de versÃµes de APIs	Versionamento e contratos bem definidos

ğŸ“˜ Resumo
Conceito	DescriÃ§Ã£o
Autonomia	Cada microsserviÃ§o Ã© dono de seu domÃ­nio
IndependÃªncia	Pode funcionar, escalar e evoluir sozinho
Boas prÃ¡ticas	APIs estÃ¡veis, banco prÃ³prio, deploy isolado
Desafios	IntegraÃ§Ã£o, observabilidade e versionamento

2.9 MicrosserviÃ§os sÃ£o componentes pequenos e coesos

Pequeno -> fÃ¡cil de entender e modificar
Grande -> Ãºtil e resolve um problema completo
Escopo coeso e bem definido

ğŸ§© O que isso significa?
Em uma arquitetura de microsserviÃ§os, cada serviÃ§o Ã© projetado para ser:
Pequeno: focado em uma Ãºnica responsabilidade de negÃ³cio.
Coeso: suas partes internas estÃ£o altamente relacionadas e trabalham juntas por um Ãºnico propÃ³sito.

ğŸ¯ PrincÃ­pio de coesÃ£o
Um serviÃ§o coeso faz uma Ãºnica coisa bem feita. Toda sua lÃ³gica gira em torno de um Ãºnico domÃ­nio ou contexto.

ğŸ“Œ Exemplo:
Um PaymentService sÃ³ lida com pagamentos â€“ ele nÃ£o deve validar login, cadastrar produtos ou enviar e-mails.

âš ï¸ Riscos se nÃ£o forem pequenos e coesos
ServiÃ§os inchados viram â€œmini-monÃ³litosâ€.
Baixa coesÃ£o gera forte acoplamento entre serviÃ§os.
Dificuldade de escalar individualmente.
Complexidade na manutenÃ§Ã£o aumenta com o tempo.


2.10 MicrosserviÃ§os possuem flexibilidade tecnolÃ³gica

ğŸ§ª DefiniÃ§Ã£o
Uma das principais vantagens da arquitetura de microsserviÃ§os Ã© que cada serviÃ§o pode ser desenvolvido usando a tecnologia mais apropriada para ele, de forma independente dos demais.

ğŸ”§ O que Ã© essa flexibilidade?
Significa que linguagens de programaÃ§Ã£o, bancos de dados, frameworks, bibliotecas e atÃ© mesmo estratÃ©gias de deploy podem variar entre os microsserviÃ§os.

ğŸ§  Por que isso Ã© possÃ­vel?
Porque os microsserviÃ§os sÃ£o:
Isolados (rodam em seus prÃ³prios processos)
AutÃ´nomos (nÃ£o compartilham cÃ³digo ou banco)
Comunicam-se via rede (APIs REST, gRPC, eventos etc.)

Em um sistema completo:

ServiÃ§o	Tecnologia usada
UserService	Java + Spring Boot + PostgreSQL
AuthService	Node.js + JWT + Redis
PaymentService	Python + Flask + MongoDB
NotificationService	Go + RabbitMQ

âœ… Vantagens da flexibilidade tecnolÃ³gica
Vantagem	DescriÃ§Ã£o
ğŸ¯ Ferramenta certa para o problema certo	Usa a tecnologia ideal para cada cenÃ¡rio
ğŸ§ª ExperimentaÃ§Ã£o segura	Testa novas ferramentas sem afetar o todo
ğŸ“š Aproveitamento de especialidades da equipe	Cada time pode usar a stack com que jÃ¡ Ã© familiar
ğŸ”„ EvoluÃ§Ã£o tecnolÃ³gica gradual	Pode modernizar um serviÃ§o sem reescrever todo o sistema

âš ï¸ Desafios e cuidados
Desafio	EstratÃ©gia para lidar
ğŸ¤ IntegraÃ§Ã£o entre linguagens	Usar padrÃµes de API bem definidos (REST, gRPC, eventos)
ğŸ“¦ Complexidade no deploy	Automatizar com CI/CD e containers
ğŸ‘©â€ğŸ’» Curva de aprendizado mÃºltipla	Definir guidelines e boas prÃ¡ticas para stacks diversas
ğŸ“Š Observabilidade e monitoramento	Padronizar logs, mÃ©tricas e tracing, mesmo em stacks diferentes

2.11 MicrosserviÃ§os sÃ£o implantados de forma independente 

ğŸš€ O que significa?
Na arquitetura de microsserviÃ§os, cada serviÃ§o pode ser desenvolvido, testado e implantado de forma autÃ´noma, sem precisar sincronizar o deploy com os demais.
Ou seja:
Um microsserviÃ§o pode ser atualizado e colocado em produÃ§Ã£o sem interferir no funcionamento dos outros.

2.12 MicrosserviÃ§os sÃ£o resilientes e tolerantes a falhas

ResiliÃªncia Ã© a capacidade de um sistema continuar funcionando mesmo quando partes dele falham.

Na arquitetura de microsserviÃ§os, isso significa que, mesmo que um serviÃ§o esteja temporariamente indisponÃ­vel ou com problemas, o restante do sistema deve continuar operando de forma controlada.

âš™ï¸ Por que isso Ã© importante?
Porque microsserviÃ§os sÃ£o:
DistribuÃ­dos, ou seja, rodam em mÃ¡quinas diferentes.
Conectados via rede, que pode ser lenta ou falhar.
Implantados independentemente, logo, podem estar em versÃµes diferentes

ğŸ§  Conceitos-chave de tolerÃ¢ncia a falhas
Conceito	DescriÃ§Ã£o
ğŸ” Retry (tentativa novamente)	Tenta repetir uma requisiÃ§Ã£o quando hÃ¡ falha temporÃ¡ria.
â›” Timeouts	Define tempo limite para respostas, evitando que um serviÃ§o fique esperando indefinidamente.
ğŸ’¥ Circuit Breaker	Interrompe chamadas para serviÃ§os instÃ¡veis, evitando efeito cascata.
ğŸ§Š Fallback	Define uma resposta alternativa quando o serviÃ§o de origem estÃ¡ indisponÃ­vel.
ğŸ›‘ Bulkhead (Compartimentos)	Isola falhas para que nÃ£o se propaguem a outros serviÃ§os.
ğŸ“ˆ Monitoramento e observabilidade	Detecta e reage rapidamente a falhas e degradaÃ§Ãµes.


2.13 MicrosserviÃ§os sÃ£o escalÃ¡veis de forma independente

Em uma arquitetura de microsserviÃ§os, cada serviÃ§o pode ser escalado separadamente, conforme suas necessidades de carga e uso.

Ou seja, vocÃª pode aumentar a capacidade (horizontal ou vertical) apenas dos serviÃ§os mais demandados, sem precisar escalar todo o sistema.

ğŸ§  Por que isso importa?
Em sistemas monolÃ­ticos, para escalar um mÃ³dulo especÃ­fico (ex: processamento de pagamento), vocÃª precisa escalar toda a aplicaÃ§Ã£o, mesmo que os outros mÃ³dulos estejam ociosos.

Com microsserviÃ§os:
O PagamentoService pode ter 10 instÃ¢ncias.
O RelatorioService, que quase nÃ£o Ã© acessado, pode ter apenas 1.

ğŸ‘‰ Isso torna o uso de recursos mais eficiente e econÃ´mico.

âš™ï¸ Tipos de escalabilidade
Tipo	DescriÃ§Ã£o
ğŸ”„ Escalabilidade horizontal	Adicionar mais instÃ¢ncias do serviÃ§o
â¬†ï¸ Escalabilidade vertical	Aumentar CPU, memÃ³ria ou recursos da instÃ¢ncia
ğŸ¯ Escalabilidade seletiva	Escalar somente os serviÃ§os necessÃ¡rios, com base na demanda


# 3.1. PrÃ¡ticas e tecnologias facilitadoras

ğŸ‘¥ Times AutÃ´nomos
Times autÃ´nomos sÃ£o equipes multidisciplinares e auto-organizadas, com autonomia para tomar decisÃµes tÃ©cnicas e de produto. Eles sÃ£o responsÃ¡veis pelo ciclo completo do serviÃ§o: concepÃ§Ã£o, desenvolvimento, testes, implantaÃ§Ã£o, monitoramento e manutenÃ§Ã£o.

CaracterÃ­sticas:
Multifuncionais: desenvolvedores, testers, DevOps, product owner.
Autonomia: tomam decisÃµes sem precisar de constantes aprovaÃ§Ãµes externas.
Accountability: sÃ£o responsÃ¡veis pelo sucesso e qualidade do serviÃ§o que operam.
Ciclo completo: do cÃ³digo Ã  produÃ§Ã£o ("you build it, you run it").

ğŸ§± Estrutura Descentralizada
A estrutura descentralizada rompe com o modelo hierÃ¡rquico tradicional. Em vez de uma cadeia de decisÃµes Ãºnica e centralizada:

Cada time Ã© dono de seus prÃ³prios serviÃ§os ou domÃ­nios.
A organizaÃ§Ã£o cresce com base em times pequenos e independentes.
A coordenaÃ§Ã£o Ã© feita por alinhamento de objetivos (visÃ£o de produto, OKRs, padrÃµes de arquitetura), nÃ£o por comando e controle.
Essa abordagem facilita a escalabilidade organizacional e se alinha com arquiteturas distribuÃ­das, como microsserviÃ§os.


Service Per Team Pattern

Ã‰ um padrÃ£o onde cada time Ã© responsÃ¡vel por um ou mais serviÃ§os (geralmente um Ãºnico serviÃ§o), assumindo total responsabilidade pelo seu ciclo de vida completo: desenvolvimento, testes, implantaÃ§Ã£o, operaÃ§Ã£o e suporte.

ğŸ“¦ CaracterÃ­sticas principais
CaracterÃ­stica	DescriÃ§Ã£o
DomÃ­nio claro	Cada serviÃ§o pertence a um domÃ­nio de negÃ³cio bem definido.
Responsabilidade total	O time cuida do cÃ³digo, infraestrutura, monitoramento e correÃ§Ãµes.
Autonomia	O time tem liberdade para tomar decisÃµes tÃ©cnicas (dentro de padrÃµes globais).
Desacoplamento organizacional	Reduz dependÃªncia entre equipes, incentivando a escalabilidade organizacional.

ğŸ¯ Objetivo
Aumentar a agilidade na entrega de software.
Permitir que times evoluam seus serviÃ§os de forma independente.
Estimular a especializaÃ§Ã£o por domÃ­nio (ex: Pagamentos, Estoque, AutenticaÃ§Ã£o).

# 3.3. Manobra inversa da Lei de Conway

Ao invÃ©s de time separados por especialidade, teremos times funcionais que consigam testar cada etapa do software (back,front,etc).

# 3.4. Times pequenos e o conceito de Two Pizza Team

Qual tamanho de um time para cuidar de um microserviÃ§os? O time deve poder ser alimentado por 2 pizzas. kkkk ideia da amazon

# 3.5. Cultura de ownership e a mentalidade de produtos (e nÃ£o projetos)

"you build it, you run it"

Microservices sÃ£o produtos e nÃ£o projetos, deve ser mantido e continuado pela mesma equipe (responsabilidade pelo ciclo de vida do serviÃ§o). Cultura de Ownership 

Ownership (ou "sentimento de dono") Ã© quando os times tÃªm autonomia, responsabilidade e autoridade sobre os sistemas que desenvolvem e mantÃªm.

Eles nÃ£o apenas entregam funcionalidades, mas se preocupam com qualidade, performance, confiabilidade, escalabilidade e evoluÃ§Ã£o contÃ­nua do produto.

# 3.6. Team Topologies e os times em organizaÃ§Ãµes distribuÃ­das

Como estruturar os times de forma eficiente? 

Team Topologies Ã© um modelo moderno de organizaÃ§Ã£o de times de software, proposto por Matthew Skelton e Manuel Pais, que busca alinhar estrutura de times Ã  arquitetura do sistema, promovendo fluxo de entrega contÃ­nua, autonomia e escalabilidade.

Tipos de times: 

ğŸ§© Stream-aligned team: Foco em um fluxo de valor contÃ­nuo: linha de produto, jornada do cliente ou domÃ­nio de negÃ³cio. Ex: time responsÃ¡vel pelo app mobile do cliente final.
ğŸ›  Enabling team:	Ajuda outros times a adotarem prÃ¡ticas, ferramentas ou tecnologias. Ex: time de DevOps, engenharia de dados, boas prÃ¡ticas de testes.
ğŸ§± Complicated subsystem team:	Especialistas que cuidam de partes muito complexas do sistema. Ex: time de otimizaÃ§Ã£o de algoritmos, engenharia de machine learning.
ğŸ”§ Platform team:	Cria e mantÃ©m uma plataforma interna para facilitar o trabalho dos outros times (ciÃªncia da plataforma). Ex: time de CI/CD, observabilidade, autenticaÃ§Ã£o.

Modos de colaboraÃ§Ã£o:
ğŸ¤ ColaboraÃ§Ã£o:	Quando hÃ¡ incerteza, experimentaÃ§Ã£o ou inovaÃ§Ã£o. Curto prazo.	Time de produto trabalhando junto com time de dados para descobrir soluÃ§Ãµes.
ğŸ“¦ Como um serviÃ§o:	Para reutilizaÃ§Ã£o clara e padronizada.	Plataforma de deploy self-service oferecida pelo time de plataforma.
ğŸ§­ FacilitaÃ§Ã£o:	Quando um time ajuda outro a adquirir capacidades.	Time de DevOps ajudando times de produto a adotar pipelines de CI/CD.

OrganizaÃ§Ãµes DistribuÃ­das: por que isso importa?
Em times distribuÃ­dos:

A colaboraÃ§Ã£o Ã© mais difÃ­cil (fuso horÃ¡rio, linguagem, cultura);
Ã‰ essencial reduzir o acoplamento entre equipes;
Times precisam de autonomia real para escalar.
Team Topologies fornece um modelo para isso, permitindo que cada time se torne dono de uma parte do sistema com interaÃ§Ãµes bem definidas e intencionais.

3.7. Cultura DevOps

A Cultura DevOps vai muito alÃ©m de ferramentas como Docker, Jenkins ou Kubernetes. Ela representa uma mudanÃ§a profunda na forma como desenvolvimento e operaÃ§Ãµes trabalham juntos para entregar software com mais agilidade, seguranÃ§a, qualidade e confiabilidade.

Cultura:

- Quebrar silos entre desenvolvimento (Dev) e operaÃ§Ãµes (Ops);
- Aumentar a frequÃªncia de entrega (deploys mais rÃ¡pidos e frequentes);
- Reduzir falhas em produÃ§Ã£o com prÃ¡ticas de automaÃ§Ã£o e monitoramento;
- Criar um ciclo de feedback contÃ­nuo entre todos os envolvidos no ciclo de vida do software.

Fundamentos:

ğŸ”„ Ciclo ContÃ­nuo:	IntegraÃ§Ã£o contÃ­nua (CI), entrega contÃ­nua (CD), monitoramento contÃ­nuo.
ğŸ‘¥ ColaboraÃ§Ã£o:	Desenvolvedores, Ops, QA e outras Ã¡reas atuam juntos, desde o inÃ­cio.
ğŸ›  AutomaÃ§Ã£o:	Infraestrutura como cÃ³digo, pipelines CI/CD, testes automatizados.
ğŸ“Š MediÃ§Ã£o:	Tudo Ã© mensurado: tempo de deploy, falhas, tempo mÃ©dio de recuperaÃ§Ã£o.
ğŸ” SeguranÃ§a embutida:	DevSecOps: seguranÃ§a Ã© parte do ciclo de desenvolvimento desde o inÃ­cio.

Pilares:

1. IntegraÃ§Ã£o ContÃ­nua (CI): Automatiza a compilaÃ§Ã£o, testes e validaÃ§Ã£o do cÃ³digo a cada push.
2. Entrega ContÃ­nua (CD): Permite deploys frequentes e confiÃ¡veis, com aprovaÃ§Ã£o mÃ­nima.
3. Infraestrutura como CÃ³digo (IaC): Provisionamento e configuraÃ§Ã£o de ambientes via cÃ³digo (Ex: Terraform, Ansible).
4. Monitoramento ContÃ­nuo: Observabilidade de logs, mÃ©tricas e traces (Ex: Prometheus, Grafana, ELK Stack).
5. Feedback ContÃ­nuo: Coleta e anÃ¡lise de mÃ©tricas para decisÃµes rÃ¡pidas (Ex: incidentes, erros, feedback de clientes).

"DevOps nÃ£o Ã© uma equipe nem um cargo, Ã© uma cultura.
Ã‰ sobre pessoas, processos e ferramentas â€” nessa ordem."

3.8. Testes automatizados e PirÃ¢mide de Testes
*nÃ£o Ã© boa prÃ¡tica, Ã© essencial"
Os testes automatizados sÃ£o parte essencial de uma arquitetura moderna, principalmente quando falamos em DevOps, entrega contÃ­nua (CI/CD) e qualidade constante em ambientes distribuÃ­dos.

- Reduz o retrabalho e o tempo de validaÃ§Ã£o manual.
- Permite releases frequentes com mais seguranÃ§a.
- Detecta regressÃµes rapidamente.
- DÃ¡ confianÃ§a para refatorar cÃ³digo.

ğŸ”º PirÃ¢mide de Testes (Test Pyramid)

A pirÃ¢mide de testes Ã© um conceito criado por Mike Cohn, que orienta como distribuir os tipos de testes para garantir qualidade de forma eficiente e rÃ¡pida.

       [ UI / End-to-End Tests ]
                 (5-10%)
                ğŸ”¼
        [ Testes de IntegraÃ§Ã£o ]
              (15-20%)
                ğŸ”¼
         [ Testes de Contrato ]
               (10-15%)
                ğŸ”¼
        [ Testes UnitÃ¡rios ]
               (70-80%)


1. ğŸ§± Testes UnitÃ¡rios (Base)
- Testam unidades isoladas de cÃ³digo (funÃ§Ãµes, mÃ©todos, classes).
- Executam rapidamente.
- SÃ£o baratos de escrever e manter.
- Exemplos: JUnit, NUnit, Jest, Mocha.
ğŸ”¹ Regra de ouro: Devem representar 70% a 80% dos testes automatizados.

2. Testes de contratos
- Eles ficam entre os testes unitÃ¡rios e os testes de integraÃ§Ã£o, pois validam a comunicaÃ§Ã£o entre partes do sistema sem precisar de todo o ambiente rodando.
- Consumer-driven contracts: O consumidor define o que espera da API.
- Provider contracts: O provedor valida se cumpre o que prometeu.

3. ğŸ”— Testes de IntegraÃ§Ã£o (Meio da pirÃ¢mide)
- Testam mÃºltiplos mÃ³dulos juntos (ex: integraÃ§Ã£o com banco, serviÃ§os externos, etc).
- Validam se os componentes funcionam em conjunto.
- Exemplos: Testes com banco em memÃ³ria (H2), REST Assured, Postman.
ğŸ”¹ Recomendado: 15% a 20% dos testes.
- Test Containers

4. ğŸ­ Testes End-to-End (Topo da pirÃ¢mide)
- Simulam o comportamento do usuÃ¡rio final.
- SÃ£o mais lentos, caros de manter e suscetÃ­veis a falhas externas.
- Exemplos: Selenium, Cypress, Playwright.
ğŸ”¹ Ideal: 5% a 10%, apenas para os fluxos mais crÃ­ticos.

5. Testes de Carga
- Verificar se os microsserviÃ§os aguentam os acessos simultaneos e etc..
- Grafana K6 etc

3.9. Containers e orquestraÃ§Ã£o

Service Instance per container pattern

ğŸ“¦ Containers: o que sÃ£o?
Um container Ã© uma unidade leve, portÃ¡til e isolada que empacota: o cÃ³digo da aplicaÃ§Ã£o, suas dependÃªncias (bibliotecas, binÃ¡rios), e seu ambiente de execuÃ§Ã£o.

O container garante que a aplicaÃ§Ã£o rode de forma previsÃ­vel em qualquer lugar: local, nuvem, CI/CD etc.

ğŸ“ Por que containers sÃ£o ideais para microsserviÃ§os?

- Cada microsserviÃ§o pode ser empacotado em seu prÃ³prio container.
- Isolamento garante que falhas em um serviÃ§o nÃ£o afetam os outros.
- FÃ¡ceis de replicar, escalar e versionar.

âš™ï¸ OrquestraÃ§Ã£o: como gerenciar mÃºltiplos containers?
Com dezenas ou centenas de microsserviÃ§os, Ã© necessÃ¡rio automatizar:
- Deploy
- Escalonamento (auto-scale)
- AtualizaÃ§Ãµes sem downtime (rolling updates)
- Health checks
- ResiliÃªncia
- Balanceamento de carga

Ã‰ aÃ­ que entra a orquestraÃ§Ã£o.

ğŸ¤– Ferramentas de OrquestraÃ§Ã£o:
- Kubernetes (o padrÃ£o da indÃºstria)
- Docker Swarm (mais simples)
- Amazon ECS, Google GKE, Azure AKS (Kubernetes gerenciado)

ğŸ§  Como o Kubernetes ajuda?
Organiza os containers em Pods e os distribui em nÃ³s (nodes).

Lida com:
- Escalabilidade automÃ¡tica
- RecuperaÃ§Ã£o de falhas
- Rede entre serviÃ§os
- Secrets e configs
- CI/CD pipelines integrados

ğŸ§© Containers + OrquestraÃ§Ã£o = Chave para microsserviÃ§os
A combinaÃ§Ã£o permite:
- Entrega contÃ­nua e rÃ¡pida (DevOps)
- Deploys independentes por time
- Infraestrutura como cÃ³digo
- EficiÃªncia no uso de recursos

Resumo:
Container:	Empacota o microsserviÃ§o com tudo que ele precisa
Orquestrador:	Gerencia, escala e mantÃ©m o ambiente confiÃ¡vel e saudÃ¡vel

3.10. Cloud Computing

ğŸ“Œ O que Ã© Cloud Computing?
Ã‰ o fornecimento de recursos computacionais sob demanda (como servidores, banco de dados, armazenamento, rede, software) pela internet, com pagamento conforme o uso.

ğŸ’¡ Por que Cloud Ã© essencial para microsserviÃ§os?
MicrosserviÃ§os demandam:

- Escalabilidade
- Isolamento
- Alta disponibilidade
- Deploys frequentes
- Ambientes independentes

A nuvem oferece todos esses recursos com elasticidade e automaÃ§Ã£o, permitindo que as equipes se concentrem mais em entregar valor do que em gerenciar infraestrutura.


ğŸ§± Modelos de serviÃ§o na Cloud
Modelo	DescriÃ§Ã£o	Exemplo
IaaS (Infraestrutura como ServiÃ§o)	VocÃª gerencia tudo, exceto os servidores fÃ­sicos.	Amazon EC2, Azure VM
PaaS (Plataforma como ServiÃ§o)	VocÃª foca no cÃ³digo, a plataforma gerencia o ambiente.	Heroku, Google App Engine
SaaS (Software como ServiÃ§o)	VocÃª apenas usa o software via web.	Gmail, Salesforce

ğŸ—ï¸ Modelos de implantaÃ§Ã£o
Tipo	DescriÃ§Ã£o
Nuvem PÃºblica	Recursos compartilhados entre vÃ¡rias empresas (AWS, Azure, GCP).
Nuvem Privada	Infraestrutura dedicada para uma organizaÃ§Ã£o.
Nuvem HÃ­brida	CombinaÃ§Ã£o de pÃºblica + privada.
Multi-Cloud	Uso de mÃºltiplos provedores de nuvem.

ğŸ§  BenefÃ­cios da Cloud para microsserviÃ§os
Elasticidade: escale serviÃ§os conforme a demanda.
ResiliÃªncia: zonas de disponibilidade, failover automÃ¡tico.
Custo sob demanda: pague pelo que usa.
AutomaÃ§Ã£o: deploys, backups, observabilidade.
Agilidade: criaÃ§Ã£o rÃ¡pida de ambientes de teste e produÃ§Ã£o.

â˜ï¸ Principais provedores de Cloud
AWS (Amazon Web Services)
Microsoft Azure
Google Cloud Platform (GCP)
Oracle Cloud, IBM Cloud, etc.

âœ… ConclusÃ£o
Cloud computing Ã© a base moderna para rodar aplicaÃ§Ãµes em microsserviÃ§os, pois permite:
- Automatizar o ciclo de vida da aplicaÃ§Ã£o,
- Escalar rapidamente,
- Isolar serviÃ§os,
- E reduzir custos operacionais.

3.11. Microservices Patterns: nÃ£o reinvente a roda

Livros:
Microservices Patterns (Chris Richardson)
Microservices.io (Chris Richardson)
Enterprise Integration Patterns - EIP
Enterprise Integration Patterns - EIP (Gregor Hohpe e Bobby Woolf)
Patterns of Distributed Systems (Unmesh Joshi)
Catalog of Patterns of Distributed Systems (Unmesh Joshi)
Microsoft Azure Architecture Center - Cloud Design Patterns
AWS Prescriptive Guidance
The Ultimate Guide to Event-Driven Architecture Patterns (Solace)
Event Streaming Patterns (Confluent)

Ao projetar uma arquitetura baseada em microsserviÃ§os, nÃ£o Ã© necessÃ¡rio (nem recomendado) criar tudo do zero. 
Existem padrÃµes amplamente adotados que ajudam a resolver desafios comuns de forma segura, escalÃ¡vel e jÃ¡ testada na prÃ¡tica.

ğŸ§± O que sÃ£o Microservices Patterns?
SÃ£o soluÃ§Ãµes reutilizÃ¡veis para problemas recorrentes em arquiteturas de microsserviÃ§os, como:

ComunicaÃ§Ã£o entre serviÃ§os
ConsistÃªncia de dados
AutenticaÃ§Ã£o e autorizaÃ§Ã£o
Deploys independentes
TolerÃ¢ncia a falhas
Monitoramento e observabilidade

ğŸ§° Principais padrÃµes que vocÃª deve conhecer:

ğŸ”„ API Gateway
- Ponto Ãºnico de entrada para chamadas externas.
- Centraliza autenticaÃ§Ã£o, roteamento, throttling, etc.

ğŸ› Service Discovery
- Permite que microsserviÃ§os encontrem uns aos outros dinamicamente.
- Exemplos: Eureka, Consul, Kubernetes DNS.

ğŸ§© Database per Service
- Cada serviÃ§o tem seu prÃ³prio banco de dados.
- Evita acoplamento entre microsserviÃ§os.

ğŸ”€ CQRS (Command Query Responsibility Segregation)
- Separa operaÃ§Ãµes de leitura e escrita.
- Melhora performance e escalabilidade.

â›“ Choreography vs Orchestration
- Choreography: eventos e reaÃ§Ãµes descentralizadas (event-driven).
- Orchestration: um serviÃ§o central coordena os outros.

ğŸ§¾ Saga Pattern
- Gerencia transaÃ§Ãµes distribuÃ­das com rollback entre microsserviÃ§os.
- Usado quando nÃ£o Ã© possÃ­vel usar transaÃ§Ãµes ACID entre bancos diferentes.

ğŸ’¬ Event Sourcing
- Eventos representam mudanÃ§as de estado no sistema.
- Ãštil para auditoria e reconstruÃ§Ã£o de estado.

ğŸš¨ Circuit Breaker
- Impede que falhas em um serviÃ§o se propaguem para outros.
- Exemplo: Hystrix, Resilience4j.

â³ Retry e Timeout
- RepetiÃ§Ã£o automÃ¡tica de chamadas com falha.
- Define um limite de tempo para chamadas entre serviÃ§os.

ğŸ“¦ Bulkhead Pattern
- Isola falhas em uma parte do sistema para que nÃ£o afetem outras.

ğŸ” Centralized Authentication
- Uso de tokens JWT, OAuth2, Keycloak, etc.

Usar padrÃµes prontos Ã© uma decisÃ£o estratÃ©gica. Eles sÃ£o o atalho mais seguro para construir microsserviÃ§os que sejam resilientes, escalÃ¡veis, bem organizados e com baixo acoplamento.

3.13. Microservice Chassis com Spring Boot e Spring Cloud

ğŸ“Œ O que Ã© um Microservice Chassis?
Um microservice chassis Ã© uma base reutilizÃ¡vel que contÃ©m os componentes e configuraÃ§Ãµes comuns que cada microsserviÃ§o precisa, como:

- Logging
- SeguranÃ§a
- Tracing distribuÃ­do
- ConfiguraÃ§Ã£o externa
- Health checks
- ComunicaÃ§Ã£o entre serviÃ§os

ğŸ’¡ Objetivo: padronizar e acelerar a criaÃ§Ã£o de microsserviÃ§os, evitando duplicaÃ§Ã£o de cÃ³digo e garantindo boas prÃ¡ticas arquiteturais.

ğŸ› ï¸ Spring Boot + Spring Cloud: a combinaÃ§Ã£o ideal
âœ… Spring Boot
- Framework para criar aplicaÃ§Ãµes Java prontas para produÃ§Ã£o com o mÃ­nimo de configuraÃ§Ã£o.
- Ideal para construir microsserviÃ§os leves e independentes.

ğŸ”§ Spring Cloud
Conjunto de bibliotecas para resolver problemas comuns em arquiteturas distribuÃ­das, como:

- Descoberta de serviÃ§os (Eureka)
- Roteamento (Zuul/Gateway)
- ConfiguraÃ§Ã£o centralizada (Spring Cloud Config)
- Circuit breaker (Resilience4j)
- Mensageria (Stream, Kafka, RabbitMQ)
- Observabilidade (Sleuth, Zipkin, Micrometer)

ğŸ“¦ Exemplo de componentes em um Chassis com Spring Cloud
Componente	FunÃ§Ã£o
Spring Cloud Config	ConfiguraÃ§Ã£o externa e centralizada
Eureka (Service Discovery)	Registro e descoberta de serviÃ§os
Spring Cloud Gateway ou Zuul	API Gateway com roteamento inteligente
Resilience4j	Circuit breaker, retries e fallback
Spring Security + OAuth2	AutenticaÃ§Ã£o e autorizaÃ§Ã£o centralizadas
Sleuth + Zipkin	Tracing distribuÃ­do e anÃ¡lise de chamadas
Micrometer + Prometheus	MÃ©tricas e monitoramento
Spring Cloud Stream	IntegraÃ§Ã£o com Kafka/RabbitMQ

ğŸ“ OrganizaÃ§Ã£o do Chassis
O chassis pode ser um starter project ou um mÃ³dulo Maven compartilhado, contendo:

/chassis
  â”œâ”€â”€ logging-config/
  â”œâ”€â”€ exception-handling/
  â”œâ”€â”€ security-config/
  â”œâ”€â”€ tracing-config/
  â”œâ”€â”€ actuator-config/
  â””â”€â”€ starter-dependencies/

Cada microsserviÃ§o entÃ£o apenas importa esse chassis como uma dependÃªncia.

ğŸš€ Vantagens do Microservice Chassis
ReduÃ§Ã£o de boilerplate
PadronizaÃ§Ã£o entre times
Ganho de velocidade no onboarding
Melhoria de governanÃ§a e seguranÃ§a
Escalabilidade organizacional

3.14. Ecossistema de projetos da (CNCF)[https://landscape.cncf.io/]

A CNCF (Cloud Native Computing Foundation) Ã© uma fundaÃ§Ã£o que promove e sustenta tecnologias cloud-native modernas, abertas e escalÃ¡veis.

Ela mantÃ©m um ecossistema rico de projetos que ajudam empresas a construir, executar e gerenciar aplicaÃ§Ãµes distribuÃ­das em ambientes de nuvem.

SÃ£o soluÃ§Ãµes que seguem os princÃ­pios:

ContÃªineres
MicrosserviÃ§os
OrquestraÃ§Ã£o
Observabilidade
ResiliÃªncia
Escalabilidade automÃ¡tica

ğŸ§± Categorias do Ecossistema CNCF
A CNCF organiza seus projetos em vÃ¡rias categorias funcionais. Aqui estÃ£o as principais:

1. OrquestraÃ§Ã£o e Gerenciamento
Kubernetes (âœ… Graduado): orquestraÃ§Ã£o de contÃªineres.
K3s: Kubernetes leve para edge computing.
Helm: gerenciador de pacotes para Kubernetes.

2. Observabilidade e Monitoramento
Prometheus (âœ… Graduado): monitoramento e alertas.
Grafana (em colaboraÃ§Ã£o): visualizaÃ§Ã£o de mÃ©tricas.
OpenTelemetry: padronizaÃ§Ã£o de logs, mÃ©tricas e traces.

3. Networking e Service Mesh
Envoy: proxy de alto desempenho.
Istio: service mesh para controle de trÃ¡fego, seguranÃ§a e observabilidade.
Linkerd: service mesh leve e simples.

4. Runtime (ExecuÃ§Ã£o de AplicaÃ§Ãµes)
containerd / CRI-O: runtimes de contÃªiner.
runc: runtime em baixo nÃ­vel (OCI).

5. Armazenamento e Databases
Rook: orquestraÃ§Ã£o de storage distribuÃ­do.
Longhorn: storage nativo em Kubernetes.

6. SeguranÃ§a
SPIFFE/SPIRE: identidade segura para serviÃ§os.
Falco: detecÃ§Ã£o de ameaÃ§as em tempo real em containers.
OPA (Open Policy Agent): polÃ­tica como cÃ³digo.

7. Entrega ContÃ­nua e GitOps
ArgoCD: entrega contÃ­nua declarativa com GitOps.
Flux: outro projeto GitOps muito popular.
Tekton: pipelines de CI/CD nativas em Kubernetes.

ğŸ“ˆ Maturidade dos Projetos CNCF
Os projetos sÃ£o classificados em trÃªs nÃ­veis:

NÃ­vel	Significado
ğŸ¼ Sandbox	Projetos experimentais ou em estÃ¡gio inicial
ğŸš€ Incubating	Projetos com adoÃ§Ã£o em crescimento e comunidade ativa
ğŸ† Graduated	Projetos maduros, amplamente usados e bem suportados

A CNCF Ã© um pilar central da arquitetura moderna cloud-native, com dezenas de projetos que cobrem todo o ciclo de vida de aplicaÃ§Ãµes distribuÃ­das, desde build atÃ© monitoramento, seguranÃ§a e entrega contÃ­nua.


4.1. Conhecendo os principais desafios e desvantagens

Embora a arquitetura de microsserviÃ§os ofereÃ§a muitos benefÃ­cios, ela nÃ£o Ã© uma bala de prata. Migrar ou adotar esse modelo exige considerar complexidades tÃ©cnicas, organizacionais e operacionais.

âš ï¸ 1. Complexidade DistribuÃ­da
Cada serviÃ§o Ã© um sistema separado â€” isso aumenta a complexidade de deploy, testes e monitoramento.
Problemas de rede, latÃªncia, timeouts e perda de conexÃ£o tornam-se comuns.
Ã‰ necessÃ¡rio lidar com eventual consistency em vez de transaÃ§Ãµes ACID simples.

ğŸ” 2. AutenticaÃ§Ã£o e AutorizaÃ§Ã£o
SeguranÃ§a entre serviÃ§os (ex: JWT, mTLS).
VerificaÃ§Ã£o de escopo, acesso e expiraÃ§Ã£o de tokens.
PropagaÃ§Ã£o de identidade entre serviÃ§os Ã© desafiadora.

ğŸ§ª 3. Testes e QA mais difÃ­ceis
Testes end-to-end sÃ£o mais complexos e frÃ¡geis.
Testes de integraÃ§Ã£o exigem mÃºltiplos serviÃ§os em execuÃ§Ã£o.
Ambiente de testes completo pode ser caro e difÃ­cil de manter.

ğŸ§° 4. Observabilidade e DepuraÃ§Ã£o
Logs, mÃ©tricas e rastreamento distribuÃ­do (tracing) sÃ£o obrigatÃ³rios.
Depurar um bug pode exigir consultar vÃ¡rios serviÃ§os, bancos de dados e logs.
Ferramentas como Prometheus, Grafana, Jaeger e ELK sÃ£o necessÃ¡rias.

ğŸ“¦ 5. DevOps e Deploys
Cada microserviÃ§o pode ter sua prÃ³pria pipeline CI/CD.
Gerenciar deploys independentes exige automaÃ§Ã£o robusta.
Rollbacks podem ser difÃ­ceis se a base de dados foi alterada.

ğŸ§  6. Curva de Aprendizado e Cultura
Requer maturidade de equipe: DevOps, GitOps, cultura de ownership.
Equipes devem ser autÃ´nomas, multifuncionais e com forte colaboraÃ§Ã£o.

ğŸ” 7. ComunicaÃ§Ã£o entre serviÃ§os
RequisiÃ§Ãµes via HTTP/gRPC ou eventos assÃ­ncronos com filas (RabbitMQ, Kafka).
Lidar com fallbacks, retries, circuit breakers.
PropagaÃ§Ã£o de contexto entre chamadas distribuÃ­das.

ğŸ·ï¸ 8. Versionamento e Compatibilidade
DifÃ­cil manter compatibilidade entre versÃµes de APIs.
Requer estratÃ©gia clara de API versioning.
Deploys desacoplados precisam garantir retrocompatibilidade.

ğŸ’° 9. Custo Operacional
Mais serviÃ§os = mais containers, pipelines, monitoramento, storage.
Necessidade de orquestradores (como Kubernetes).
GestÃ£o de infraestrutura mais cara e complexa.

âš–ï¸ 10. Overhead de Gerenciamento
Descoberta de serviÃ§os, contratos de interface, e governanÃ§a.
Monitoramento de dependÃªncias e falhas em cascata.
Pode resultar em â€œmicrosserviÃ§os demaisâ€ (overengineering).

âœ… Quando NÃƒO usar microsserviÃ§os
Evite esse modelo quando:
O sistema ainda estÃ¡ em fase inicial ou pequena escala.
A equipe tem pouca experiÃªncia com DevOps e arquitetura distribuÃ­da.
A complexidade nÃ£o compensa os benefÃ­cios de independÃªncia e escala.


4.2. Complexidade na modelagem de serviÃ§os e o risco do monÃ³lito distribuÃ­do

ğŸ“Œ Modelar microsserviÃ§os nÃ£o Ã© sÃ³ dividir cÃ³digo, Ã© dividir responsabilidades de forma coesa, independente e orientada ao negÃ³cio.

âš ï¸ Riscos da mÃ¡ modelagem: o MonÃ³lito DistribuÃ­do
O que Ã© isso?
â¡ Ã‰ quando vocÃª â€œespalhaâ€ um monÃ³lito em vÃ¡rios serviÃ§os, mas eles continuam fortemente acoplados e dependentes uns dos outros.

ğŸ”¥ Sintomas:
Muitos serviÃ§os precisam ser atualizados juntos.
RequisiÃ§Ãµes em cascata entre serviÃ§os para processar uma Ãºnica aÃ§Ã£o.
Falha de um serviÃ§o derruba toda a aplicaÃ§Ã£o.
Deploys e testes se tornam lentos e complexos.
Excesso de chamadas REST/gRPC entre serviÃ§os.

ğŸ¯ Causas Comuns
Modelagem baseada em camadas tÃ©cnicas (ex: um serviÃ§o sÃ³ para "usuÃ¡rios", outro para "pedidos", sem pensar no domÃ­nio).
SeparaÃ§Ã£o prematura sem entender o domÃ­nio.
Equipes organizadas em silos tÃ©cnicos.
AusÃªncia de Bounded Contexts (conceito do DDD).
Falta de visÃ£o de produto e experiÃªncia do usuÃ¡rio.

ğŸ“Œ ATENÃ‡ÃƒO: DomÃ­nio antes da tecnologia: modele com base em domÃ­nios de negÃ³cio (Domain-Driven Design).

4.3. Dificuldade na refatoraÃ§Ã£o de fronteiras dos serviÃ§os

Quando comeÃ§amos a dividir um sistema em microsserviÃ§os, tentamos delimitar bem as "fronteiras" â€” ou seja, o que pertence a qual serviÃ§o.

PorÃ©m, com o tempo, percebemos que:

- Algumas regras de negÃ³cio estÃ£o no serviÃ§o errado;
- Determinadas decisÃµes foram precipitadas;
- Surgem dependÃªncias cruzadas que antes nÃ£o existiam.

ğŸ› ï¸ Como mitigar esse problema?
1. Comece monolÃ­tico, module bem
- Antes de quebrar, modularize. Evita criar microsserviÃ§os antes de entender os limites naturais do domÃ­nio.

2. Use o DDD (Domain-Driven Design)
- Ajuda a identificar os bounded contexts corretos.

3. Evite decisÃµes prematuras
- Espere o domÃ­nio amadurecer antes de separar em serviÃ§os.

4. Use eventos para transiÃ§Ã£o
Ao mover dados de um serviÃ§o para outro:
- Publique eventos que os dois serviÃ§os escutam;
- Migre gradualmente.

5. Tenha contratos bem definidos
- Refatorar com APIs versionadas e contratos de comunicaÃ§Ã£o desacoplados (como eventos) facilita mudanÃ§as.

ATENÃ‡ÃƒO: Antes de iniciar o desenvolvimento modele bem, pois o trablho de refatoraÃ§Ã£o Ã© tenso

4.4. Complexidade da computaÃ§Ã£o distribuÃ­da

A computaÃ§Ã£o distribuÃ­da, base dos microsserviÃ§os, traz muitas vantagens â€” como escalabilidade e autonomia â€” mas tambÃ©m muita complexidade.

Aqui estÃ£o os principais desafios da computaÃ§Ã£o distribuÃ­da:

ğŸ§© 1. Falhas sÃ£o inevitÃ¡veis
ServiÃ§os caem, a rede falha, pacotes se perdem.

VocÃª precisa lidar com:

- Timeouts
- Retentativas
- Circuit Breakers
- Mensagens duplicadas

ğŸ”§ Exemplo: Um ServiÃ§o de Pagamento chama o ServiÃ§o de Entrega. Se a chamada falhar, vocÃª precisa decidir: tentar de novo? Reverter o pagamento?

ğŸ”„ 2. ComunicaÃ§Ã£o entre serviÃ§os
Chamadas HTTP entre serviÃ§os sÃ£o lentas, falham ou travam.
APIs precisam ser versionadas, resilientes, seguras.
Pode-se usar filas (mensageria), mas isso complica ainda mais.
ğŸ” VocÃª tambÃ©m precisa lidar com autenticaÃ§Ã£o e autorizaÃ§Ã£o entre microsserviÃ§os (ex: JWT, mTLS).

ğŸ§  3. ConsistÃªncia eventual
Como cada serviÃ§o tem seu banco, nÃ£o existe transaÃ§Ã£o distribuÃ­da confiÃ¡vel.
VocÃª precisa usar estratÃ©gias como:
Sagas (coordenadas ou coreografadas)
Eventual consistency
Event sourcing (em casos mais extremos)
ğŸ§¨ DifÃ­cil garantir que "pagou â†’ entregou" sem uma transaÃ§Ã£o. Precisamos confiar em eventos e orquestraÃ§Ãµes.

ğŸ•µï¸ 4. Observabilidade
Como entender o que estÃ¡ acontecendo em dezenas de serviÃ§os?
Log centralizado (ex: ELK, Grafana Loki)
Tracing distribuÃ­do (ex: OpenTelemetry, Zipkin, Jaeger)
MÃ©tricas (ex: Prometheus, Grafana)
ğŸ“Š "O pedido travou" â€” onde? Sem observabilidade, Ã© impossÃ­vel saber.

ğŸ“‰ 5. Performance
MicrosserviÃ§os geralmente tÃªm mais latÃªncia que monÃ³litos.
Cada salto de rede consome tempo.
Excesso de comunicaÃ§Ã£o entre serviÃ§os (chamadas encadeadas) vira gargalo.

ğŸ§ª 6. Testes e ambientes
Testar um fluxo end-to-end requer vÃ¡rios serviÃ§os funcionando juntos.
Ambientes de homologaÃ§Ã£o devem simular o ambiente real distribuÃ­do.
Testes automatizados exigem mock, contrato, e cuidado com dependÃªncias.

Desafio	SoluÃ§Ãµes comuns
Falhas e latÃªncia:	Timeouts, retries, circuit breakers
ComunicaÃ§Ã£o entre serviÃ§os:	APIs resilientes, mensageria
ConsistÃªncia eventual:	Sagas, eventos, CQRS
Observabilidade:	Tracing, mÃ©tricas, logs
Performance:	OtimizaÃ§Ã£o de chamadas, cache, batch
Testabilidade:	Testes de contrato, mocks, ambientes integrados


4.5. Teorema CAP e consistÃªncia eventual

O Teorema CAP Ã© um conceito fundamental para entender os trade-offs em sistemas distribuÃ­dos, como microsserviÃ§os.
Ele nos diz que em qualquer sistema distribuÃ­do, sÃ³ Ã© possÃ­vel garantir no mÃ¡ximo dois dos trÃªs elementos a seguir ao mesmo tempo:

C	- ConsistÃªncia:	          Todos os nÃ³s veem os mesmos dados ao mesmo tempo.
A	- Disponibilidade:	      O sistema sempre responde (com sucesso ou erro).
P	- TolerÃ¢ncia Ã  PartiÃ§Ã£o:  O sistema continua funcionando mesmo que haja falhas de comunicaÃ§Ã£o entre nÃ³s.

âš–ï¸ Trade-offs (escolha dois):
Tipo de sistema	                                      Garante	                                        Sacrifica
CP (ConsistÃªncia + PartiÃ§Ã£o)            :	Dados sempre consistentes mesmo com falhas de rede  :	Pode ficar indisponÃ­vel
AP (Alta disponibilidade + PartiÃ§Ã£o)	  : Sempre responde	                                    : Pode haver dados desatualizados (inconsistÃªncia eventual)
CA (ConsistÃªncia + Disponibilidade)	    : CoerÃªncia e resposta	                              : âŒ NÃ£o tolera falhas de rede â€“ irreal em sistemas distribuÃ­dos

ConsistÃªncia Eventual
- Ã‰ o modelo adotado por muitos sistemas distribuÃ­dos (ex: bancos NoSQL, microsserviÃ§os).
- Os dados podem estar temporariamente inconsistentes, mas eventualmente convergem.

- Ã‰ comum quando usamos:
  - Mensageria (eventos assÃ­ncronos)
  - ReplicaÃ§Ã£o de dados entre serviÃ§os
  - Sagas coreografadas

ğŸ“˜ Exemplo: Um pedido Ã© feito e o serviÃ§o de pagamento recebe o evento depois de alguns segundos. Os dados â€œficam certosâ€ com o tempo.


4.7. Aumento de custos de infraestrutura e operaÃ§Ã£o

A adoÃ§Ã£o da arquitetura de microsserviÃ§os traz muitas vantagens â€” como escalabilidade, resiliÃªncia e autonomia dos times â€” mas tambÃ©m aumenta significativamente os custos, especialmente em comparaÃ§Ã£o com um monÃ³lito simples.

1. Mais instÃ¢ncias e serviÃ§os
Em vez de um Ãºnico deploy, vocÃª passa a ter dezenas (ou centenas) de serviÃ§os rodando individualmente.
Cada serviÃ§o requer recursos de CPU, memÃ³ria, armazenamento, rede etc.

2. Ambiente de execuÃ§Ã£o mais complexo
Precisa de containers (Docker), orquestraÃ§Ã£o (Kubernetes), service mesh (Istio, Linkerd), gateways, proxies, etc.
Toda essa infraestrutura consome recursos mesmo quando o trÃ¡fego Ã© baixo.

3. Observabilidade
Ã‰ necessÃ¡rio investir em ferramentas como:
Log centralizado (ELK, Loki, Datadog)
Tracing distribuÃ­do (Jaeger, Zipkin)
Monitoramento (Prometheus, Grafana)
Essas ferramentas tambÃ©m rodam em containers e geram custo computacional.

4. ComunicaÃ§Ã£o em rede
MicrosserviÃ§os se comunicam via rede, o que pode gerar:
LatÃªncia
Erros de rede
TrÃ¡fego elevado, impactando a conta da nuvem

5. MÃºltiplos pipelines e deploys
Cada serviÃ§o precisa de um pipeline de CI/CD separado.
A automaÃ§Ã£o se torna essencial, o que exige engenharia de plataforma e ferramentas especÃ­ficas.

6. Time de plataforma/SRE/DevOps
Para operar uma arquitetura distribuÃ­da, muitas empresas precisam de um time dedicado para manter a infraestrutura (monitoramento, deploys, scripts de recuperaÃ§Ã£o, seguranÃ§a etc.).

â˜ï¸ Na nuvem, paga-se por:
Quantidade de instÃ¢ncias ou pods em execuÃ§Ã£o
Uso de CPU e memÃ³ria
Volume de trÃ¡fego entre zonas/serviÃ§os
Armazenamento e logs
ServiÃ§os gerenciados (ex: Kafka, bancos, tracing)

4.8. Riscos de seguranÃ§a

SuperfÃ­cie de ataque ampliada
VÃ¡rios serviÃ§os = mais pontos de entrada = mais vulnerabilidades potenciais.

ComunicaÃ§Ã£o entre serviÃ§os exposta
Dados trafegam via rede (HTTP/gRPC), podendo ser interceptados sem criptografia (use HTTPS/TLS).

AutenticaÃ§Ã£o e autorizaÃ§Ã£o distribuÃ­das
Cada serviÃ§o precisa validar tokens e permissÃµes corretamente. Se mal implementado, vira brecha.

GestÃ£o de segredos
Tokens, chaves de API, credenciaisâ€¦ precisam ser bem protegidos e rotacionados (ex: usar Vault).

DependÃªncias externas vulnerÃ¡veis
Muitos serviÃ§os = mais bibliotecas = maior chance de vulnerabilidades conhecidas.

ConfiguraÃ§Ã£o incorreta
Erros de CORS, permissÃµes excessivas, portas abertas, etc., sÃ£o comuns em ambientes mal gerenciados.

Falhas no isolamento
Falta de sandboxing ou containers mal configurados podem permitir acesso indevido entre serviÃ§os.

4.9. Conformidade com regulamentaÃ§Ãµes de privacidade (LGPD/GDPR)

MicrosserviÃ§os devem seguir regras de proteÃ§Ã£o de dados como LGPD (Brasil) e GDPR (Europa), o que traz desafios especÃ­ficos:

ğŸ” Principais exigÃªncias:

Consentimento do usuÃ¡rio
Os serviÃ§os que coletam dados devem registrar e respeitar o consentimento.

Finalidade e minimizaÃ§Ã£o de dados
Cada serviÃ§o deve tratar apenas os dados estritamente necessÃ¡rios.

Direito de acesso, correÃ§Ã£o e exclusÃ£o
O sistema deve permitir que usuÃ¡rios consultem e solicitem remoÃ§Ã£o/alteraÃ§Ã£o de seus dados (ex: â€œDireito ao esquecimentoâ€).

SeguranÃ§a no tratamento
Dados pessoais devem ser armazenados e transmitidos com seguranÃ§a (criptografia, mascaramento, etc).

Auditoria e rastreabilidade
MicrosserviÃ§os devem registrar logs e ter trilhas auditÃ¡veis sobre como os dados foram manipulados.

Compartilhamento com terceiros
Deve haver controle e transparÃªncia sobre para quem os dados sÃ£o enviados (outros serviÃ§os, parceiros etc.).

SoluÃ§Ã£o: 
- Centralizar polÃ­ticas de privacidade
- Ter um serviÃ§o de conformidade (ex: Privacy Service)
- Automatizar anonimizaÃ§Ã£o, deleÃ§Ã£o e exportaÃ§Ã£o de dados
- Documentar e revisar rotas sensÃ­veis

4.10. Hype Driven Development e Technology Sprawl

ğŸš€ Hype Driven Development (Desenvolvimento guiado por modinha)
Escolher tecnologias porque estÃ£o na moda, sem avaliar se resolvem o problema real.
Exemplo: usar Kubernetes, Kafka, GraphQL ou microsserviÃ§os sem necessidade.

âš ï¸ ConsequÃªncia: Complexidade desnecessÃ¡ria, curva de aprendizado alta e desperdÃ­cio de tempo e dinheiro.

ğŸŒªï¸ Technology Sprawl (DispersÃ£o tecnolÃ³gica)
Cada time escolhe stacks, libs e ferramentas diferentes, gerando um ecossistema caÃ³tico.
Exemplo: 10 microsserviÃ§os com 5 linguagens, 4 bancos de dados e 3 frameworks web diferentes.

âš ï¸ ConsequÃªncia: DifÃ­cil manter, testar, contratar, versionar, monitorar e integrar.

5.1. Fuja de microsserviÃ§os: quando nÃ£o vale a pena a adoÃ§Ã£o

A adoÃ§Ã£o de microsserviÃ§os tem se tornado uma tendÃªncia em arquiteturas modernas, mas nem sempre Ã© a melhor escolha. Abaixo estÃ£o alguns cenÃ¡rios onde "fugir" de microsserviÃ§os Ã© a decisÃ£o mais inteligente:

ğŸš« 1. Projetos pequenos ou com escopo bem definido
MicrosserviÃ§os introduzem uma complexidade significativa em termos de:

Deploys independentes
ComunicaÃ§Ã£o entre serviÃ§os (REST, mensageria, etc.)
Monitoramento, logging e rastreamento distribuÃ­do
TolerÃ¢ncia a falhas e consistÃªncia de dados
Quando nÃ£o hÃ¡ demanda real por essa complexidade, um monÃ³lito bem estruturado Ã© mais eficiente.

ğŸ“Œ Exemplo: Um sistema de controle de tarefas para uma equipe pequena.

âš ï¸ 2. Falta de maturidade da equipe
MicrosserviÃ§os exigem uma sÃ©rie de prÃ¡ticas avanÃ§adas:

DevOps maduro
Observabilidade (logs, mÃ©tricas, tracing)
CI/CD automatizado
Design orientado a domÃ­nios (DDD)
Equipes inexperientes podem transformar a arquitetura distribuÃ­da em um caos tÃ©cnico difÃ­cil de manter.

ğŸ”„ 3. Necessidade de consistÃªncia forte entre dados
Quando as transaÃ§Ãµes exigem consistÃªncia estrita entre mÃºltiplas operaÃ§Ãµes, microsserviÃ§os sÃ£o desafiadores:
TransaÃ§Ãµes distribuÃ­das sÃ£o difÃ­ceis de manter e escalar
VocÃª terÃ¡ que lidar com Sagas, eventuais inconsistÃªncias, compensaÃ§Ãµes, etc.
ğŸ“Œ Exemplo: Sistemas bancÃ¡rios de movimentaÃ§Ã£o financeira com mÃºltiplas validaÃ§Ãµes simultÃ¢neas.

ğŸ’¸ 4. Infraestrutura limitada
Rodar microsserviÃ§os requer:

Orquestradores (como Kubernetes)
Balanceadores de carga
Gateways de API
Alta disponibilidade dos serviÃ§os
Se vocÃª nÃ£o tem recursos para investir nisso, o custo de manutenÃ§Ã£o pode ser proibitivo.

ğŸ›‘ 5. Prematura separaÃ§Ã£o de serviÃ§os
Evite cair no erro do "prÃ©-otimizar":
Muitos sistemas podem comeÃ§ar como monÃ³litos modulares e sÃ³ depois se dividirem em microsserviÃ§os.
Separar cedo demais pode levar a dependÃªncias cruzadas mal definidas, serviÃ§os anÃªmicos ou altamente acoplados.

ğŸ§  MonÃ³lito modular > MicrosserviÃ§o mal projetado

âœ… Quando um monÃ³lito Ã© melhor:
Projeto novo sem necessidade clara de escalabilidade independente
Sistema com equipe reduzida
Time sem experiÃªncia em microsserviÃ§os
Requisitos tÃ©cnicos simples ou de mÃ©dio porte
Foco em entrega rÃ¡pida e validaÃ§Ã£o de produto (MVP)

5.2 Abrace os microsserviÃ§os quando realmente faz sentido 

Embora os microsserviÃ§os adicionem complexidade, em determinados contextos, eles sÃ£o altamente vantajosos. O segredo estÃ¡ em reconhecer quando o custo da complexidade compensa os ganhos de autonomia, escalabilidade e resiliÃªncia.

âœ”ï¸ Recapitulando: Quando vale a pena adotar microsserviÃ§os?
CritÃ©rio	IndÃ­cio que justifica
DomÃ­nio	: VÃ¡rios contextos bem definidos
Escalabilidade:	Carga desigual entre componentes
Equipes	MÃºltiplos: times com foco em partes distintas
ResiliÃªncia:	Precisa isolar falhas e manter o sistema funcional
FrequÃªncia de deploy:	MudanÃ§as constantes em partes isoladas do sistema

5.3 MonÃ³lito Modular: Alternativa aos microsserviÃ§os 

Quando microsserviÃ§os nÃ£o sÃ£o a melhor escolha, mas o sistema ainda precisa de organizaÃ§Ã£o, escalabilidade interna e separaÃ§Ã£o de responsabilidades, o monÃ³lito modular surge como uma soluÃ§Ã£o estratÃ©gica.

ğŸ§  O que Ã© um monÃ³lito modular?
Ã‰ uma aplicaÃ§Ã£o Ãºnica (um deploy, um processo), mas com sua estrutura interna dividida por mÃ³dulos independentes e coesos, que:

Encapsulam suas regras de negÃ³cio
NÃ£o se acoplam diretamente entre si (ou fazem isso por contratos bem definidos)
MantÃªm separaÃ§Ã£o lÃ³gica clara, mesmo estando no mesmo binÃ¡rio

ğŸ” Ã‰ pensar como microsserviÃ§os, mas sem distribuir.

âœ… Quando optar por monÃ³lito modular?
Projeto estÃ¡ comeÃ§ando e pode crescer
Equipe ainda pequena ou em fase de aprendizado
HÃ¡ clareza de domÃ­nios e responsabilidade, mas sem necessidade de deploys independentes
Requisitos de escalabilidade sÃ£o limitados ou futuros

ğŸ”§ BenefÃ­cios do monÃ³lito modular
Vantagem	DescriÃ§Ã£o
ğŸ§© OrganizaÃ§Ã£o	Cada mÃ³dulo representa um bounded context da aplicaÃ§Ã£o
ğŸ§ª Testabilidade	Fica mais fÃ¡cil testar partes isoladas do sistema
ğŸš€ EvoluÃ§Ã£o	Facilita uma futura extraÃ§Ã£o para microsserviÃ§os
ğŸ§± Simplicidade operacional	Apenas um deploy, uma infraestrutura, menos sobrecarga
ğŸ‘¥ Autonomia parcial	Equipes podem cuidar de mÃ³dulos diferentes, mesmo num repositÃ³rio Ãºnico


5.4 EstratÃ©gias Greenfield: Microservices First e Monolith First

Projetos greenfield (iniciados do zero) oferecem a rara oportunidade de escolher uma arquitetura sem amarras do legado. Mas com essa liberdade vem a responsabilidade:
adotar a abordagem certa desde o inÃ­cio pode acelerar â€” ou comprometer â€” o sucesso do projeto.

Duas abordagens comuns se destacam:

âš™ï¸ Microservices First
ComeÃ§ar diretamente com microsserviÃ§os, projetando o sistema como um conjunto de serviÃ§os distribuÃ­dos desde o inÃ­cio.

âœ… Quando usar:
A empresa jÃ¡ tem experiÃªncia sÃ³lida com microsserviÃ§os
DomÃ­nios bem definidos desde o inÃ­cio
Equipe multidisciplinar e infraestrutura madura (DevOps, CI/CD, observabilidade, mensageria)
Escalabilidade e resiliÃªncia sÃ£o requisitos crÃ­ticos desde o MVP

ğŸ” Exemplo prÃ¡tico:
Uma fintech com squads separados para onboarding, transaÃ§Ãµes e antifraude decide comeÃ§ar com trÃªs serviÃ§os distintos e independentes, pois o volume e a criticidade sÃ£o altos desde o primeiro dia.

âš ï¸ Riscos:
Superengenharia desnecessÃ¡ria
Complexidade tÃ©cnica precoce
Dificuldade de mudar o design se os domÃ­nios forem mal compreendidos

ğŸ§± Monolith First
ComeÃ§ar com um monÃ³lito bem estruturado e modular, com o objetivo de extrair microsserviÃ§os quando (e se) for necessÃ¡rio.

âœ… Quando usar:
Equipe reduzida ou com pouca experiÃªncia em arquiteturas distribuÃ­das
DomÃ­nios ainda estÃ£o sendo descobertos (fase de exploraÃ§Ã£o e validaÃ§Ã£o)
MVP rÃ¡pido Ã© uma prioridade
A complexidade da infraestrutura deve ser mantida ao mÃ­nimo no inÃ­cio

ğŸ” Exemplo prÃ¡tico:
Uma startup quer validar rapidamente uma plataforma de educaÃ§Ã£o online. Escolhe construir um monÃ³lito modular com contextos bem separados (usuÃ¡rio, curso, pagamento), com possibilidade futura de extraÃ§Ã£o de microsserviÃ§os.

ğŸ¯ Vantagens:
Menor custo de operaÃ§Ã£o e deploy
Simplicidade no inÃ­cio
Base sÃ³lida para modularizaÃ§Ã£o e futura transiÃ§Ã£o

5.5 Anti-patterns organizacionais: Big Bang, ModularizaÃ§Ã£o incremental e Strangler Fig Pattern

Migrar um sistema legado para microsserviÃ§os ou modularizar um monÃ³lito exige mais que decisÃµes tÃ©cnicas: Ã© tambÃ©m um desafio organizacional. E nesse processo, algumas armadilhas sÃ£o recorrentes.

âŒ Big Bang Rewrite
â€œVamos reescrever tudo do zero, agora do jeito certo.â€

ğŸ§± O que Ã©?
Ã‰ a tentativa de substituir o sistema legado inteiro por uma nova arquitetura â€” geralmente microsserviÃ§os â€” em um Ãºnico grande movimento.

âš ï¸ Problemas:
AltÃ­ssimo custo, risco e tempo de execuÃ§Ã£o
Pouco feedback real durante o processo
Dificuldade de reproduzir todos os comportamentos e integraÃ§Ãµes legadas
Produto pode nunca ser entregue antes de se tornar obsoleto

ğŸ’¡ Alternativa:
Evite! Prefira abordagens incrementais, como o Strangler Fig Pattern, que veremos a seguir.

âŒ ModularizaÃ§Ã£o incremental mal orientada
â€œVamos modularizando aos poucos, conforme der...â€

ğŸ§± O que Ã©?
A ideia de migrar ou modularizar sem uma visÃ£o clara de domÃ­nios, fronteiras ou objetivos tÃ©cnicos, apenas reorganizando classes ou pacotes superficialmente.

âš ï¸ Problemas:
Falsa sensaÃ§Ã£o de modularidade
MÃ³dulos altamente acoplados
Dificuldade de extraÃ§Ã£o futura para microsserviÃ§os
Falta de alinhamento entre times

ğŸ’¡ Alternativa:
Use DDD (Domain-Driven Design) para guiar a separaÃ§Ã£o de mÃ³dulos.
EstabeleÃ§a contratos claros e independÃªncia entre os mÃ³dulos desde o inÃ­cio.
Acompanhe com mÃ©tricas tÃ©cnicas (acoplamento, coesÃ£o, cobertura de testes, etc).

ğŸŒ± Strangler Fig Pattern (padrÃ£o da figueira estranguladora)
â€œVamos substituir o sistema aos poucos, mantendo o legado vivo atÃ© que tudo tenha migrado.â€

ğŸ§± O que Ã©?
Inspirado numa planta que cresce ao redor de outra atÃ© substituÃ­-la, este padrÃ£o consiste em envolver o sistema legado com uma nova arquitetura, redirecionando funcionalidades para novos serviÃ§os Ã  medida que forem reconstruÃ­das.

âœ… Vantagens:
Permite feedback rÃ¡pido
Reduz risco ao manter funcionalidades legadas ativas
Favorece evoluÃ§Ã£o por prioridades reais (uso, valor de negÃ³cio, urgÃªncia)

ğŸ” Exemplo:
Um endpoint /api/clientes continua atendido pelo legado.
O endpoint /api/pedidos Ã© redirecionado para um novo microsserviÃ§o.
Gradualmente, mais endpoints migram atÃ© que o sistema legado seja aposentado.

6.1 PadrÃµes de comunicaÃ§Ãµes entre microsserviÃ§os

  1. ComunicaÃ§Ã£o SÃ­ncrona (Request/Response)
  Protocolo comum: HTTP/HTTPS (REST, gRPC).

  CaracterÃ­sticas:
  O serviÃ§o que chama espera a resposta.
  Mais simples de implementar.
  Pode causar acoplamento e problemas de escalabilidade se muitos serviÃ§os dependerem uns dos outros diretamente.
  Exemplo: Um serviÃ§o de pedido chama o serviÃ§o de pagamento via REST para processar o pagamento.

  2. ComunicaÃ§Ã£o AssÃ­ncrona (Mensageria)
  Tecnologias comuns: RabbitMQ, Apache Kafka, Amazon SQS.

  CaracterÃ­sticas:
  ComunicaÃ§Ã£o baseada em eventos ou mensagens.
  O emissor envia a mensagem e nÃ£o espera resposta.
  Permite baixo acoplamento e alta escalabilidade.
  Exemplo: O serviÃ§o de pedido envia um evento â€œpedido criadoâ€ e o serviÃ§o de estoque consome esse evento para reservar os produtos.

  3. Event-Driven Architecture (Arquitetura Orientada a Eventos)
  Eventos sÃ£o disparados por serviÃ§os e outros serviÃ§os reagem a eles.

  PadrÃµes comuns:
  Event Notification: Apenas sinaliza que algo ocorreu.
  Event-Carried State Transfer: O evento jÃ¡ carrega todos os dados necessÃ¡rios.
  Event Sourcing: O estado do sistema Ã© reconstruÃ­do com base em eventos.
  Vantagem: Escalabilidade, auditabilidade, e histÃ³rico claro de mudanÃ§as.

  4. API Gateway
  Um ponto de entrada para o sistema.
  Pode rotear requisiÃ§Ãµes, aplicar autenticaÃ§Ã£o, balanceamento de carga e transformaÃ§Ã£o de protocolos.
  Exemplo de ferramenta: Kong, Zuul, Spring Cloud Gateway.
  BenefÃ­cio: Centraliza e padroniza a comunicaÃ§Ã£o com os microsserviÃ§os.

  6. ComunicaÃ§Ã£o por Chaveamento (Choreography x Orchestration)
  Choreography: Cada serviÃ§o sabe o que fazer e reage a eventos (mais desacoplado).
  Orchestration: Um serviÃ§o central coordena o fluxo (mais controle, porÃ©m mais acoplamento).

6.2 IntroduÃ§Ã£o ao Request-response Pattern (Request-reply)
O padrÃ£o Request-Response, tambÃ©m conhecido como Request-Reply, Ã© um dos padrÃµes de comunicaÃ§Ã£o mais comuns em sistemas distribuÃ­dos.
Ele consiste em uma interaÃ§Ã£o onde um cliente envia uma requisiÃ§Ã£o (request) para um servidor, e espera receber uma resposta (response).
Esse padrÃ£o pode ser implementado de duas formas principais: sÃ­ncrona e assÃ­ncrona.

# Na comunicaÃ§Ã£o sÃ­ncrona, o cliente aguarda a resposta do servidor antes de continuar sua execuÃ§Ã£o.

Exemplo:
Um cliente HTTP envia uma requisiÃ§Ã£o GET para uma API REST e espera a resposta antes de continuar.

CaracterÃ­sticas:
Bloqueante: o cliente fica inativo atÃ© receber a resposta.
Baixa latÃªncia esperada: usado quando a resposta Ã© rÃ¡pida.
Exemplo de tecnologia: HTTP/REST, gRPC sÃ­ncrono, chamadas diretas via mÃ©todos.

# Na comunicaÃ§Ã£o assÃ­ncrona, o cliente nÃ£o espera pela resposta imediatamente. Em vez disso, a resposta pode chegar depois, via outro canal, ou ser tratada por meio de callbacks, futuros/promessas ou mensageria.

Exemplo:
Um serviÃ§o envia uma mensagem para uma fila (como RabbitMQ ou Kafka) e continua seu processamento. O consumidor processa a mensagem e envia a resposta posteriormente, talvez por outra fila ou endpoint.

CaracterÃ­sticas:
NÃ£o bloqueante: permite maior escalabilidade.
ResiliÃªncia: desacopla produtor e consumidor.
Exemplo de tecnologia: JMS, RabbitMQ, Apache Kafka, gRPC assÃ­ncrono, WebSockets, Promises (JavaScript), CompletableFuture (Java).

Use SÃ­ncrono quando:

- Precisa da resposta imediata.
- As operaÃ§Ãµes sÃ£o rÃ¡pidas e confiÃ¡veis.
- HÃ¡ menor volume de requisiÃ§Ãµes simultÃ¢neas.

Use AssÃ­ncrono quando:

- Deseja escalar melhor.
- Lida com operaÃ§Ãµes demoradas ou interdependentes.
- Precisa de resiliÃªncia contra falhas temporÃ¡rias.

6.3 ComunicaÃ§Ã£o bloqueante e nÃ£o bloqueante 

ğŸ”’ Bloqueante (Blocking) SÃ­ncrono
- O processo espera a resposta antes de continuar.
- Fica parado atÃ© terminar.
âœ… Simples, mas menos eficiente em grande escala.
ğŸ§± Exemplo: REST com Spring MVC.

ğŸ”“ NÃ£o Bloqueante (Non-blocking) AssÃ­ncrono
- O processo nÃ£o espera; continua executando.
- A resposta Ã© tratada depois (callback, evento, future).
ğŸš€ Melhor para alta escalabilidade.
âš™ï¸ Exemplo: Spring WebFlux, Node.js, CompletableFuture.

6.4 O que sÃ£o contratos

Um contrato Ã© um acordo formal que define como os microsserviÃ§os devem se comunicar entre si. Ele especifica o formato das mensagens, os dados esperados, os tipos de requisiÃ§Ã£o, as respostas e possÃ­veis erros.

Por que Ã© importante?
- Garante que serviÃ§os diferentes entendam corretamente as mensagens trocadas.
- Permite que equipes trabalhem de forma independente, sem quebrar a comunicaÃ§Ã£o.
- Facilita a manutenÃ§Ã£o, evoluÃ§Ã£o e testes dos serviÃ§os.

Exemplos de contratos
- APIs REST com definiÃ§Ã£o via OpenAPI/Swagger.
- Eventos com schemas (ex: Avro, JSON Schema).
- Mensagens em filas com formatos padronizados.

Caracteristicas:
- schema
- protocolo de comunicaÃ§Ã£o
- formatos de dados suportados (serializaÃ§Ã£o)
- pontos de interface
- versÃ£o do contrato 
- regras de evoluÃ§Ã£o

Documentar Contratos:
- OpenAPI: RestAPI
- AsyncAPI: Definir Contratos de comunicaÃ§Ã£o assincrona

6.5 SerializaÃ§Ã£o 

SerializaÃ§Ã£o Ã© o processo de converter uma estrutura de dados ou objeto em uma sequÃªncia de bytes, para que possa ser transmitida, armazenada ou reconstruÃ­da depois.

Componentes principais
Formato: Como os dados sÃ£o organizados no arquivo ou mensagem (ex: JSON, XML, Protobuf).
Schema / IDL (Interface Definition Language): Descreve a estrutura dos dados (ex: Avro, Protobuf .proto files). Garante que remetente e receptor entendam os dados da mesma forma.
CodificaÃ§Ã£o: A maneira de converter os dados em bytes (ex: binÃ¡rio compacto, texto legÃ­vel).

Exemplo rÃ¡pido:
JSON Ã© um formato de serializaÃ§Ã£o texto, sem schema fixo.
Protobuf usa schema definido e codificaÃ§Ã£o binÃ¡ria, mais eficiente.

6.6 Acoplamento e microsserviÃ§os

ğŸ”— O que Ã© acoplamento?
Acoplamento Ã© o nÃ­vel de dependÃªncia entre dois mÃ³dulos ou serviÃ§os.
- Alto acoplamento: serviÃ§os muito dependentes entre si â†’ difÃ­ceis de mudar, testar e escalar.
- Baixo acoplamento: serviÃ§os independentes â†’ mais flexÃ­veis, fÃ¡ceis de evoluir.

ğŸ¤ MicrosserviÃ§os e o baixo acoplamento
MicrosserviÃ§os devem ser:
- Independentes para evoluir e implantar separadamente.
- Bem definidos por contratos (APIs, mensagens).
- Fracos acoplamentos, mas fortes coesÃµes (fazem bem uma tarefa especÃ­fica).

6.7 Messaging Patterns e mensageria 

ğŸ“¦ O que Ã© mensageria?
Mensageria Ã© um modelo de comunicaÃ§Ã£o entre sistemas usando mensagens trocadas por meio de filas ou brokers (ex: RabbitMQ, Kafka).
Em vez de chamadas diretas, um serviÃ§o envia uma mensagem e o outro a processa de forma assÃ­ncrona.

ğŸ” Principais Messaging Patterns

Point-to-Point (Ponto a Ponto)
- Um remetente envia para uma fila.
- Um Ãºnico consumidor processa a mensagem.
ğŸ§¾ Ex: Fila de pedidos.

Publish/Subscribe (Pub/Sub)
- Um remetente publica uma mensagem.
- VÃ¡rios consumidores inscritos recebem cÃ³pias.
ğŸ§¾ Ex: NotificaÃ§Ãµes para mÃºltiplos serviÃ§os.

Request/Reply (RequisiÃ§Ã£o/Resposta)
- Um serviÃ§o envia uma mensagem e espera uma resposta.
- Pode ser sÃ­ncrono ou assÃ­ncrono.

Fan-out
- Parecido com Pub/Sub, mas todas as mensagens sÃ£o replicadas para vÃ¡rias filas.
- Ãštil para replicar eventos para mÃºltiplos destinos.

Competing Consumers
- VÃ¡rios consumidores escutam a mesma fila e competem para processar mensagens.
- Ajuda na escalabilidade.

ğŸ“¬ Exemplo de ferramentas de mensageria
- RabbitMQ: baseado em filas, fÃ¡cil de usar.
- Apache Kafka: ideal para eventos em larga escala e persistÃªncia.
- ActiveMQ, Amazon SQS, Azure Service Bus, etc.

Messaging patterns definem como os serviÃ§os trocam mensagens em sistemas distribuÃ­dos.
Eles aumentam a desacoplagem, a resiliÃªncia e a escalabilidade dos microsserviÃ§os.

6.8 Producer-consumer Pattern

Ã‰ um padrÃ£o de design usado quando um ou mais produtores geram dados (ou tarefas) e colocam em uma fila, e um ou mais consumidores retiram esses dados para processar.

ğŸ‘¥ Quem sÃ£o:
Producer (Produtor):
Cria e envia mensagens/tarefas para uma fila (ex: novo pedido, evento, log).

Consumer (Consumidor):
LÃª da fila e processa a mensagem (ex: salva no banco, envia e-mail, gera relatÃ³rio).

ğŸ“¦ Onde Ã© usado?
Em mensageria assÃ­ncrona
Para desacoplar serviÃ§os e melhorar a escalabilidade.
Quando o processamento pode ser feito de forma independente e paralela.

âœ… BenefÃ­cios
Evita sobrecarga no consumidor.
Permite escalabilidade (vÃ¡rios consumidores).
Torna o sistema mais resiliente (mensagens nÃ£o se perdem).

ğŸ§¾ Exemplo simples
ServiÃ§o A (produtor) envia pedidos para uma fila.
ServiÃ§o B (consumidor) retira da fila e processa os pedidos.

ğŸ¯ Resumo
O Producer-Consumer Pattern Ã© ideal para comunicaÃ§Ã£o assÃ­ncrona entre microsserviÃ§os, promovendo desacoplamento, performance e escalabilidade.

6.9 Publisher-subscriber Pattern

Ã‰ um padrÃ£o de comunicaÃ§Ã£o onde um publicador (publisher) envia mensagens sem saber quem vai receber, e um ou mais assinantes (subscribers) recebem essas mensagens se estiverem inscritos.

ğŸ‘¥ Quem sÃ£o:
Publisher (Publicador):
Envia eventos ou mensagens para um canal ou tÃ³pico.

Subscriber (Assinante):
Escuta o canal/tÃ³pico e recebe mensagens que forem publicadas ali.

ğŸ“¦ Como funciona?
O publicador envia uma mensagem para um tÃ³pico.
Todos os assinantes daquele tÃ³pico recebem uma cÃ³pia da mensagem.
NÃ£o hÃ¡ ligaÃ§Ã£o direta entre publicador e assinantes â†’ desacoplamento total.

ğŸ§¾ Exemplo real:
- Um serviÃ§o publica o evento "UsuÃ¡rio criado".
- VÃ¡rios serviÃ§os ouvem esse evento:
  - ServiÃ§o de e-mail envia mensagem de boas-vindas.
  - ServiÃ§o de analytics registra novo usuÃ¡rio.
  - ServiÃ§o de auditoria grava o evento.

âœ… BenefÃ­cios
Desacoplamento entre remetente e receptores.
FÃ¡cil adicionar/remover assinantes.
Ideal para event-driven architecture.

ğŸ¯ Resumo
Pub/Sub permite que mÃºltiplos serviÃ§os escutem eventos de forma desacoplada, ajudando na escalabilidade e evoluÃ§Ã£o independente dos microsserviÃ§os.


7.1. IntroduÃ§Ã£o Ã  modelagem de microsserviÃ§os

A modelagem de microsserviÃ§os trata da forma como dividimos um sistema grande em pequenos serviÃ§os independentes, cada um responsÃ¡vel por uma funÃ§Ã£o especÃ­fica do negÃ³cio.

âœ… Principais conceitos:
MicrosserviÃ§o: Ã© um mÃ³dulo pequeno, autÃ´nomo, que executa uma funÃ§Ã£o especÃ­fica.

Desacoplamento: cada microsserviÃ§o funciona de forma independente dos outros.

Foco no domÃ­nio: os microsserviÃ§os sÃ£o modelados com base em Ã¡reas do negÃ³cio (ex: faturamento, cadastro de clientes).

ComunicaÃ§Ã£o via API: microsserviÃ§os se comunicam entre si por meio de interfaces bem definidas, geralmente com HTTP/REST ou mensageria.

IndependÃªncia de deploy: cada serviÃ§o pode ser atualizado ou implantado sem afetar os demais.

ğŸ¯ Objetivo:
Tornar o sistema mais flexÃ­vel, escalÃ¡vel e fÃ¡cil de manter, permitindo que equipes diferentes trabalhem em serviÃ§os diferentes ao mesmo tempo.


7.2 Baixo Acomplamento: Reduza as dependencias entre serviÃ§os

Baixo acoplamento significa que os microsserviÃ§os devem ser o mais independentes possÃ­vel uns dos outros.

âœ… Por que isso Ã© importante?
Facilita a manutenÃ§Ã£o e evoluÃ§Ã£o do sistema.
Permite que serviÃ§os sejam implantados separadamente.
Reduz o risco de erros se propagarem entre serviÃ§os.
Melhora a escalabilidade e a resiliÃªncia do sistema.

ğŸ§© Como alcanÃ§ar baixo acoplamento?
Use APIs bem definidas para comunicaÃ§Ã£o.
Evite acesso direto ao banco de dados de outro serviÃ§o.
Troque dados essenciais, nÃ£o objetos complexos.
Utilize mensageria (eventos) quando possÃ­vel, em vez de chamadas diretas.

ğŸ‘‰ Em resumo: cada serviÃ§o deve saber o mÃ­nimo necessÃ¡rio sobre os outros para funcionar corretamente.

âš ï¸ Sintomas de serviÃ§os muito acoplados

ğŸ”— 1. MudanÃ§a em um serviÃ§o quebra outros: Se vocÃª altera um serviÃ§o e precisa mudar vÃ¡rios outros juntos, isso indica forte dependÃªncia.
ğŸš« 2. Deploys sincronizados: Ã‰ preciso atualizar vÃ¡rios serviÃ§os ao mesmo tempo, o que dificulta entregas rÃ¡pidas.
ğŸ” 3. Conhecimento excessivo entre serviÃ§os: Um serviÃ§o "sabe demais" sobre a estrutura interna de outro (ex: conhece classes ou tabelas do outro serviÃ§o).
ğŸŒ 4. Baixa autonomia das equipes: Equipes nÃ£o conseguem trabalhar de forma independente, pois sempre dependem de alteraÃ§Ãµes em outros serviÃ§os.
ğŸ” 5. ReutilizaÃ§Ã£o indevida de banco de dados: Um serviÃ§o acessa diretamente o banco de dados de outro, criando forte acoplamento entre dados.
ğŸ§© 6. Falhas em cascata: Quando um serviÃ§o cai, vÃ¡rios outros deixam de funcionar tambÃ©m.

ğŸ‘‰ Esses sinais indicam que o sistema precisa ser refatorado para ter melhor isolamento e independÃªncia entre os microsserviÃ§os. 

7.3 Acoplamento por domÃ­nio

  Quando dois ou mais serviÃ§os compartilham a mesma lÃ³gica de negÃ³cio ou responsabilidade.

  âŒ Problema: os serviÃ§os ficam muito ligados e nÃ£o seguem bem o princÃ­pio de separaÃ§Ã£o por contexto.

  ğŸ’¡ SoluÃ§Ã£o: usar Bounded Contexts da modelagem DDD (Domain-Driven Design), garantindo que cada serviÃ§o cuide apenas do seu domÃ­nio especÃ­fico.

  Ex: um serviÃ§o de vendas que depende de regras internas do serviÃ§o de pagamentos para funcionar.

7.4 Acoplamento por repasse de dados

  Acontece quando um serviÃ§o precisa repassar dados que nÃ£o sÃ£o dele, apenas para ajudar outro serviÃ§o.

  âŒ Problema: o serviÃ§o vira um "mensageiro", ficando inchado e responsÃ¡vel por dados que nÃ£o fazem parte do seu domÃ­nio.

  ğŸ’¡ SoluÃ§Ã£o: permitir que o serviÃ§o que realmente precisa dos dados os busque diretamente ou use uma mensageria/eventos.

  Ex: o serviÃ§o A recebe uma requisiÃ§Ã£o, repassa dados para B, que repassa para C â€” sendo que sÃ³ C realmente precisa da informaÃ§Ã£o.


7.5 Acoplamento por recurso comum

  Ocorre quando vÃ¡rios serviÃ§os compartilham o mesmo recurso, como um banco de dados, cache ou arquivo.

  âŒ Problema: se um serviÃ§o altera o recurso, pode impactar os outros.

  ğŸ’¡ SoluÃ§Ã£o: cada serviÃ§o deve ter seu prÃ³prio recurso isolado. Dados em comum podem ser replicados ou sincronizados por eventos.

  Ex: dois serviÃ§os usam a mesma tabela no banco de dados.

7.6 Acoplamento por estrutura interna e Information hiding

  Acontece quando um serviÃ§o expÃµe detalhes da sua estrutura interna para outros.

  âŒ Problema: se a estrutura mudar, todos os serviÃ§os dependentes quebram.

  ğŸ’¡ SoluÃ§Ã£o: usar encapsulamento e contratos claros (como DTOs e APIs estÃ¡veis), escondendo os detalhes internos.

  Ex: outro serviÃ§o acessa diretamente os campos de uma entidade interna, ao invÃ©s de usar uma API ou DTO.

  Information Hiding: Um serviÃ§o nÃ£o deve expor detalhes internos para outro

7.7 Alta coesÃ£o, Single Resposability Principle e Common Clousure Principle

Organize seus serviÃ§os para que cada um tenha uma Ãºnica responsabilidade, alta coesÃ£o interna e mude o mÃ­nimo possÃ­vel com mudanÃ§as externas.

ğŸ”¹ Alta coesÃ£o
  Cada serviÃ§o deve ter responsabilidades relacionadas e bem definidas.
  Um serviÃ§o faz bem uma coisa especÃ­fica, sem misturar funcionalidades.
  BenefÃ­cio: cÃ³digo mais organizado, fÃ¡cil de entender, testar e manter

ğŸ”¹ SRP (Single Responsibility Principle)
  (PrincÃ­pio da Responsabilidade Ãšnica)
  Um mÃ³dulo (ou serviÃ§o) deve ter apenas um motivo para mudar.
  Ele resolve um Ãºnico problema ou funÃ§Ã£o dentro do sistema.
  Ex: um serviÃ§o que sÃ³ gerencia usuÃ¡rios â€” nÃ£o cuida de autenticaÃ§Ã£o, relatÃ³rios, etc.

ğŸ”¹ CCP (Common Closure Principle)
  (PrincÃ­pio do Fechamento Comum)
  Classes (ou funcionalidades) que mudam pelos mesmos motivos devem estar juntas no mesmo mÃ³dulo.
  Isso minimiza o impacto de mudanÃ§as e facilita a evoluÃ§Ã£o do sistema.
  Ex: tudo que muda quando hÃ¡ uma alteraÃ§Ã£o nas regras de pagamento deve estar no mesmo serviÃ§o.


7.8. Lei de Constantine: Equilibrando entre acoplamento e coesÃ£o

"A estrutura de um sistema de software deve ser tal que minimize o acoplamento entre os mÃ³dulos e maximize a coesÃ£o dentro dos mÃ³dulos",
ou seja: "Alta coesÃ£o e baixo acoplamento"

ğŸ”— Acoplamento
DefiniÃ§Ã£o: Grau de dependÃªncia entre mÃ³dulos.
DesejÃ¡vel: Baixo acoplamento.
Por quÃª? Sistemas com baixo acoplamento sÃ£o mais fÃ¡ceis de manter, testar e evoluir.

ğŸ§± CoesÃ£o
DefiniÃ§Ã£o: Grau em que os elementos de um mÃ³dulo estÃ£o relacionados entre si.
DesejÃ¡vel: Alta coesÃ£o.
Por quÃª? Um mÃ³dulo coeso Ã© mais compreensÃ­vel e realiza uma Ãºnica responsabilidade bem definida.

7.9. Decompondo por capacidades de negÃ³cio (Business Capabilities)

Capacidades de negÃ³cio sÃ£o as habilidades fundamentais que uma organizaÃ§Ã£o possui para gerar valor. Elas representam o "o que a empresa faz", de maneira estÃ¡vel, independente de processos, pessoas ou tecnologias.

Exemplos de capacidades:
Cadastro de Clientes
Gerenciamento de Pedidos
Faturamento
Controle de Estoque
Pagamento de Royalties

ğŸ§  Pense nelas como "blocos funcionais autÃ´nomos" que existem mesmo se a tecnologia ou processos mudarem.

Decompor sistemas por capacidades de negÃ³cio Ã© uma prÃ¡tica que:

Reduz o acoplamento entre mÃ³dulos
Aumenta a coesÃ£o dentro dos mÃ³dulos
ReforÃ§a a autonomia das equipes
Acelera a entrega de valor

Ela representa um passo maduro na direÃ§Ã£o da arquitetura orientada ao negÃ³cio, ideal para organizaÃ§Ãµes que desejam escalar com seguranÃ§a, clareza e eficiÃªncia.

7.10. Refinando fronteiras por subcapacidades e requisitos nÃ£o funcionais

ApÃ³s decompor o sistema em capacidades de negÃ³cio, o prÃ³ximo passo natural Ã© refinar essas divisÃµes para que reflitam subcapacidades mais especÃ­ficas e
requisitos nÃ£o funcionais (RFNs) relevantes â€” como desempenho, escalabilidade, seguranÃ§a e disponibilidade.

Esse refinamento permite maior granularidade, clareza arquitetural e alinhamento com restriÃ§Ãµes tÃ©cnicas e operacionais.

ğŸ§± O que sÃ£o Subcapacidades?
Subcapacidades sÃ£o desdobramentos especializados de uma capacidade de negÃ³cio, representando partes coesas e reutilizÃ¡veis de seu comportamento.

Exemplo:
Capacidade: Distribuir Recebimentos

Subcapacidades possÃ­veis:
Calcular valores de repasse
Aplicar regras de rateio por contrato
Gerar extratos de distribuiÃ§Ã£o
Validar dados antes do repasse

Cada subcapacidade pode representar uma fronteira lÃ³gica para um mÃ³dulo, componente ou microserviÃ§o.

âš™ï¸ E os Requisitos NÃ£o Funcionais?
Requisitos nÃ£o funcionais afetam como o sistema deve se comportar,
independentemente da lÃ³gica de negÃ³cio. Eles tÃªm um impacto direto sobre a forma como refinamos ou isolamos partes do sistema.

Exemplos comuns:
RFN	Impacto no refinamento
Desempenho	Separar partes crÃ­ticas para otimizaÃ§Ã£o especÃ­fica
Escalabilidade	Isolar componentes para escalar horizontalmente
SeguranÃ§a	Conter dados sensÃ­veis em serviÃ§os restritos
TolerÃ¢ncia a falhas	Separar fluxos crÃ­ticos de fluxos nÃ£o essenciais
Auditabilidade	Criar mÃ³dulos especializados para rastreabilidade

7.11. Reconhecendo bad smells na modelagem de microsserviÃ§os

Na jornada de modelagem de microsserviÃ§os, Ã© comum cometer erros que, embora nÃ£o causem falhas imediatas,
resultam em sistemas difÃ­ceis de manter, escalar ou evoluir. Esses sintomas sÃ£o conhecidos como "bad smells" (ou "maus odores arquiteturais").
ReconhecÃª-los cedo permite realizar ajustes antes que se tornem problemas sistÃªmicos.

1. ServiÃ§os com nomes genÃ©ricos
âš ï¸ UserService, DataService, InfoService, etc.
âŒ Indica falta de alinhamento com capacidades de negÃ³cio.
âœ… Prefira nomes como CadastroDeClientesService ou DistribuicaoDeRecebimentosService.

2. Modelos de dados compartilhados
âš ï¸ VÃ¡rios serviÃ§os acessando a mesma tabela ou esquema de banco.
âŒ Viola o princÃ­pio de autonomia do microserviÃ§o.
âœ… Cada serviÃ§o deve ter seu prÃ³prio modelo de dados e, idealmente, sua prÃ³pria base.

3. OrquestraÃ§Ã£o centralizada excessiva
âš ï¸ Um serviÃ§o "controlador" que decide tudo o que os outros fazem.
âŒ Cria acoplamento entre fluxos e perda de resiliÃªncia.
âœ… Use coreografia por eventos quando possÃ­vel para manter os serviÃ§os desacoplados.

4. ServiÃ§os que fazem â€œtudoâ€
âš ï¸ Um serviÃ§o que cuida de autenticaÃ§Ã£o, negÃ³cios, relatÃ³rios e mais.
âŒ Alto acoplamento interno, baixa coesÃ£o.
âœ… Divida por subcapacidades ou bounded contexts.

5. ComunicaÃ§Ã£o sÃ­ncrona entre todos os serviÃ§os
âš ï¸ ServiÃ§os chamando outros via HTTP em cadeia.
âŒ Cria dependÃªncia de disponibilidade em tempo real (cascata de falhas).
âœ… Use mensageria assÃ­ncrona (Kafka, RabbitMQ) quando possÃ­vel.

6. InconsistÃªncia de contratos de API
âš ï¸ MudanÃ§as em uma API quebram outros serviÃ§os.
âŒ Falta de versionamento ou contratos bem definidos.
âœ… Use OpenAPI/Swagger com versionamento e controle de compatibilidade.

7. RepetiÃ§Ã£o de lÃ³gica de negÃ³cio entre serviÃ§os
âš ï¸ Mesmas validaÃ§Ãµes ou cÃ¡lculos espalhados em vÃ¡rios pontos.
âŒ Quebra o princÃ­pio DRY e gera divergÃªncia com o tempo.
âœ… Centralize essa lÃ³gica em um serviÃ§o Ãºnico ou extrato comum com versionamento.

8. DependÃªncia circular entre serviÃ§os
âš ï¸ ServiÃ§o A chama B que chama C que chama A.
âŒ Dificulta testes, manutenÃ§Ã£o e implantaÃ§Ã£o.
âœ… Reavalie a modelagem de fronteiras; talvez o domÃ­nio nÃ£o esteja bem particionado.

9. DependÃªncia excessiva de gateways ou proxies
âš ï¸ Todos os acessos passam por um Ãºnico gateway que contÃ©m lÃ³gica demais.
âŒ Gera um novo "monolito disfarÃ§ado".
âœ… Gateways devem ser finos, delegando lÃ³gica aos serviÃ§os.

10. Falta de ownership claro
âš ï¸ Equipe A cuida do backend, B do frontend, C do banco.
âŒ NinguÃ©m Ã© dono de ponta a ponta da capacidade.
âœ… Use o modelo "You build it, you run it" com times alinhados por capacidade.

Reconhecer bad smells na modelagem de microsserviÃ§os Ã© uma habilidade essencial para manter a arquitetura limpa, escalÃ¡vel e sustentÃ¡vel.
Eles indicam pontos de atenÃ§Ã£o, nÃ£o falhas absolutas â€” mas ignorÃ¡-los tende a levar a um "microlito": um monolito fragmentado que combina o pior dos dois mundos.


7.12. Projeto AlgaSensors: Entendendo o negÃ³cio da empresa

- Monitoramento remoto de temperaturas (Ramo da Empresa)
- Usam sensores inteligentes (Sensores enviam os dados via internet)
- Existem modelos de sensores, e cada modelo de sensor trabalha com 1 protocolo de comunicaÃ§Ã£o (HTTP, TCP, GRPC)
- A gestÃ£o dos sensores sÃ£o feitas via planilha excel
- Dados de um sensor (nome, endereÃ§o, ip, modelo, protocolo)
- Para instalar um sensor 
  - O cliente informa a localidade
  - Escolhe o modelo e cadastra o sensor
  - O tecnico vai e instala o sensor
- Monitoramento do sensor:
  - Os colaboradores utilizam um dashboard 
  - Conseguem ver a temperatura em tempo real
- A empresa possui cerca de 500 sensores e querem expandir
- O intervalo de tempo idela para registrar as temperaturas seria a cada 5 segundos
- Dois alarmes por sensor (temperatura minima e maxima)

- Problemas:
  - NÃ£o Ã© possÃ­vel desativar um sensor a distancia, porÃ©m pode ser feito remoto pois o sensor aceita
  - A dashboard nÃ£o suporta todo tipo de sensor
  - A dashboard sÃ³ exibe os dados, porÃ©m nÃ£o envia alertas
  - A dashboard nÃ£o possui histÃ³rico
  - A dashboard ficou lenta apÃ³s cadastro dos sensores

Requisitos Funcionais:
RF1 - Receber e armazenar os dados de temperatura
RF2 - Cadastrar sensores
RF3 - Ativar os desativar sensores remotamente
RF4 - Concsultar temperaturas registradas
RF5 - Alertar quando as temperaturas estiverem fora dos limites

Requisitos NÃ£o Funcionais
RNF1 - Capacidade de processar um grande volume de dados (A cada 5 segundos receberemos atualizaÃ§Ã£o sobre temperaturas e o dashboard necessita de atenÃ§aÃµ)

Objetos de negÃ³cio:
Sensor (Nome, Protocolo, Modelo, LocalizaÃ§Ã£o, IP, tempMax, temMin, Ativo, TemperaturaAtual)
Registro Temperatura (Sensor, Valor da temperatura, Data Registro) 

Modulos:

GestÃ£o de sensores:
  - Instalar Sensores
  - Realizar ManutenÃ§Ã£o
  - Cadastrar 
  - Ativar / Desativar

Monitoramento de temperaturas:
  - Monitorar temperatura
  - Registro de temperatura
  - Alertar
  - registrar
  - HistÃ³rico


7.13 Projeto AlgaSensors: Modelando um monolito

Ferramente: https://whimsical.com/

https://whimsical.com/algasensors-projeto-1-monolitico-CoJRjNz2cZmu5JsC3ve3LY

7.14. Projeto AlgaSensors: Modelando microsserviÃ§os por capacidades de negÃ³cio

https://whimsical.com/algasensors-projeto-2-ms-por-capacidade-de-negocio-SPG4WbrTtSMRxKvQA5feFy


7.15: Melhorando microsserviÃ§os

https://whimsical.com/algasensors-projeto-3-ms-por-capacidade-de-negocio-quebra-tecnic-WYzsyeWfajy9vFMswiRQTN

7.17. DecomposiÃ§Ã£o por subdomÃ­nios: como DDD pode ajudar?

Como o DDD ajuda na decomposiÃ§Ã£o por subdomÃ­nios?

1. Entendimento profundo do domÃ­nio
  DDD enfatiza a colaboraÃ§Ã£o entre especialistas do negÃ³cio (domain experts) e desenvolvedores. Isso permite:
  Identificar as partes distintas do domÃ­nio.
  Compreender melhor os limites, regras e objetivos de cada Ã¡rea.
  Evitar suposiÃ§Ãµes erradas ou generalizaÃ§Ãµes perigosas.

2. IdentificaÃ§Ã£o de subdomÃ­nios
  DDD classifica os subdomÃ­nios em trÃªs tipos principais:
  Core Domain (DomÃ­nio Central): Ã‰ o coraÃ§Ã£o do negÃ³cio. Onde estÃ¡ o maior diferencial competitivo. Deve ter atenÃ§Ã£o mÃ¡xima.
  Supporting Subdomain (DomÃ­nio de Suporte): Apoia o domÃ­nio central, mas nÃ£o Ã© exclusivo. Pode ser implementado sob medida.
  Generic Subdomain (DomÃ­nio GenÃ©rico): SÃ£o necessidades comuns, que nÃ£o diferenciam a empresa (ex: autenticaÃ§Ã£o, envio de e-mail) â€” podem ser terceirizadas ou reutilizadas.

3. DelimitaÃ§Ã£o com Bounded Contexts
  Um Bounded Context (Contexto Delimitado) Ã© o contÃªiner lÃ³gico onde um modelo faz sentido. DDD propÃµe que cada subdomÃ­nio tenha seu prÃ³prio modelo, isolado em um bounded context:
  Evita conflitos semÃ¢nticos (ex: â€œClienteâ€ no contexto de cobranÃ§a â‰  â€œClienteâ€ no contexto de CRM).
  Permite escolher arquiteturas, tecnologias e estratÃ©gias de modelagem diferentes conforme a necessidade.
  Facilita a evoluÃ§Ã£o independente de partes do sistema.

4. Base para arquitetura modular
  Com subdomÃ­nios bem definidos e bounded contexts claros, vocÃª pode:
  Criar microserviÃ§os coesos (um por contexto).
  Aplicar modularizaÃ§Ã£o com menos acoplamento.
  Ter times autÃ´nomos por contexto, promovendo escalabilidade organizacional.

5. Melhor alinhamento com o negÃ³cio
  Ao decompor com base em subdomÃ­nios, vocÃª modela o sistema de acordo com a realidade do negÃ³cio e nÃ£o com a estrutura tÃ©cnica. Isso gera:
  Mais valor entregue ao negÃ³cio.
  Menos retrabalho e mais clareza nas funcionalidades.
  Possibilidade de adaptaÃ§Ã£o mais rÃ¡pida Ã s mudanÃ§as.

8.3. Maven ou Gradle?

Ferramentas para Build

Java
  - Maven
    - XML
    - Dependencias Maven
    - Build Linear (passo a passo)
    - CustomizaÃ§Ã£o via Plugins
  - Gradle
    - Groovy
    - Dependencias Maven
    - Build incremental
    - CosutmizaÃ§Ã£o via plugins e tasks com groovy

8.4. Git Repository: Monorepo vs multirepo

ğŸ§± O que Ã© Monorepo?
Um monorepo (monolithic repository) Ã© um Ãºnico repositÃ³rio Git que contÃ©m o cÃ³digo de mÃºltiplos projetos, mÃ³dulos ou serviÃ§os, geralmente relacionados entre si.

âœ… Vantagens do Monorepo
VisÃ£o unificada: Todo o cÃ³digo estÃ¡ no mesmo lugar, facilitando a navegaÃ§Ã£o e o entendimento do sistema como um todo.
RefatoraÃ§Ãµes entre projetos: AlteraÃ§Ãµes coordenadas em vÃ¡rias bibliotecas e serviÃ§os ficam mais fÃ¡ceis (ex: atualizar uma interface usada por vÃ¡rios mÃ³dulos).
PadronizaÃ§Ã£o: Ferramentas, estilos de cÃ³digo, CI/CD e dependÃªncias podem ser centralizados.
Atomic commits: Possibilita commits que afetam mÃºltiplos serviÃ§os ao mesmo tempo de forma consistente.

âŒ Desvantagens do Monorepo
Escalabilidade do Git: RepositÃ³rios muito grandes podem ficar lentos, especialmente sem ferramentas especÃ­ficas (como Nx, Lage, Bazel, git sparse-checkout, etc).
Gerenciamento de permissÃµes: Pode ser difÃ­cil restringir o acesso a apenas uma parte do cÃ³digo.
Builds mais complexos: Requer ferramentas para evitar builds e testes desnecessÃ¡rios.


ğŸ“¦ O que Ã© Multirepo?
No multirepo, cada projeto, biblioteca ou serviÃ§o tem seu prÃ³prio repositÃ³rio Git separado.

âœ… Vantagens do Multirepo
Isolamento claro: Cada equipe ou projeto trabalha de forma independente, com menos risco de impactos cruzados.
Controle de acesso mais simples: Pode restringir o acesso por repositÃ³rio.
HistÃ³rico e CI/CD separados: Cada repositÃ³rio tem sua pipeline e versionamento especÃ­ficos.

âŒ Desvantagens do Multirepo
Complexidade na orquestraÃ§Ã£o: AlteraÃ§Ãµes que afetam mÃºltiplos repositÃ³rios exigem mais coordenaÃ§Ã£o.
Gerenciamento de dependÃªncias: Pode gerar conflitos de versÃ£o ou retrabalho em atualizaÃ§Ãµes.
Menos visibilidade: DifÃ­cil ter uma visÃ£o global do sistema.

ğŸ“Œ O que sÃ£o Git Submodules?
Um Git Submodule permite que vocÃª adicione um repositÃ³rio Git dentro de outro repositÃ³rio Git, funcionando como uma espÃ©cie de ponte entre mÃºltiplos repositÃ³rios.

ğŸ” Submodule = um repositÃ³rio "filho" referenciado dentro de um repositÃ³rio "pai".

ğŸ§± Quando usar?
Use submodules quando:
VocÃª quer reaproveitar um projeto existente (ex: uma biblioteca ou serviÃ§o).
Os projetos tÃªm ciclos de vida diferentes e nÃ£o devem estar no mesmo repositÃ³rio.
VocÃª nÃ£o quer copiar cÃ³digo, mas tambÃ©m nÃ£o quer que tudo esteja num Ãºnico monorepo.

ğŸ”„ Comandos Ãºteis com Submodules
AÃ§Ã£o	Comando
Clonar repositÃ³rio com submodules:  	$ git clone --recurse-submodules <url>
Atualizar todos os submodules: 	      $ git submodule update --init --recursive
Puxar mudanÃ§as dos submodules:        $ cd services/email-service && git pull
Remover um submodule:               	Editar .gitmodules, remover a pasta, e git rm

8.5. Criando Git Repository dos serviÃ§os

ems algasensors

serviÃ§o pai: 
  - ems-algasensors-meta
filhos: 
  - ems-algasensors-temperature-processing
  - ems-algasensors-device-management
  - ems-algasensors-temperature-monitoring

8.6. Configurando Git submodules

Configurando dentro do super project 

- clone o repository pai
- dentro do repository pai crie uma pasta /microservices
- $ git submodule add git@github.com:LucianoFraga27/ems-algasensors-temperature-monitoring.git /microservices temperature-monitoring
- $ git pull --recurse-submodules | git pull de todos os modulos
- $ git clone --recurse-submodules -j8 <ulr-repository-pai> | clonando todos os repositorios pai e filhos

8.7. Criando microsserviÃ§os com Spring Boot e Gradle

8.9. Gradle: Estrutura do projeto

build: 
bootJar -> JAR
build -> realiza os testes + bootJar
check : realiza todos os testes
test : testes

8.10. Instalando o plugin do Lombok na IntelliJ IDEA

- instalar plugin Lombok
- enable annotations processors

8.12. Adicionando plugins do Gradle

8.13. Adicionando novas dependÃªncias no Gradle

https://mvnrepository.com/artifact/org.apache.commons/commons-lang3

implementation 'org.apache.commons:commons-lang3:3.17.0'

8.14. Gerenciando serviÃ§os na IntelliJ IDEA

Executando multiplos serviÃ§os no IntelliJ IDEA

Passo 1: Alterar a porta dos serviÃ§os

Passo 2: Configure a execuÃ§Ã£o da aplicaÃ§Ã£o
  - vm options: -XX:MaxRAM=256m
  - working directory: deixe apontando para o microserviÃ§o dele
  - store as project file : guarde a configuraÃ§Ã£o como um arquivo do projeto

Passo 3: Add Services
  - Applications

8.15. O que Ã© SonarQube?

Sast (Static Application Security Test)
Clean as you code [Limpar o cÃ³digo durante o desenvolvimento]

Ã© uma plataforma open-source usada para anÃ¡lise (estÃ¡tica) contÃ­nua da qualidade de cÃ³digo. Ele permite inspecionar automaticamente o cÃ³digo-fonte para detectar:

- Bugs
- Vulnerabilidades de seguranÃ§a
- "Code smells" (mÃ¡s prÃ¡ticas de codificaÃ§Ã£o)
- Cobertura de testes
- DuplicaÃ§Ãµes de cÃ³digo
- Problemas de manutenibilidade

Principais caracterÃ­sticas:
- Suporte a mÃºltiplas linguagens: Java, JavaScript, C#, Python, TypeScript, entre outras.
- IntegraÃ§Ã£o com CI/CD: Pode ser integrado com Jenkins, GitLab CI, GitHub Actions etc.
- Dashboards interativos: Fornece relatÃ³rios visuais e mÃ©tricas de qualidade do cÃ³digo.
- Qualidade de cÃ³digo como critÃ©rio de aprovaÃ§Ã£o: Pode bloquear builds se o cÃ³digo nÃ£o atender a um padrÃ£o mÃ­nimo de qualidade.
- ExtensÃ­vel: Suporta plugins e possui uma versÃ£o comercial com recursos extras (SonarQube Developer, Enterprise, etc.).

- O cÃ³digo-fonte Ã© analisado por um scanner (como o sonar-scanner).
- Os resultados sÃ£o enviados ao servidor do SonarQube.
- A interface web do SonarQube exibe os problemas encontrados e orientaÃ§Ãµes para resolvÃª-los.

Banco de Regras:
- OWASP
- Clean Code
- SonarSource
- Code Conventions
- Regras Costumizadas

Segurabilidade, Confiabilidade e Manutenibilidade

Beneficios:
- Evita bugs
- Busca vunerabilidades de seguranÃ§a
- Evita code Smals

SonarQube Cloud, SonarQube Server, SonarQube IDE (LINT)

8.16. Instalando o SonarQube plugin na IntelliJ IDEA

https://plugins.jetbrains.com/plugin/7973-sonarqube-for-ide


9.1. O problema dos identificadores nos sistemas distribuÃ­dos

O ID serve para:
- Referencia unicidade
- OrganizaÃ§Ã£o dos Dados
- Integridade dos Dados
- Relacionamentos
- Rastreabilidade

Em sistemas distribuÃ­dos, identificadores Ãºnicos sÃ£o essenciais para distinguir entidades como usuÃ¡rios, sessÃµes, objetos, transaÃ§Ãµes, arquivos e recursos de rede.
No entanto, garantir unicidade e consistÃªncia desses identificadores em um ambiente distribuÃ­do apresenta desafios especÃ­ficos.

ğŸ§© Desafios principais
1. AusÃªncia de um ponto central
  - Em sistemas distribuÃ­dos, nÃ£o hÃ¡ um servidor Ãºnico controlando a geraÃ§Ã£o de IDs.
  - Cada nÃ³ pode operar de forma independente, o que dificulta a coordenaÃ§Ã£o para evitar duplicatas.
2. ColisÃµes de identificadores
  - Dois nÃ³s diferentes podem gerar o mesmo identificador se nÃ£o houver um mecanismo de distinÃ§Ã£o, como namespace ou prefixos Ãºnicos.
3. SincronizaÃ§Ã£o de relÃ³gios
  - Identificadores baseados em timestamp podem gerar duplicaÃ§Ãµes ou ordem incorreta se os relÃ³gios dos servidores nÃ£o estiverem sincronizados.
4. LatÃªncia e particionamento
  - A comunicaÃ§Ã£o entre nÃ³s pode ser lenta ou falhar temporariamente (ex: partiÃ§Ãµes de rede), impedindo o consenso global.
5. Escalabilidade
  - Sistemas precisam gerar bilhÃµes de identificadores Ãºnicos sem se tornarem um gargalo ou depender de um coordenador central.

ğŸ”§ SoluÃ§Ãµes comuns
1. UUID (Universally Unique Identifier)
  - Exemplo: 550e8400-e29b-41d4-a716-446655440000
  - Gerado localmente com base em timestamp, MAC address, aleatoriedade ou uma combinaÃ§Ã£o disso.
  - Muito usado, mas nÃ£o ordenado e pode ser "grande" para certas aplicaÃ§Ãµes.
2. Snowflake IDs (Twitter)
  - IDs de 64 bits que incluem timestamp + ID do datacenter + ID do worker + contador.
  - SÃ£o Ãºnicos, ordenÃ¡veis e eficientes para sistemas distribuÃ­dos.
3. Banco centralizado de IDs
  - Um serviÃ§o Ãºnico que gera e distribui identificadores.
  - Funciona, mas introduz um ponto Ãºnico de falha e limita a escalabilidade.
4. PrÃ©-alocaÃ§Ã£o de faixas
  - Cada nÃ³ recebe uma faixa de nÃºmeros (ex: 1000 a 1999) e gera IDs dentro dela.
  - Reduz colisÃµes, mas exige coordenaÃ§Ã£o prÃ©via e pode desperdiÃ§ar IDs.
5. Hashing com sal Ãºnico
  - NÃ³s aplicam funÃ§Ãµes hash com sementes Ãºnicas para evitar colisÃµes mesmo com entradas parecidas.
6. TSID (Time-Sortable Identifier)
  - Um identificador Ãºnico que incorpora informaÃ§Ãµes de tempo, permitindo que seja ordenado cronologicamente, ao mesmo tempo em que permanece Ãºnico em ambientes distribuÃ­dos.
  - Inspirado no Snowflake ID do Twitter, mas Ã© mais simples, mais eficiente e com foco em linguagens como Java, Kotlin, etc.

9.2. Entendendo o UUID v4 e v7

# ğŸ“Š UUID v4 â€” AleatÃ³rio puro
 - Base AleatÃ³ria
 - NÃ£o ordenavel pelo tempo
 - Alta aleatoriedade 
 - Identificadores Ãºnicos nÃ£o ordenados
 - Gerado com nÃºmeros totalmente aleatÃ³rios (exceto por alguns bits reservados).
 - Tem 122 bits efetivamente aleatÃ³rios (de um total de 128 bits).
 - Exemplo: f47ac10b-58cc-4372-a567-0e02b2c3d479
 - Vantagem: Simples, universal, compatÃ­vel com qualquer linguagem.
 - Vantagem: Alta entropia: baixa chance de colisÃ£o.
 - Desvantagem: NÃ£o ordenÃ¡vel por tempo â†’ dificulta buscas ou indexaÃ§Ã£o eficiente em bancos de dados.
 - Desvantagem: Pode prejudicar o desempenho de Ã­ndices (por serem aleatÃ³rios e causarem fragmentaÃ§Ã£o).
 - ImplementaÃ§Ã£o Nativa no Java: java.util.UUID.randomUUID(); 
 
# ğŸ†• UUID v7 â€” Ordenado por tempo (novo padrÃ£o)
  - Base Tempo + Rand
  - Ordenavel pelo tempo
  - AleatÃ³rio
  - SubstituiÃ§Ã£o moderna e ordenavel do V4
  - Combina timestamp no inÃ­cio (em milissegundos) com bits aleatÃ³rios no final.
  - Garante unicidade + ordenaÃ§Ã£o temporal.
  - Foi padronizado pelo IETF como evoluÃ§Ã£o natural ao UUID v1 (que tinha problemas com MAC address e privacidade).
  - Exemplo: 01890f5e-a3b1-7ccd-91e5-d00e2b4733e4
  - Os primeiros bits representam o tempo â†’ o UUID Ã© naturalmente ordenÃ¡vel.
  - Isso Ã© ideal para logs, mensagens, bancos de dados, etc.
  - Vantagem: Unicidade com base em tempo + aleatoriedade.
  - Vantagem: Ideal para sistemas distribuÃ­dos com necessidade de ordenar eventos.
  - Vantagem: Melhor para indexaÃ§Ã£o em bancos de dados.
  - Desvantagem: Ainda nÃ£o suportado por 100% das bibliotecas nativas em todas as linguagens (mas estÃ¡ se espalhando rapidamente).
  - Desvantagem: NÃ£o Ã© "puro aleatÃ³rio", entÃ£o nÃ£o serve para casos onde se quer entropia mÃ¡xima.
  - ImplementaÃ§Ã£o Java pela biblioteca : Faster:XML
    - com.fasterxml.uuid.TimeBasedEpochRandomGenerator

ColisÃµes
- 18 quintilhÃµes por ms antes de uma colisÃ£o

Vantagens:
  - Unicidade global, SÃ£o Ãºnicos em escala global, probabilidade de colisÃ£o praticamente zero
  - GeraÃ§Ã£o Descentralizada, IndependÃªncia de banco de dados, flexibilidade de uso
  - Valores Imprevisiveis, mais seguro em diversos aspectos
  - Suporte Universal, usado por diversos tipos de tecnologia

Desvantagens:
  - tamanho (ocupa 128bits)
  - legibilidade por humanos
  - OrdenaÃ§Ã£o e indexaÃ§Ã£o: Custam mais para o banco de dados (v4 nÃ£o ordenÃ¡vel, v7 ordenavel e indexavel)

Quando usar? 
- Sistemas Distribuidos
- Indentificadores publicos ou expostos
- geraÃ§Ã£o descentralizada
- evitar vazamento de informaÃ§Ãµes

Quando nÃ£o usar?
- Quando a legebilidade Ã© necessÃ¡ria
- Em sistemas pequenos e centralizados
- Quando a aleatorieadade nÃ£o Ã© necessÃ¡ria
- Quando o desempenho do banco de dados Ã© critico

9.3. Entendendo o TSID (Time-Sortable Identifier)

Um identificador Ãºnico que incorpora informaÃ§Ãµes de tempo, permitindo que seja ordenado cronologicamente,
ao mesmo tempo em que permanece Ãºnico em ambientes distribuÃ­dos.

Ele foi inspirado no Snowflake ID do Twitter, mas Ã© mais simples, mais eficiente e com foco em linguagens como Java, Kotlin, etc.

ğŸ§¬ Estrutura de um TSID (geralmente 64 bits)
Bits	Campo 	            DescriÃ§Ã£o
42	  Timestamp	          Tempo em milissegundos desde uma Ã©poca customizada (geralmente 2020-01-01)
22	  Entropia/AleatÃ³rio	Bits de entropia para garantir unicidade entre nÃ³s ou processos simultÃ¢neos

Exemplo de TSID:
TSID: 1928781481899251712  
Base36: 3S5Z8DVBTM3

ImplementaÃ§Ã£o no Java: io.hypersistence.tsid.TSID

Vantagens:
  - Eficiencia no banco de dados (64 bits)
  - OrdenaÃ§Ã£o temporal
  - GeraÃ§Ã£o descentralizada
  - Boa legebilidade (string de 13 caracteres)

Desvantanges:
  - NÃ£o sÃ£o Ãºnicos em escala global
  - SÃ£o unicos em escala local, um cluster, um nÃ³
  - Maior Complexidade na implementaÃ§Ã£o
    - relogio do sistema
    - numero do nÃ³, tamanho do cluster
    - sincronizaÃ§Ã£o de data e hora entre nÃ³s
  - Valores Previsiveis

Quando Usar?
  - Sistemas Distribuidos
  - Identificadores para banco de dados relacionais
  - URLs e exibiÃ§Ã£o em telas

Quando nÃ£o usar?
  - Quando a imprevisibilidade Ã© critica
  - Em sistemas pequenos e centralizados
  - Quando a ordenaÃ§Ã£o temporal nÃ£o Ã© necessÃ¡ria
  - Quando a unicdade global Ã© necessÃ¡ria

9.4. Usando o UUID v4 e v7 com Java

https://mvnrepository.com/artifact/com.fasterxml.uuid/java-uuid-generator

implementation 'com.fasterxml.uuid:java-uuid-generator:5.1.0'

9.5. Usando o TSID com Java

https://github.com/vladmihalcea/hypersistence-tsid?tab=readme-ov-file

https://mvnrepository.com/artifact/io.hypersistence/hypersistence-tsid

implementation 'io.hypersistence:hypersistence-tsid:2.1.4'

9.6. Outros tipos e abordagens: Snowflake ID, Ticket Server e Dual Identifier

1. Snowflake ID (Twitter)
- Estrutura: ID de 64 bits, inclui timestamp, data center, worker e sequÃªncia.
- Formato: Geralmente um nÃºmero inteiro longo.
- Exemplo de ID: 1537200203577346048
- Vantagem: Ordenado por tempo, Ãºnico em sistemas distribuÃ­dos.

2. Ticket Server (ou Centralized ID Generator)
- Estrutura: Um servidor central gera IDs incrementais.
- Formato: Simples e sequencial.
- Exemplo de ID: 1001, 1002, 1003
- Vantagem: FÃ¡cil de entender e depurar.
- Desvantagem: Ponto Ãºnico de falha e gargalo.

3. Dual Identifier
- Estrutura: Dois identificadores â€” um interno (sequencial) e outro externo (pÃºblico, geralmente UUID ou hash).
- Exemplo:
  Interno: 54783
  Externo: 3fa85f64-5717-4562-b3fc-2c963f66afa6
  Vantagem: Permite expor um ID nÃ£o sequencial/publicamente amigÃ¡vel mantendo controle interno.

10.1. O que vamos implementar?

Design Doc: https://www.notion.so/algaworks1/Design-Doc-Ado-o-da-Arquitetura-de-Microsservi-os-no-AlgaSensors-1a5731beea3580489501f870ac7f3c3e?pvs=4
Modelagem: https://whimsical.com/ems-01-07-15-projeto-algasensors-refinando-modelagem-PL457CGTiNJAY3FGqg5oJE

10.8. YAML ou Properties: qual usar?

A escolha entre YAML (application.yml) e Properties (application.properties) no Spring Boot (versÃ£o 10.8 ou qualquer outra) 
depende de alguns critÃ©rios como legibilidade, estrutura, preferÃªncia da equipe e casos de uso especÃ­ficos.

- Use YAML para configuraÃ§Ãµes complexas e com estrutura hierÃ¡rquica.
- Use Properties para configuraÃ§Ãµes simples e diretas.


12.2 O message broker RabbitMQ


Um "message broker" (tambÃ©m chamado de corretor de mensagens) Ã© um sistema que facilita a comunicaÃ§Ã£o entre diferentes componentes de um sistema,
seja ele um aplicativo, serviÃ§o ou microserviÃ§o. Ele atua como um intermediÃ¡rio, permitindo que os remetentes de mensagens, ou "produtores",
enviem informaÃ§Ãµes para um local centralizado, e os receptores, ou "consumidores", as recebam conforme necessÃ¡rio


O RabbitMQ Ã© um message broker open-source que atua como um intermediador de mensagens entre sistemas.
Ele permite que produtores enviem mensagens para consumidores de forma assÃ­ncrona, confiÃ¡vel e desacoplada.

ğŸ§  Por que usar um Message Broker como o RabbitMQ?

ğŸ”— Desacoplamento entre serviÃ§os (produtor e consumidor nÃ£o precisam estar disponÃ­veis ao mesmo tempo)
â³ Alta disponibilidade e confiabilidade
ğŸ§µ Suporte a mensagens assÃ­ncronas
ğŸ¯ Roteamento inteligente de mensagens
ğŸ“¦ PersistÃªncia de mensagens atÃ© serem consumidas
ğŸ§© Escalabilidade fÃ¡cil: mÃºltiplos produtores/consumidores

ğŸ’¡ Quando usar RabbitMQ?
IntegraÃ§Ã£o entre microserviÃ§os
Processamento em segundo plano
Fila de tarefas assÃ­ncronas
Controle de fluxo de eventos (event-driven architecture)
Reprocessamento automÃ¡tico em caso de falha (com DLQ)

12.3 Componentes do RabbitMQ

O RabbitMQ funciona com base em alguns componentes fundamentais. Aqui estÃ¡ um resumo prÃ¡tico:

1. Producer: Quem envia a mensagem para o broker. (Pode ser uma API, serviÃ§o, script, etc.)
2. Queue (Fila): Onde a mensagem fica armazenada atÃ© ser consumida, Pode ser persistente ou temporÃ¡ria. Cada fila pode ter vÃ¡rios consumidores.
  - name
  - durable: se Ã© para ser permanete
  - exclusive: se Ã© exclusiva de um consumidor
  - arguments (config/features)
  - Estilos de consumo : Push e pull
    - PUSH: Queue ------> Consumer [As mensagens sÃ£o enviadas para o consumirdor assim que chegam]
    - PULL: Queue <------ Consumer [O consumidor solicita as mensagens]
3. Consumer: Quem recebe/processa a mensagem da fila. (Pode haver mÃºltiplos consumidores por fila.)
4. Exchange: Roteia mensagens recebidas dos produtores para uma ou mais filas. (Decide como entregar com base no tipo e na routing key.)
  - direct:	Roteia baseado em uma routing key exata
  - fanout:	Ignora routing key e envia a todas as filas ligadas
  - topic:	Roteia baseado em padrÃµes de routing key com * e #
  - headers:	Roteia baseado nos headers da mensagem em vez de routing key
5. Routing Key: Uma chave que o producer envia junto com a mensagem. (Usada pela exchange para decidir para qual fila enviar.)
6. Binding: A ligaÃ§Ã£o entre uma exchange e uma fila. (Define a routing key que ativa a entrega.)
7. Dead Letter Queue (DLQ): Uma fila especial onde mensagens com falhas de processamento (ou rejeitadas) sÃ£o redirecionadas. (Ãštil para anÃ¡lise e reprocessamento manual.)
8- Message:
  - Metadata: Content type / Routing Key
  - Headers: VersÃ£o, ids etc
  - Payload: xml, json, string etc.. (payloads grandes causam problemas)

[Producer]
    |
    V
[Exchange] --(Routing Key)--> [Queue] --> [Consumer]

12.4. Nomenclaturas e versionamento

Queues & Exchanges. Como nomear ?

Quando trabalhamos com diversos serviÃ§os publicando e consumindo mensagens, uma boa nomenclatura evita:

Conflitos e colisÃµes
Dificuldade de rastreabilidade
Ambiguidade entre ambientes ou versÃµes
Acoplamento indesejado entre serviÃ§os

VocÃª deve definir uma padronizaÃ§Ã£o clara para:
- Exchange:   <producer-name>.<business-process>.<message-version>.e ou . exchange
- Queue:      <consumer-name>.<business-process>.<message-version>.q ou .queue
- Routing Key: 

ConvenÃ§Ã£o Recomendada: <domÃ­nio>.<evento>.<versÃ£o>[.tipo]

Quando versionar?
MudanÃ§a no formato da mensagem
MudanÃ§a na semÃ¢ntica do evento
IntroduÃ§Ã£o de novos campos obrigatÃ³rios
Quebra de compatibilidade com consumidores antigos

Como versionar?
Inclua o sufixo v1, v2, etc. no nome da exchange, fila, e/ou routing key
Mantenha versÃµes antigas ativas se houver consumidores legados

12.5 simulado do rabbit: https://tryrabbitmq.com/

12.x Fluxo simples

ğŸ§± O que existe no RabbitMQ?
Exchange â€“ como uma "central de distribuiÃ§Ã£o"
Fila (Queue) â€“ onde a mensagem fica esperando
Binding â€“ conexÃ£o entre a Exchange e a fila

ğŸ” Qual a ordem correta?
1. Exchange: VocÃª precisa primeiro criar uma exchange, porque Ã© para ela que o produtor envia a mensagem.
* direct â€“ envia para uma fila especÃ­fica baseada em uma â€œchave de roteamentoâ€ (routingKey)
* fanout â€“ envia para todas as filas conectadas
* topic â€“ envia baseado em padrÃµes (ex: email.*)

2. Fila (Queue): Depois, vocÃª cria uma fila, que Ã© onde a mensagem vai â€œficar esperandoâ€.
- A aplicaÃ§Ã£o consumidora escuta essa fila.

3. Binding: AÃ­ vocÃª faz a ligaÃ§Ã£o entre a exchange e a fila, usando uma routingKey (ou nÃ£o)

âš™ï¸ O que o produtor faz? Ele envia uma mensagem para uma exchange, dizendo: "Aqui estÃ¡ a mensagem, envie para a fila X (routingKey: â€˜mensagens.testeâ€™)"
âš™ï¸ O que o consumidor faz? Ele fica escutando uma fila (por exemplo: fila.teste) e quando uma mensagem chega lÃ¡, ele processa.

1. Manualmente no painel do RabbitMQ
VÃ¡ em Queues > Add a new queue â†’ fila.teste
VÃ¡ em Exchanges > Add a new exchange â†’ exchange.teste
VÃ¡ em Bindings > Ligue a exchange na fila com uma routing key (ex: mensagens.teste)

12.19 Direct Exchange

 Direct Exchange Ã© um dos quatro tipos de exchanges padrÃ£o no RabbitMQ 
 e seu funcionamento Ã© baseado em uma regra simples e poderosa: roteamento por correspondÃªncia exata.

Quando um produtor (Producer) envia uma mensagem para uma Direct Exchange,
ele anexa uma "etiqueta" chamada Routing Key (Chave de Roteamento). Essa chave Ã© uma string, por exemplo, "pdf" ou "relatorio_financeiro".

VocÃª tem uma ou mais filas (Queues) que querem receber mensagens. Para receber mensagens de uma exchange, uma fila precisa estar "ligada" a ela.

Ao ligar uma fila a uma Direct Exchange, vocÃª especifica uma Binding Key (Chave de LigaÃ§Ã£o). Essa chave define qual o "endereÃ§o" que aquela fila estÃ¡ escutando.

A exchange entregarÃ¡ uma cÃ³pia da mensagem para todas as filas cuja Binding Key seja exatamente igual Ã  Routing Key da mensagem.

Se a Routing Key da mensagem nÃ£o corresponder exatamente a nenhuma Binding Key, a mensagem Ã© descartada (a menos que existam configuraÃ§Ãµes alternativas, como uma Alternate Exchange).

vs. Fanout Exchange: A Fanout ignora completamente a Routing Key e envia a mensagem para todas as filas ligadas a ela (broadcast).


12.19 Topic Exchange


Se a Direct Exchange Ã© sobre entregar uma carta para um "endereÃ§o exato",
a Topic Exchange Ã© como um serviÃ§o de assinatura de revistas e jornais, onde vocÃª pode assinar categorias de notÃ­cias muito especÃ­ficas ou muito amplas.

A Topic Exchange roteia mensagens com base em uma correspondÃªncia de padrÃ£o entre a Routing Key da mensagem e a Binding Key que liga a exchange Ã  fila.

As chaves sÃ£o uma lista de palavras separadas por pontos (.). Por exemplo: br.sp.temperatura ou log.error.database.

A exchange entrega uma cÃ³pia da mensagem para todas as filas cuja Binding Key (com seus curingas) corresponda Ã  Routing Key da mensagem.


12.21. Headers Exchange

Se a Direct Exchange usa uma "etiqueta de endereÃ§o" (a routing key) e a Topic Exchange usa uma "etiqueta de categoria" hierÃ¡rquica (tambÃ©m a routing key),
a Headers Exchange ignora completamente a routing key. Em vez disso, ela funciona como um inspetor de alfÃ¢ndega,
olhando para as propriedades da mensagem, conhecidas como headers (cabeÃ§alhos).

Ao ligar (bind) uma fila a uma Headers Exchange, vocÃª fornece um ou mais argumentos de cabeÃ§alho. O mais importante desses argumentos Ã© o x-match.

O x-match define como os outros argumentos da ligaÃ§Ã£o devem ser comparados com os cabeÃ§alhos da mensagem. Ele pode ter dois valores:

all (E / AND): A mensagem sÃ³ Ã© enviada para a fila se TODOS os pares chave-valor definidos na ligaÃ§Ã£o estiverem presentes e corresponderem exatamente nos cabeÃ§alhos da mensagem.
any (OU / OR): A mensagem Ã© enviada para a fila se PELO MENOS UM dos pares chave-valor definidos na ligaÃ§Ã£o corresponder a um cabeÃ§alho na mensagem.
A Routing Key, se enviada pelo produtor, Ã© completamente ignorada.


13.1. Retry Pattern

O Retry Pattern (PadrÃ£o de RepetiÃ§Ã£o) Ã© um padrÃ£o de resiliÃªncia usado em sistemas distribuÃ­dos para lidar com falhas temporÃ¡rias em chamadas de rede, como:
Ã‰ muito usado em sistemas distribuÃ­dos, onde falhas intermitentes podem ocorrer ao acessar serviÃ§os externos, bancos de dados, filas de mensagens, etc.

- chamadas a serviÃ§os REST,
- acesso a banco de dados,
- leitura de arquivos remotos,
- ExceÃ§Ãµes momentÃ¢neas em um serviÃ§o

Quando ocorre uma falha, o padrÃ£o instrui o sistema a tentar novamente a operaÃ§Ã£o depois de um pequeno intervalo, em vez de falhar imediatamente.

ğŸ§  Quando usar?
Use o Retry Pattern quando as falhas forem transitÃ³rias, ou seja, provavelmente se resolvem sozinhas em pouco tempo. Exemplos:

- LatÃªncia momentÃ¢nea da rede
- Timeouts intermitentes
- ServiÃ§o de terceiros temporariamente indisponÃ­vel

âš ï¸ Quando nÃ£o usar?
Evite usar quando:

- A falha for permanente (ex: dados invÃ¡lidos, permissÃ£o negada)
- O retry pode causar efeitos colaterais indesejados (ex: duplicaÃ§Ã£o de dados em requisiÃ§Ãµes nÃ£o idempotentes)
- Quando a operaÃ§Ã£o nÃ£o for idempotente, podendo causar efeitos colaterais (ex: envio duplicado de email, criaÃ§Ã£o de registros mÃºltiplos)

ğŸ” EstratÃ©gias Comuns
- Retry Fixo: tenta novamente apÃ³s um tempo fixo.
- Exponential Backoff: tempo de espera cresce exponencialmente (ex: 1s, 2s, 4sâ€¦).
- Jitter: adiciona aleatoriedade ao tempo de espera para evitar congestionamento.

âœ… BenefÃ­cios
- Aumenta a resiliÃªncia da aplicaÃ§Ã£o.
- Evita falhas causadas por problemas passageiros.
- Melhora a experiÃªncia do usuÃ¡rio ao reduzir erros imediatos.

âš ï¸ IdempotÃªncia e TransaÃ§Ãµes
O Retry Pattern Ã© mais seguro quando aplicado a operaÃ§Ãµes idempotentes ou envoltas em transaÃ§Ãµes.

Idempotente: operaÃ§Ã£o que pode ser executada mÃºltiplas vezes sem efeitos colaterais (ex: GET, PUT).
Transacional: operaÃ§Ãµes envoltas em transaÃ§Ãµes podem ser revertidas em caso de erro, garantindo consistÃªncia.

ğŸ”’ Exemplo seguro: PUT /usuario/1234  {"nome": "Renan"} âœ… Idempotente
âš ï¸ Exemplo perigoso: POST /pagamento {"valor": 100}  âŒ NÃ£o idempotente â€” pode cobrar duas vezes!

ğŸ§© Retry Pattern em MicroserviÃ§os


ğŸ”— 1. ComunicaÃ§Ã£o REST
ServiÃ§os podem estar temporariamente indisponÃ­veis.

Use Retry + Timeout + Circuit Breaker para aumentar a resiliÃªncia.

Bibliotecas comuns:
  Resilience4j (Java)
  Spring Retry
  Hystrix (legado)
  Axios Retry (JavaScript)
  Polly (.NET)

âœ‰ï¸ 2. ComunicaÃ§Ã£o por Mensageria (ex: RabbitMQ, Kafka)
Mensagens podem falhar no consumo ou no processamento.

Retry pode ser:
  AutomÃ¡tico via reentrega da mensagem (DLQ, retry queues)
  Manual com tentativas controladas no cÃ³digo do consumidor
  Ideal em consumidores idempotentes (ex: atualizaÃ§Ã£o de status)

ğŸ§· Dica:
  Use Dead Letter Queues (DLQ) para mensagens que falham apÃ³s N tentativas.
  Em Kafka, considere reprocessamento com controle de offset.

â“ Retry Pattern Ã© melhor para chamadas sÃ­ncronas ou assÃ­ncronas?

ğŸ” 1. Em chamadas SÃNCRONAS
Por exemplo, vocÃª faz uma chamada HTTP (REST) para outro serviÃ§o e quer tentar de novo caso ele falhe.

ğŸ”— Exemplo: RESTTemplate, FeignClient, WebClient no Spring.
  â±ï¸ O cliente espera pela resposta e o retry acontece no mesmo fluxo.
  ğŸ’¡ Cuidado com o tempo total de espera!
    Se vocÃª fizer 3 tentativas com 2 segundos cada, o tempo total pode ser de atÃ© 6 segundos antes de falhar de vez.

âœ… Usos comuns sÃ­ncronos:
ComunicaÃ§Ã£o entre microserviÃ§os via REST
Acesso a banco de dados
Consumo de APIs externas
Leitura de arquivos remotos

ğŸ” 2. Em chamadas ASSÃNCRONAS
âœ… Sim, tambÃ©m Ã© Ãºtil â€” especialmente com mensageria.
Aqui, o processamento acontece de forma desacoplada, por exemplo:
ğŸ“© VocÃª publica uma mensagem numa fila (RabbitMQ, Kafka).
ğŸ› ï¸ Um consumidor processa essa mensagem â€” e se falhar, pode tentar novamente.

AssÃ­ncrono Ã© ideal para:
  Retries automÃ¡ticos com baixo impacto no usuÃ¡rio
  Desacoplamento e tolerÃ¢ncia a falhas mais robusta
  Reprocessamento de mensagens com Dead Letter Queues (DLQ)

ğŸ’¡ Dica final:
Em sÃ­ncrono, vocÃª â€œtravaâ€ a resposta esperando.
Em assÃ­ncrono, vocÃª deixa o sistema mais elÃ¡stico e resiliente â€” mas precisa lidar com reprocessamento e ordenaÃ§Ã£o.


Uasndo no Spring boot:

----

<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

Adicionar na main : @EnableRetry

----

@Service
public class ExternalService {

    private int attempt = 0;

    @Retryable(
        value = { RuntimeException.class },
        maxAttempts = 3,
        backoff = @Backoff(delay = 2000)
    )
    public String callService() {
        attempt++;
        System.out.println("Attempt #" + attempt);

        if (attempt < 3) {
            throw new RuntimeException("Service failed temporarily");
        }

        return "Service response OK";
    }

    @Recover
    public String recover(RuntimeException e) {
        System.out.println("Recovery method called after retries");
        return "Default fallback response";
    }
}

----

@Retryable: Indica que o mÃ©todo pode ser reexecutado automaticamente ao lanÃ§ar uma exceÃ§Ã£o especificada.
  value: tipos de exceÃ§Ãµes a capturar.
  maxAttempts: nÃºmero mÃ¡ximo de tentativas.
  backoff: tempo entre as tentativas (em milissegundos).
@Recover: mÃ©todo que serÃ¡ chamado apÃ³s todas as tentativas falharem.


13.3. Dead Letter Channel Pattern e Dead Letter Queue Pattern

Esses dois padrÃµes sÃ£o usados para tratar mensagens que falham ao ser processadas.
A diferenÃ§a principal estÃ¡ em como e onde elas sÃ£o redirecionadas quando falham.

 1. Dead Letter Queue Pattern (DLQ)
 Uma fila separada usada para armazenar mensagens que nÃ£o puderam ser processadas corretamente apÃ³s vÃ¡rias tentativas (ou por rejeiÃ§Ã£o explÃ­cita).

 âœ… Quando usar:
Quando vocÃª quer preservar a mensagem com erro para futura anÃ¡lise, correÃ§Ã£o ou reprocessamento.
Quando falhas nÃ£o sÃ£o recuperÃ¡veis no momento.

âœ… Exemplo (RabbitMQ):
Mensagem vai para a fila pedido.processamento.
O consumidor tenta processar e falha vÃ¡rias vezes.
A mensagem Ã© rejeitada ou expira.
A mensagem Ã© redirecionada automaticamente para a fila pedido.dlq.


2. Dead Letter Channel Pattern
Um canal lÃ³gico (nÃ£o necessariamente uma fila) para onde mensagens problemÃ¡ticas sÃ£o enviadas imediatamente apÃ³s falha.
Esse canal pode ser uma fila, um log, um serviÃ§o REST, etc.

âœ… Quando usar:
Quando vocÃª quer manter separaÃ§Ã£o clara entre mensagens vÃ¡lidas e com erro.
Quando vocÃª quer tomar uma aÃ§Ã£o personalizada (ex: logar, notificar, reencaminhar).
Ã‰ mais comum em integraÃ§Ãµes com Apache Camel, Spring Integration, ou Enterprise Integration Patterns.

âœ… ConclusÃ£o:
Use DLQ quando trabalha com filas de mensagens e precisa guardar mensagens com erro.
Use Dead Letter Channel quando estÃ¡ em um fluxo de integraÃ§Ã£o (como Spring Integration) e quer mais controle sobre o que fazer com a mensagem com erro.

13.6. Mensageria nÃ£o acaba por aqui

