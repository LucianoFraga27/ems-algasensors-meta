1.1 Boas Vindas
1.2 Alinhando expectativas
1.3 Por que arquitetura é importante?
1.4 O que é Arquitetura de software?
- Arquitetura de software inclui características, padrões e princípios do Sistema
- Requisitos Funcionais;
- Requisitos não funcionais;

Na arquitetura de software, os "ILities" (também chamados de "ilities" ou qualidades da arquitetura) são características não-funcionais que ajudam a avaliar e guiar decisões arquiteturais. Eles geralmente terminam em “-ilidade” (em português) ou “-ility” (em inglês), daí o apelido. São importantes porque definem como o sistema se comporta sob várias condições, em vez de o que o sistema faz.

Aqui estão os principais ILities da arquitetura de software:

🎯 1. Escalabilidade (Scalability)
Capacidade do sistema de lidar com aumento de carga (mais usuários, dados ou transações).

Escalabilidade vertical: melhorar hardware.

Escalabilidade horizontal: adicionar mais máquinas.

🔁 2. Manutenibilidade (Maintainability)
Facilidade de corrigir erros, adicionar funcionalidades ou atualizar tecnologias.

Influenciada por boas práticas, modularidade, e documentação clara.

🔄 3. Reusabilidade (Reusability)
Capacidade de reutilizar componentes ou módulos do sistema em outros contextos.

Favorece a produtividade e consistência.

⚙️ 4. Confiabilidade (Reliability)
Capacidade do sistema de funcionar corretamente por longos períodos sem falhas.

Inclui mecanismos de tolerância a falhas e redundância.

🕒 5. Disponibilidade (Availability)
Percentual de tempo que o sistema está operacional e acessível.

Está relacionada à confiabilidade, mas foca na disponibilidade percebida.

🔐 6. Segurança (Security)
Capacidade de proteger dados e funcionalidades contra acesso não autorizado.

Inclui autenticação, autorização, criptografia e auditoria.

📏 7. Usabilidade (Usability)
Facilidade de uso e aprendizado do sistema pelos usuários finais.

🚀 8. Desempenho (Performance)
Resposta do sistema sob carga: tempo de resposta, throughput, latência, etc.

🧪 9. Testabilidade (Testability)
Facilidade de testar os componentes do sistema de forma automatizada e confiável.

📦 10. Portabilidade (Portability)
Facilidade de mover o sistema entre ambientes (diferentes sistemas operacionais, servidores, etc).

♻️ 11. Flexibilidade / Extensibilidade (Flexibility / Extensibility)
Facilidade de adaptar o sistema a mudanças nos requisitos ou ambiente.

📚 12. Auditabilidade (Auditability)
Capacidade de rastrear atividades e eventos dentro do sistema, útil para conformidade e segurança.

1.5 As leis da arquitetura de software

Primeira Lei: Toda decisão arquitetural é um tradeoff (Toda escolha que você faz na arquitetura melhora alguns aspectos do sistema e piora outros)
Segunda Lei: Tudo depende do contexto. (O "porquê" é mais importante que o "como")
Terceira Lei: A arquitetura evolui.
Quarta Lei: Não otimize prematuramente.
Quinta Lei: Simplifique.

1.6 As responsabilidades e perfil do arquiteto de software

O arquiteto de software é o profissional responsável por definir e manter a estrutura técnica de sistemas, guiando decisões estratégicas sobre tecnologias, padrões, integrações, e atributos de qualidade
- Tomar decisões arquiteturais
- Analisar continuamente a arquitetura
- Acompanhar tendências e inovações
- Garantir a conformidade com decisões arquiteturais
- Ter experiência diversificada
- Bom líder
- Saber defender seus pontos arquiteturais

1.7 O que é arquitetura de solução?

-  é o projeto técnico de uma solução de TI completa — que integra sistemas, tecnologias, dados, infraestrutura e segurança — para atender a um objetivo de negócio específico.
O arquiteto de solução define:
- As tecnologias a serem usadas (Java + Angular + PostgreSQL)
- Como o sistema se comunica com a SEFAZ (web service, certificados A1/A3)
- Como será a segurança (OAuth2, Keycloak)
- Como será a integração com os ERPs da empresa
- Onde vai rodar (Kubernetes, AWS, on-premise, etc.)
- Como será o monitoramento e a escalabilidade

"A arquitetura de solução é onde a visão do negócio encontra a execução técnica"

1.8 O que design de software? 

é o projeto interno do sistema: como os módulos, classes, métodos, dados e fluxos interagem para cumprir os requisitos.

"O design de software é como você organiza os blocos dentro da arquitetura"

1.9 O que é design de código?

é o cuidado com a escrita do código-fonte para torná-lo claro, limpo, reutilizável, testável e fácil de manter.

"O design de código é o cuidado com os detalhes que fazem o código viver bem com outros desenvolvedores"

1.10 Estilos arquiteturais, padrões  e padrões de projeto

🏛️ 1. Estilos Arquiteturais (Architectural Styles)
🔹 São modelos amplos que descrevem como os componentes de um sistema se organizam e interagem entre si.
🔹 Não são soluções detalhadas, mas sim abstrações de alto nível.
Exemplos:
Monolítico	Toda a aplicação em um único bloco (backend, frontend, regras, etc.)
Camadas (Layered)	Organização em camadas (UI, lógica de negócio, persistência)
Cliente-Servidor	Comunicação entre cliente e servidor via rede
Microservices	Sistema dividido em pequenos serviços independentes
Event-Driven	Comunicação via eventos (publicação e assinatura)
Orientado a Serviços (SOA)	Exposição de funcionalidades como serviços reutilizáveis


🧩 2. Padrões Arquiteturais (Architectural Patterns)
🔸 São soluções reutilizáveis e comprovadas para problemas arquiteturais comuns.
🔸 Mais específicos do que estilos, mas ainda em alto nível.
MVC (Model-View-Controller)	Separa visualização, controle e modelo (usado em Web e Desktop)
MVVM (Model-View-ViewModel)	Similar ao MVC, comum em apps mobile/desktop modernos
CQRS (Command Query Responsibility Segregation)	Separação entre leitura (query) e escrita (command)
Event Sourcing	Persistência baseada em eventos ao invés de estados
Hexagonal (Ports & Adapters)	Foco na independência entre regras de negócio e tecnologias externas
Broker	Intermedia comunicação entre módulos (ex: sistemas distribuídos com mensageria)


🧠 3. Padrões de Projeto (Design Patterns)
🔹 São soluções detalhadas e reutilizáveis para problemas recorrentes no nível de código.
🔹 Organizam como classes, objetos e métodos se relacionam.
Exemplos (segundo o livro Design Patterns, GoF):
Criacionais	Singleton, Factory Method, Abstract Factory, Builder, Prototype
Estruturais	Adapter, Composite, Proxy, Decorator, Facade
Comportamentais	Strategy, Observer, Command, State, Chain of Responsibility

🧭 Resumo em níveis:
Alto nível	Estilo Arquitetural	Estrutura geral do sistema
Médio nível	Padrão Arquitetural	Solução específica para organização interna
Baixo nível	Padrão de Projeto	Estrutura do código e relação entre classes/objetos


1.11 Diagramas arquiteturais formais

“O diagrama deve ter um propósito e gerar valor.”

Diagramas são representações visuais da arquitetura de um sistema. Servem para comunicar, documentar e alinhar o entendimento técnico entre stakeholders (desenvolvedores, arquitetos, analistas, gestores etc.).

🔹 Diagramas Formais
São baseados em notações padronizadas, como UML ou C4, com semântica clara e reprodutível.

🧩 UML (Unified Modeling Language)
Diagrama de Classes	Mostra classes, atributos, métodos e seus relacionamentos (herança, composição, etc.)
Diagrama de Sequência	Mostra a interação entre componentes no tempo (fluxo de chamadas entre objetos ou serviços)

🧱 C4 Model (por Simon Brown)
O C4 divide a arquitetura em quatro níveis progressivos de detalhe:
C1	Context	Visão geral do sistema no seu ambiente (usuários, sistemas externos)
C2	Container	Mostra os “containers” (ex: app web, banco de dados, APIs, serviços)
C3	Component	Mostra os componentes internos de um container (ex: controllers, services, repositórios)
C4	Code	Zoom no código, com classes ou estruturas específicas

🔹 Diagramas Livres (Ad hoc)
São diagramas criados sem seguir uma notação formal. Úteis para brainstorms, apresentações rápidas ou comunicação não técnica.

📌 Ex: fluxos de usuário, arquitetura simplificada de um MVP, fluxos de dependência em sistemas legados.

✅ Guidelines para uma boa diagramação
Para garantir que os diagramas realmente comuniquem com clareza, siga boas práticas:
🎯 Propósito claro: cada diagrama deve responder uma pergunta (ex: “Como os sistemas se comunicam?”).
📌 Título e legenda: contextualize o diagrama.
🧭 Nível adequado: não misture níveis de abstração (ex: não coloque código e sistemas externos no mesmo diagrama).
📏 Linhas bem definidas: evite sobreposição ou conexões ambíguas.
🔠 Nomeclaturas padronizadas: use nomes coerentes com o código ou domínio de negócio.
🔄 Atualização frequente: diagramas desatualizados causam confusão.

🛠️ Ferramentas recomendadas
Ferramenta	Tipo	Destaques
StarUML	Formal	Suporte completo a UML e C4
Whimsical	Livre	Interface visual moderna, ideal para brainstorming
Miro	Livre	Colaboração em tempo real, ótimo para times remotos
Excalidraw	Livre	Estilo manuscrito, ideal para apresentações visuais leves
Draw.io (diagrams.net)	Misto	Grátis, suporta tanto diagramas formais quanto livres
Eraser.io	Livre	Visual limpo, excelente para wireframes e fluxos leves


1.12 Documentações arquiteturais: Design Docs e ADRs

A documentação arquitetural é essencial para registrar decisões técnicas, justificativas e impactos de longo prazo em sistemas de software. Ela ajuda times a manterem alinhamento, facilita onboarding e evita a repetição de discussões técnicas já resolvidas.

🧾 Design Docs (Design Documents)
🔹 Documento que descreve como será construída uma solução técnica antes da implementação.

✅ Objetivos:
Comunicar ideias técnicas com clareza.
Discutir abordagens e validar decisões.
Antecipar riscos, impactos e alternativas.
Servir como plano de referência para desenvolvimento.

📑 Estrutura comum de um Design Doc:
Título e autores	Nome do documento e responsáveis pela proposta
Contexto	Descrição do problema ou necessidade
Objetivos e escopo	O que será resolvido e o que está fora do escopo
Proposta técnica	Solução detalhada, tecnologias envolvidas, fluxos
Alternativas consideradas	Outras opções analisadas e por que foram descartadas
Riscos	Riscos técnicos, de negócio ou operacionais
Plano de implementação	Etapas, entregas e responsáveis
Anexos	Diagramas, links, POCs, benchmarks, etc.

📌 Quando usar:
Projetos médios/grandes.
Novas integrações ou mudanças arquiteturais relevantes.
Refatorações com impacto em múltiplos módulos.


🧠 ADRs (Architecture Decision Records) *um histórico
🔸 São registros curtos e objetivos de decisões arquiteturais importantes.

✅ Objetivos:
Documentar o que foi decidido, por que e quando.
Manter histórico técnico.
Facilitar o entendimento futuro das decisões.

📑 Estrutura típica de um ADR:
Seção	Descrição
Título	Nome da decisão
Status	Proposto, Aceito, Rejeitado, etc.
Contexto	Situação que levou à necessidade da decisão
Decisão	O que foi decidido
Consequências	Resultados esperados e efeitos colaterais

📌 Quando usar:
Toda vez que uma decisão técnica importante for tomada.
Substituição de tecnologias, padrões ou integrações.
Mudanças de regras ou diretrizes técnicas.

🛠️ Ferramentas úteis para manter Design Docs e ADRs:
Google Docs / Notion (colaborativo, fácil de versionar).
Markdown + Git (rastreável, versionado com código).
ADR Tools: adr-tools, adr-log.

1.13 O que é System Design e System Design Interview ?

System Design (ou projeto de sistemas) é o processo de planejar a arquitetura de um sistema de software complexo, considerando escalabilidade, desempenho, disponibilidade, segurança, manutenibilidade e custos.

É usado principalmente em sistemas distribuídos, aplicações web em larga escala, sistemas críticos, etc.

🔍 Envolve decisões como:
Componentes principais: serviços, bancos de dados, filas, cache, APIs etc.
Como se comunicam: REST, gRPC, eventos, mensageria...
Onde são implantados: cloud, containers, regiões geográficas...
Como escalam: balanceadores de carga, particionamento (sharding), replicação...
Como são tolerantes a falhas: retries, circuit breaker, redundância...
Monitoramento, segurança, backups, deploy contínuo, etc.

🧱 Exemplos de sistemas a projetar:
Um clone do Instagram
Um serviço de encurtador de URL
Uma API de feed em tempo real
Um sistema de filas como o Uber
Uma arquitetura de microserviços para um e-commerce

🧪 O que é a System Design Interview?
É um tipo de entrevista técnica muito comum em empresas de tecnologia, principalmente em grandes empresas (Big Techs), para cargos de engenheiro de software, tech lead e arquiteto.

📚 O que é avaliado na entrevista:
Critério	O que esperam
Clareza de pensamento	Entender o problema antes de sair desenhando
Capacidade de abstração	Quebrar o sistema em partes significativas
Decisões arquiteturais	Escolher tecnologias e justificar
Design escalável e resiliente	Planejar para crescimento e falhas
Comunicação	Conseguir explicar e colaborar com entrevistador

🧩 Estrutura típica da entrevista:
Recebe o problema – Ex: “Projete um serviço de mensagens como o WhatsApp”.
Faz perguntas de escopo – Quem são os usuários? Volume? Latência?
Define requisitos funcionais e não funcionais
Desenha um diagrama de alto nível
Detalha componentes – banco, cache, fila, storage, balanceamento...
Fala sobre escalabilidade, segurança, tradeoffs e gargalos
(Opcional): monitoração, deploy, logging, fallback...


“System Design é sobre resolver problemas do mundo real com software confiável, escalável e compreensível.”

📌 Dica para estudar:
Leia livros como “Designing Data-Intensive Applications” (Martin Kleppmann)

Pratique com sites como:
System Design Primer (GitHub) https://github.com/donnemartin/system-design-primer
ByteByteGo https://www.bytebytego.com/
Exercícios de system design no LeetCode Discuss https://leetcode.com/discuss/interview-question/system-design
Faça diagramas no papel ou ferramentas como Draw.io



2.1 – Conhecendo a Arquitetura Monolítica e os Monólitos Clássicos

🏛️ O que é uma Arquitetura Monolítica?
Uma arquitetura monolítica é aquela em que todo o sistema é desenvolvido, implantado e executado como uma única aplicação. Todas as funcionalidades (módulos, camadas, serviços) são acopladas em um único artefato binário.

🧱 Características do Monólito Clássico
Implantação única	Um único pacote (JAR, WAR, .EXE) que contém toda a aplicação
Compartilhamento de memória	Todos os módulos compartilham o mesmo espaço de execução
Tight coupling (alto acoplamento)	Mudanças em um módulo frequentemente afetam outros
Escalabilidade vertical	A escala é feita aumentando o poder da máquina onde o sistema roda
Facilidade inicial	Fácil de desenvolver e testar no início do projeto
Desafios de manutenção	Cresce rapidamente e se torna difícil de entender e evoluir

📌 Vantagens:
✅ Simples de desenvolver e implantar inicialmente
✅ Depuração e testes facilitados no começo
✅ Menor complexidade operacional (um único artefato para deploy)
✅ Integração simples entre componentes (chamada direta, sem rede)

⚠️ Desvantagens:
❌ Dificuldade de escalar partes específicas da aplicação
❌ Lenta inicialização e testes conforme cresce
❌ Deploys arriscados: qualquer mudança exige reimplantação total
❌ Baixa flexibilidade para adoção de novas tecnologias
❌ Pode virar um “Big Ball of Mud” (bola de lama) – difícil de manter e entender


📖 Termo relacionado: Monolito Modulare
É possível ter um monólito organizado, com boa separação de responsabilidades por meio de módulos internos bem definidos, o que ajuda a manter a clareza e a evolutividade.
➡️ Isso é diferente de um monolito bagunçado, sem separação de responsabilidades.


🧱 Tipos de Monólitos
# Monólito Ruim (ou Big Ball of Mud)
Sem organização clara.
Baixa separação de responsabilidades.
Classes gigantes e interdependentes.
Alta chance de bugs quando qualquer parte muda.
Difícil de testar e evoluir.
⚠️ Exemplo típico de código legado difícil de manter.

# Monólito Modular
Organizado internamente em módulos ou camadas bem definidas.
Utiliza princípios de design como DDD, camadas (controller/service/repository) ou hexagonal.
Embora esteja num único artefato, cada módulo tem limites claros de responsabilidade.
Mais fácil de entender, manter e eventualmente migrar para microserviços, se necessário.
✅ Boa prática em muitos projetos menores e médios.

# Monólito Distribuído (ou "pseudosserviços")
Aparentemente dividido em pacotes/layers/comunicação via REST ou mensageria dentro da mesma aplicação.
Tenta imitar microserviços sem realmente separar em processos independentes.
Pode introduzir complexidade desnecessária sem os benefícios reais da arquitetura distribuída.
⚠️ Muito comum quando se tenta "forçar" microserviços dentro de um monólito.

# Monólito com Frontend e Backend Acoplados
Interface do usuário e backend estão no mesmo repositório, servidor e ciclo de deploy.
Pode ser simples de manter no início, mas traz desafios para times separados e evolução do frontend.
Muito comum em sistemas antigos com JSP, JSF, PHP puro, ASP.NET clássico, etc.

# Monólito com Gateway Modular
Um estilo onde o monólito é estruturado com módulos de domínio desacoplados, mas controlado por um gateway central que orquestra as chamadas.
Ajuda a manter a coesão e controlar melhor a responsabilidade dos domínios.
Pode ser evoluído facilmente para microserviços.

2.2. Organização de equipes e a Lei de Conway

🧠 O que diz a Lei de Conway?
"As organizações que projetam sistemas são limitadas a produzir designs que são cópias da estrutura de comunicação dessas organizações."
— Melvin Conway, 1967
Ou seja:
A forma como sua equipe se comunica e se organiza influencia diretamente na estrutura do software que ela constrói.

📦 Exemplificando na prática:
Se uma organização tem 3 equipes isoladas, o sistema provavelmente terá 3 módulos principais mal integrados.
Se o time de frontend e backend mal se comunicam, o sistema resultará em interfaces engessadas e APIs mal projetadas.
Se há departamentos burocráticos separados, o software será acoplado e inflexível, refletindo essa lentidão.

🏗️ Implicações arquiteturais
A arquitetura de software deve espelhar conscientemente a estrutura das equipes — ou seja:
Arquitetura orientada a times: cada equipe é responsável por um módulo ou domínio de negócio.
Facilita ownership (propriedade de código) e autonomia.
Reduz dependências e gargalos de comunicação.
Cria interfaces mais coesas e limites de contexto mais claros (ex: DDD e Bounded Contexts).

🧩 Lei de Conway vs. Inversão de Conway (Conway's Law Inverted)
Lei de Conway (tradicional): estrutura da equipe influencia o design do sistema.
Inversão da Lei de Conway (ou Arquitetura Direcionando Times):
Você propositalmente estrutura a equipe de acordo com a arquitetura desejada.
"Se você quer uma arquitetura modular e escalável, estruture seus times modular e escalavelmente."

👥 Tipos de times (modelo Team Topologies)
Stream-aligned	Foco em fluxo de valor (produto ou domínio)
Platform	Suporte aos demais times com infraestrutura
Enabling	Apoia outros times em conhecimento técnico
Complicated Subsystem	Especialistas em lógica de alto nível técnico

A adoção de arquiteturas como microserviços só é sustentável com times que seguem esse tipo de divisão inteligente.

🧭 Dica para arquitetos:
Antes de desenhar seu sistema, observe como os times estão organizados.
Melhor ainda: ajude a organizar os times para refletir a arquitetura desejada.


2.3. Arquitetura monolítica não é legado!

Mito: “Se é monolito, é legado, velho ou ruim.”
Verdade: "Monólito ≠ legado.
Monólito é apenas um estilo arquitetural. Ele pode ser moderno, bem projetado, performático e escalável."

✅ Quando o monolito é uma boa escolha?
Projetos pequenos ou médios, com uma equipe menor.
Quando a velocidade de entrega é importante.
Para evitar complexidade prematura dos microserviços.
Quando se deseja manter a simplicidade de deploy e monitoramento.

“Start monolithic, break apart when necessário”
— Princípio comum em arquiteturas evolutivas.

⚠️ Por que microserviços não são solução mágica?
Microserviços exigem maturidade organizacional (infraestrutura, devops, observabilidade, times dedicados).
Aumentam a complexidade de deploy, versionamento e comunicação.
Aplicações simples se tornam overengineered se forem quebradas em microsserviços sem necessidade.

❗ Ser monolítico não é um problema.
O problema é ser mal estruturado, confuso e difícil de manter — isso sim é legado.


2.4 Pesadelo dos monólitos: quando tudo sai do controle ( Monolithic Hell)

“O problema não é o monólito em si, e sim quando ele se torna um monolito monstro, inchado, acoplado e impossível de mudar.”

🧨 O que é o "Monolithic Hell"?
É quando o monólito foge do controle, causando dor e paralisia na evolução do sistema.

⚠️ Sinais claros do inferno monolítico:
😱 Deploys demorados e arriscados	Um pequeno ajuste exige subir o sistema inteiro, com alto risco de quebra.
🔄 Tudo depende de tudo	Módulos fortemente acoplados, difíceis de testar ou modificar isoladamente.
🧩 Código duplicado e confuso	Falta de coesão, com funcionalidades repetidas e mal organizadas.
🛠️ Manutenção se torna terror	Alterar uma regra de negócio pode quebrar funcionalidades em áreas não relacionadas.
🧱 Camadas mal definidas	Front, serviço e repositórios misturados; regras de negócio espalhadas.
🐌 Time se move devagar	O sistema é tão complexo que até tarefas simples levam semanas.
🤝 Falta de ownership	Todos mexem em tudo; ninguém é dono de nada.
😵‍💫 Dificuldade de escalar times	Várias pessoas trabalhando no mesmo módulo geram conflitos constantes.

💣 Causas comuns:
Falta de modularização interna.
Desorganização de camadas e responsabilidades.
Acoplamento entre funcionalidades não relacionadas.
Crescimento desgovernado do sistema, sem refatorações.
Negligência com práticas de design e arquitetura.


🚑 Como fugir do pesadelo:
🧹 Refatorar e modularizar	Organiza responsabilidades e melhora o entendimento do código.
🧪 Investir em testes automatizados	Reduz medo de mudanças e regressões.
🧭 Adotar arquitetura em camadas ou DDD	Melhora separação de responsabilidades.
🧱 Criar Bounded Contexts	Isola domínios de negócio que crescem separadamente.
🧪 Dividir o deploy por áreas de negócio	Rumo a uma arquitetura distribuída, como microsserviços ou módulos independentes.

💡 Conclusão:
O monólito pode ser saudável, mas sem disciplina arquitetural, ele cresce como uma bola de neve desgovernada.
Quando chega nesse ponto, o custo de manter supera o custo de evoluir para algo mais modular.

2.5 Conhecendo a arquitetura de microsserviços

A arquitetura de microsserviços é um estilo onde o sistema é dividido em serviços pequenos, independentes e autônomos, que comunicam entre si por meio de redes (geralmente HTTP/REST, gRPC, mensageria etc).

Cada microsserviço é focado em uma única responsabilidade de negócio.

🎯 Objetivo principal
Permitir que cada parte da aplicação evolua, escale e seja implantada de forma independente.

🧱 Características principais
🎯 Foco em domínio único	Cada microsserviço cuida de uma parte específica do negócio.
🛠️ Deploys independentes	Um serviço pode ser atualizado sem afetar os outros.
🌐 Comunicação via rede	REST, gRPC, mensageria (RabbitMQ, Kafka etc.).
💾 Banco de dados independente	Cada serviço gerencia seu próprio banco (desacoplamento de dados).
👥 Times independentes	Time pode ser dono de um ou mais microsserviços.
🧪 Resiliência e tolerância a falhas	Cada serviço lida com suas falhas isoladamente.


🧪 Vantagens
📦 Escalabilidade individual por serviço.
🚀 Agilidade no desenvolvimento e deploy.
🔄 Facilidade de manter e evoluir partes específicas.
🔍 Observabilidade clara por serviço (logs, métricas, tracing).
🧭 Adoção mais fácil de DDD e Bounded Contexts.

⚠️ Desvantagens / Desafios
📡 Complexidade de comunicação	Redes são mais frágeis que chamadas locais.
🔀 Gerenciamento de transações distribuídas	Evitar commit em múltiplos bancos é difícil.
🎯 Governança e versionamento de APIs	Serviços mudam e precisam manter compatibilidade.
📦 Infraestrutura robusta exigida	Precisa de CI/CD, containers (Docker), orquestração (Kubernetes), etc.
🔍 Observabilidade e rastreamento	Necessário investir em logs centralizados, tracing, dashboards etc.

✅ Quando vale a pena usar?
Projeto com grande escala ou múltiplos domínios complexos.
Organização com múltiplos times trabalhando de forma paralela.
Necessidade de alta disponibilidade e escalabilidade granular.
Já existe maturidade em infraestrutura (DevOps, automação, observabilidade).


2.6 Microsserviços possuem seus próprios estados

🎯 Princípio fundamental dos microsserviços:
Cada microsserviço é responsável por seu próprio estado e dados.

Isso significa que cada serviço possui e controla sua própria base de dados, sem compartilhamento direto com outros serviços.

🧱 Por que isso é importante?
🔗 Desacoplamento	Serviços não dependem de bancos de dados externos.
🚀 Deploys independentes	Você pode alterar um banco sem afetar outros serviços.
📊 Escalabilidade separada	Cada serviço pode otimizar sua base de dados conforme a necessidade.
🔒 Isolamento de falhas	Se um banco falhar, os demais continuam funcionando.

⚠️ Antipadrão a evitar: Banco de dados compartilhado
Se vários microsserviços acessam o mesmo banco de dados, você tem um banco monolítico, não microsserviços de verdade.

💬 Como os serviços se comunicam então?
A comunicação entre serviços acontece via APIs ou mensageria, e nunca diretamente via banco de dados.

Exemplo:
OrderService precisa de dados do UserService → faz uma chamada HTTP ou envia um evento.
Nunca faz um SELECT direto na base do UserService.

📦 Transações distribuídas? Cuidado!
Evite dependência de transações ACID entre serviços. Em vez disso, use:
✅ Eventual consistency (consistência eventual).
✅ Sagas para orquestrar múltiplas etapas entre serviços.
✅ Eventos assíncronos para manter os dados atualizados entre domínios.

🧠 Cada serviço, seu próprio modelo
Além do banco, cada microsserviço pode ter seu próprio modelo de dados (linguagem, formato, estrutura), ideal para aquele domínio específico.

Microsserviço deve..
Ter sua própria base de dados:	Garante independência e escalabilidade.
Controlar seu estado interno:	Evita dependência cruzada.
Expor dados via API ou eventos:	Mantém contratos bem definidos.

2.7 Microsserviços se comunicam via rede em uma arquitetura distribuída

🌐 Visão geral
Na arquitetura de microsserviços, cada serviço é executado de forma independente e se comunica com os demais através da rede, formando uma arquitetura distribuída.

🔗 O que é uma arquitetura distribuída?
É uma arquitetura onde múltiplos serviços autônomos estão espalhados em diferentes ambientes (containers, VMs, servidores) e interagem entre si via rede.

Cada microsserviço pode estar:
- Em máquinas diferentes
- Em data centers diferentes
- Em nós diferentes de um cluster Kubernetes

📡 Formas de comunicação entre microsserviços
Tipo	Descrição	Exemplo
🔁 Síncrona (sincrônica)	A chamada espera a resposta.	REST (HTTP), gRPC
🔁 Assíncrona	A chamada é enviada e processada depois.	Mensageria (RabbitMQ, Kafka)

📶 Protocolos comuns
HTTP/HTTPS (REST) → mais comum, simples e legível
gRPC → mais rápido, binário, ideal para alta performance
AMQP/Kafka → comunicação assíncrona por eventos


🧩 Implicações da comunicação via rede
Implicação	Explicação
❌ A rede falha	Comunicação pode cair, deve haver retry e fallback
⏱️ Latência	Chamadas são mais lentas que chamadas locais
🔒 Segurança	Deve-se usar autenticação, criptografia e controle de acesso
🕵️‍♂️ Observabilidade	Logs, tracing e métricas são fundamentais para entender o tráfego entre serviços
📐 Versionamento de APIs	Mudanças em contratos afetam outros serviços

🧠 Boas práticas
✅ Usar circuit breakers (como Resilience4j, Hystrix)
✅ Implementar timeout e retries
✅ Preferir comunicação assíncrona quando possível (eventos)
✅ Usar APIs bem definidas e versionadas
✅ Monitorar com logs centralizados, tracing distribuído, dashboards


2.8 Microsserviços são autônomos e independentes

Em uma arquitetura de microsserviços, cada serviço é uma unidade independente, que pode ser desenvolvido, testado, implantado, escalado e mantido separadamente dos demais.

Autonomia	| Independência
Cada serviço toma decisões sozinho	| Pode ser executado sem precisar dos outros
Tem sua lógica de negócio isolada	| É desenvolvido e versionado separadamente
Gerencia seu próprio banco de dados | Pode ser implantado de forma individual
Expõe sua própria API	| Pode ser escalado conforme sua demanda

📦 Exemplo prático
Imagine um sistema de e-commerce com três microsserviços:
UserService – gerencia usuários
OrderService – gerencia pedidos
ProductService – gerencia produtos

Cada um:

Tem sua base de dados própria
Possui repositório de código separado
Pode ser implantado de forma independente
Se comunica com os outros via APIs ou eventos

⚙️ Benefícios dessa independência
Benefício	Descrição
🚀 Deploys independentes	Você atualiza um serviço sem afetar os outros
🧪 Testabilidade	Pode testar cada serviço isoladamente
🔄 Ciclo de vida separado	Cada equipe pode manter seu serviço com autonomia
📈 Escalabilidade sob demanda	Escala somente o serviço que precisa
🔁 Resiliência	Uma falha em um serviço não derruba o sistema todo

⚠️ Desafios a considerar
Desafio	Abordagem recomendada
🤝 Integração entre serviços	APIs bem definidas + eventos
📉 Dependência indesejada	Evitar chamadas cruzadas em excesso
🔍 Observabilidade distribuída	Usar tracing, logs centralizados e métricas
🚧 Gerência de versões de APIs	Versionamento e contratos bem definidos

📘 Resumo
Conceito	Descrição
Autonomia	Cada microsserviço é dono de seu domínio
Independência	Pode funcionar, escalar e evoluir sozinho
Boas práticas	APIs estáveis, banco próprio, deploy isolado
Desafios	Integração, observabilidade e versionamento

2.9 Microsserviços são componentes pequenos e coesos

Pequeno -> fácil de entender e modificar
Grande -> útil e resolve um problema completo
Escopo coeso e bem definido

🧩 O que isso significa?
Em uma arquitetura de microsserviços, cada serviço é projetado para ser:
Pequeno: focado em uma única responsabilidade de negócio.
Coeso: suas partes internas estão altamente relacionadas e trabalham juntas por um único propósito.

🎯 Princípio de coesão
Um serviço coeso faz uma única coisa bem feita. Toda sua lógica gira em torno de um único domínio ou contexto.

📌 Exemplo:
Um PaymentService só lida com pagamentos – ele não deve validar login, cadastrar produtos ou enviar e-mails.

⚠️ Riscos se não forem pequenos e coesos
Serviços inchados viram “mini-monólitos”.
Baixa coesão gera forte acoplamento entre serviços.
Dificuldade de escalar individualmente.
Complexidade na manutenção aumenta com o tempo.


2.10 Microsserviços possuem flexibilidade tecnológica

🧪 Definição
Uma das principais vantagens da arquitetura de microsserviços é que cada serviço pode ser desenvolvido usando a tecnologia mais apropriada para ele, de forma independente dos demais.

🔧 O que é essa flexibilidade?
Significa que linguagens de programação, bancos de dados, frameworks, bibliotecas e até mesmo estratégias de deploy podem variar entre os microsserviços.

🧠 Por que isso é possível?
Porque os microsserviços são:
Isolados (rodam em seus próprios processos)
Autônomos (não compartilham código ou banco)
Comunicam-se via rede (APIs REST, gRPC, eventos etc.)

Em um sistema completo:

Serviço	Tecnologia usada
UserService	Java + Spring Boot + PostgreSQL
AuthService	Node.js + JWT + Redis
PaymentService	Python + Flask + MongoDB
NotificationService	Go + RabbitMQ

✅ Vantagens da flexibilidade tecnológica
Vantagem	Descrição
🎯 Ferramenta certa para o problema certo	Usa a tecnologia ideal para cada cenário
🧪 Experimentação segura	Testa novas ferramentas sem afetar o todo
📚 Aproveitamento de especialidades da equipe	Cada time pode usar a stack com que já é familiar
🔄 Evolução tecnológica gradual	Pode modernizar um serviço sem reescrever todo o sistema

⚠️ Desafios e cuidados
Desafio	Estratégia para lidar
🤝 Integração entre linguagens	Usar padrões de API bem definidos (REST, gRPC, eventos)
📦 Complexidade no deploy	Automatizar com CI/CD e containers
👩‍💻 Curva de aprendizado múltipla	Definir guidelines e boas práticas para stacks diversas
📊 Observabilidade e monitoramento	Padronizar logs, métricas e tracing, mesmo em stacks diferentes

2.11 Microsserviços são implantados de forma independente 

🚀 O que significa?
Na arquitetura de microsserviços, cada serviço pode ser desenvolvido, testado e implantado de forma autônoma, sem precisar sincronizar o deploy com os demais.
Ou seja:
Um microsserviço pode ser atualizado e colocado em produção sem interferir no funcionamento dos outros.

2.12 Microsserviços são resilientes e tolerantes a falhas

Resiliência é a capacidade de um sistema continuar funcionando mesmo quando partes dele falham.

Na arquitetura de microsserviços, isso significa que, mesmo que um serviço esteja temporariamente indisponível ou com problemas, o restante do sistema deve continuar operando de forma controlada.

⚙️ Por que isso é importante?
Porque microsserviços são:
Distribuídos, ou seja, rodam em máquinas diferentes.
Conectados via rede, que pode ser lenta ou falhar.
Implantados independentemente, logo, podem estar em versões diferentes

🧠 Conceitos-chave de tolerância a falhas
Conceito	Descrição
🔁 Retry (tentativa novamente)	Tenta repetir uma requisição quando há falha temporária.
⛔ Timeouts	Define tempo limite para respostas, evitando que um serviço fique esperando indefinidamente.
💥 Circuit Breaker	Interrompe chamadas para serviços instáveis, evitando efeito cascata.
🧊 Fallback	Define uma resposta alternativa quando o serviço de origem está indisponível.
🛑 Bulkhead (Compartimentos)	Isola falhas para que não se propaguem a outros serviços.
📈 Monitoramento e observabilidade	Detecta e reage rapidamente a falhas e degradações.


2.13 Microsserviços são escaláveis de forma independente

Em uma arquitetura de microsserviços, cada serviço pode ser escalado separadamente, conforme suas necessidades de carga e uso.

Ou seja, você pode aumentar a capacidade (horizontal ou vertical) apenas dos serviços mais demandados, sem precisar escalar todo o sistema.

🧠 Por que isso importa?
Em sistemas monolíticos, para escalar um módulo específico (ex: processamento de pagamento), você precisa escalar toda a aplicação, mesmo que os outros módulos estejam ociosos.

Com microsserviços:
O PagamentoService pode ter 10 instâncias.
O RelatorioService, que quase não é acessado, pode ter apenas 1.

👉 Isso torna o uso de recursos mais eficiente e econômico.

⚙️ Tipos de escalabilidade
Tipo	Descrição
🔄 Escalabilidade horizontal	Adicionar mais instâncias do serviço
⬆️ Escalabilidade vertical	Aumentar CPU, memória ou recursos da instância
🎯 Escalabilidade seletiva	Escalar somente os serviços necessários, com base na demanda


# 3.1. Práticas e tecnologias facilitadoras

👥 Times Autônomos
Times autônomos são equipes multidisciplinares e auto-organizadas, com autonomia para tomar decisões técnicas e de produto. Eles são responsáveis pelo ciclo completo do serviço: concepção, desenvolvimento, testes, implantação, monitoramento e manutenção.

Características:
Multifuncionais: desenvolvedores, testers, DevOps, product owner.
Autonomia: tomam decisões sem precisar de constantes aprovações externas.
Accountability: são responsáveis pelo sucesso e qualidade do serviço que operam.
Ciclo completo: do código à produção ("you build it, you run it").

🧱 Estrutura Descentralizada
A estrutura descentralizada rompe com o modelo hierárquico tradicional. Em vez de uma cadeia de decisões única e centralizada:

Cada time é dono de seus próprios serviços ou domínios.
A organização cresce com base em times pequenos e independentes.
A coordenação é feita por alinhamento de objetivos (visão de produto, OKRs, padrões de arquitetura), não por comando e controle.
Essa abordagem facilita a escalabilidade organizacional e se alinha com arquiteturas distribuídas, como microsserviços.


Service Per Team Pattern

É um padrão onde cada time é responsável por um ou mais serviços (geralmente um único serviço), assumindo total responsabilidade pelo seu ciclo de vida completo: desenvolvimento, testes, implantação, operação e suporte.

📦 Características principais
Característica	Descrição
Domínio claro	Cada serviço pertence a um domínio de negócio bem definido.
Responsabilidade total	O time cuida do código, infraestrutura, monitoramento e correções.
Autonomia	O time tem liberdade para tomar decisões técnicas (dentro de padrões globais).
Desacoplamento organizacional	Reduz dependência entre equipes, incentivando a escalabilidade organizacional.

🎯 Objetivo
Aumentar a agilidade na entrega de software.
Permitir que times evoluam seus serviços de forma independente.
Estimular a especialização por domínio (ex: Pagamentos, Estoque, Autenticação).

# 3.3. Manobra inversa da Lei de Conway

Ao invés de time separados por especialidade, teremos times funcionais que consigam testar cada etapa do software (back,front,etc).

# 3.4. Times pequenos e o conceito de Two Pizza Team

Qual tamanho de um time para cuidar de um microserviços? O time deve poder ser alimentado por 2 pizzas. kkkk ideia da amazon

# 3.5. Cultura de ownership e a mentalidade de produtos (e não projetos)

"you build it, you run it"

Microservices são produtos e não projetos, deve ser mantido e continuado pela mesma equipe (responsabilidade pelo ciclo de vida do serviço). Cultura de Ownership 

Ownership (ou "sentimento de dono") é quando os times têm autonomia, responsabilidade e autoridade sobre os sistemas que desenvolvem e mantêm.

Eles não apenas entregam funcionalidades, mas se preocupam com qualidade, performance, confiabilidade, escalabilidade e evolução contínua do produto.

# 3.6. Team Topologies e os times em organizações distribuídas

Como estruturar os times de forma eficiente? 

Team Topologies é um modelo moderno de organização de times de software, proposto por Matthew Skelton e Manuel Pais, que busca alinhar estrutura de times à arquitetura do sistema, promovendo fluxo de entrega contínua, autonomia e escalabilidade.

Tipos de times: 

🧩 Stream-aligned team: Foco em um fluxo de valor contínuo: linha de produto, jornada do cliente ou domínio de negócio. Ex: time responsável pelo app mobile do cliente final.
🛠 Enabling team:	Ajuda outros times a adotarem práticas, ferramentas ou tecnologias. Ex: time de DevOps, engenharia de dados, boas práticas de testes.
🧱 Complicated subsystem team:	Especialistas que cuidam de partes muito complexas do sistema. Ex: time de otimização de algoritmos, engenharia de machine learning.
🔧 Platform team:	Cria e mantém uma plataforma interna para facilitar o trabalho dos outros times (ciência da plataforma). Ex: time de CI/CD, observabilidade, autenticação.

Modos de colaboração:
🤝 Colaboração:	Quando há incerteza, experimentação ou inovação. Curto prazo.	Time de produto trabalhando junto com time de dados para descobrir soluções.
📦 Como um serviço:	Para reutilização clara e padronizada.	Plataforma de deploy self-service oferecida pelo time de plataforma.
🧭 Facilitação:	Quando um time ajuda outro a adquirir capacidades.	Time de DevOps ajudando times de produto a adotar pipelines de CI/CD.

Organizações Distribuídas: por que isso importa?
Em times distribuídos:

A colaboração é mais difícil (fuso horário, linguagem, cultura);
É essencial reduzir o acoplamento entre equipes;
Times precisam de autonomia real para escalar.
Team Topologies fornece um modelo para isso, permitindo que cada time se torne dono de uma parte do sistema com interações bem definidas e intencionais.

3.7. Cultura DevOps

A Cultura DevOps vai muito além de ferramentas como Docker, Jenkins ou Kubernetes. Ela representa uma mudança profunda na forma como desenvolvimento e operações trabalham juntos para entregar software com mais agilidade, segurança, qualidade e confiabilidade.

Cultura:

- Quebrar silos entre desenvolvimento (Dev) e operações (Ops);
- Aumentar a frequência de entrega (deploys mais rápidos e frequentes);
- Reduzir falhas em produção com práticas de automação e monitoramento;
- Criar um ciclo de feedback contínuo entre todos os envolvidos no ciclo de vida do software.

Fundamentos:

🔄 Ciclo Contínuo:	Integração contínua (CI), entrega contínua (CD), monitoramento contínuo.
👥 Colaboração:	Desenvolvedores, Ops, QA e outras áreas atuam juntos, desde o início.
🛠 Automação:	Infraestrutura como código, pipelines CI/CD, testes automatizados.
📊 Medição:	Tudo é mensurado: tempo de deploy, falhas, tempo médio de recuperação.
🔐 Segurança embutida:	DevSecOps: segurança é parte do ciclo de desenvolvimento desde o início.

Pilares:

1. Integração Contínua (CI): Automatiza a compilação, testes e validação do código a cada push.
2. Entrega Contínua (CD): Permite deploys frequentes e confiáveis, com aprovação mínima.
3. Infraestrutura como Código (IaC): Provisionamento e configuração de ambientes via código (Ex: Terraform, Ansible).
4. Monitoramento Contínuo: Observabilidade de logs, métricas e traces (Ex: Prometheus, Grafana, ELK Stack).
5. Feedback Contínuo: Coleta e análise de métricas para decisões rápidas (Ex: incidentes, erros, feedback de clientes).

"DevOps não é uma equipe nem um cargo, é uma cultura.
É sobre pessoas, processos e ferramentas — nessa ordem."

3.8. Testes automatizados e Pirâmide de Testes
*não é boa prática, é essencial"
Os testes automatizados são parte essencial de uma arquitetura moderna, principalmente quando falamos em DevOps, entrega contínua (CI/CD) e qualidade constante em ambientes distribuídos.

- Reduz o retrabalho e o tempo de validação manual.
- Permite releases frequentes com mais segurança.
- Detecta regressões rapidamente.
- Dá confiança para refatorar código.

🔺 Pirâmide de Testes (Test Pyramid)

A pirâmide de testes é um conceito criado por Mike Cohn, que orienta como distribuir os tipos de testes para garantir qualidade de forma eficiente e rápida.

       [ UI / End-to-End Tests ]
                 (5-10%)
                🔼
        [ Testes de Integração ]
              (15-20%)
                🔼
         [ Testes de Contrato ]
               (10-15%)
                🔼
        [ Testes Unitários ]
               (70-80%)


1. 🧱 Testes Unitários (Base)
- Testam unidades isoladas de código (funções, métodos, classes).
- Executam rapidamente.
- São baratos de escrever e manter.
- Exemplos: JUnit, NUnit, Jest, Mocha.
🔹 Regra de ouro: Devem representar 70% a 80% dos testes automatizados.

2. Testes de contratos
- Eles ficam entre os testes unitários e os testes de integração, pois validam a comunicação entre partes do sistema sem precisar de todo o ambiente rodando.
- Consumer-driven contracts: O consumidor define o que espera da API.
- Provider contracts: O provedor valida se cumpre o que prometeu.

3. 🔗 Testes de Integração (Meio da pirâmide)
- Testam múltiplos módulos juntos (ex: integração com banco, serviços externos, etc).
- Validam se os componentes funcionam em conjunto.
- Exemplos: Testes com banco em memória (H2), REST Assured, Postman.
🔹 Recomendado: 15% a 20% dos testes.
- Test Containers

4. 🎭 Testes End-to-End (Topo da pirâmide)
- Simulam o comportamento do usuário final.
- São mais lentos, caros de manter e suscetíveis a falhas externas.
- Exemplos: Selenium, Cypress, Playwright.
🔹 Ideal: 5% a 10%, apenas para os fluxos mais críticos.

5. Testes de Carga
- Verificar se os microsserviços aguentam os acessos simultaneos e etc..
- Grafana K6 etc

3.9. Containers e orquestração

Service Instance per container pattern

📦 Containers: o que são?
Um container é uma unidade leve, portátil e isolada que empacota: o código da aplicação, suas dependências (bibliotecas, binários), e seu ambiente de execução.

O container garante que a aplicação rode de forma previsível em qualquer lugar: local, nuvem, CI/CD etc.

📐 Por que containers são ideais para microsserviços?

- Cada microsserviço pode ser empacotado em seu próprio container.
- Isolamento garante que falhas em um serviço não afetam os outros.
- Fáceis de replicar, escalar e versionar.

⚙️ Orquestração: como gerenciar múltiplos containers?
Com dezenas ou centenas de microsserviços, é necessário automatizar:
- Deploy
- Escalonamento (auto-scale)
- Atualizações sem downtime (rolling updates)
- Health checks
- Resiliência
- Balanceamento de carga

É aí que entra a orquestração.

🤖 Ferramentas de Orquestração:
- Kubernetes (o padrão da indústria)
- Docker Swarm (mais simples)
- Amazon ECS, Google GKE, Azure AKS (Kubernetes gerenciado)

🧠 Como o Kubernetes ajuda?
Organiza os containers em Pods e os distribui em nós (nodes).

Lida com:
- Escalabilidade automática
- Recuperação de falhas
- Rede entre serviços
- Secrets e configs
- CI/CD pipelines integrados

🧩 Containers + Orquestração = Chave para microsserviços
A combinação permite:
- Entrega contínua e rápida (DevOps)
- Deploys independentes por time
- Infraestrutura como código
- Eficiência no uso de recursos

Resumo:
Container:	Empacota o microsserviço com tudo que ele precisa
Orquestrador:	Gerencia, escala e mantém o ambiente confiável e saudável

3.10. Cloud Computing

📌 O que é Cloud Computing?
É o fornecimento de recursos computacionais sob demanda (como servidores, banco de dados, armazenamento, rede, software) pela internet, com pagamento conforme o uso.

💡 Por que Cloud é essencial para microsserviços?
Microsserviços demandam:

- Escalabilidade
- Isolamento
- Alta disponibilidade
- Deploys frequentes
- Ambientes independentes

A nuvem oferece todos esses recursos com elasticidade e automação, permitindo que as equipes se concentrem mais em entregar valor do que em gerenciar infraestrutura.


🧱 Modelos de serviço na Cloud
Modelo	Descrição	Exemplo
IaaS (Infraestrutura como Serviço)	Você gerencia tudo, exceto os servidores físicos.	Amazon EC2, Azure VM
PaaS (Plataforma como Serviço)	Você foca no código, a plataforma gerencia o ambiente.	Heroku, Google App Engine
SaaS (Software como Serviço)	Você apenas usa o software via web.	Gmail, Salesforce

🏗️ Modelos de implantação
Tipo	Descrição
Nuvem Pública	Recursos compartilhados entre várias empresas (AWS, Azure, GCP).
Nuvem Privada	Infraestrutura dedicada para uma organização.
Nuvem Híbrida	Combinação de pública + privada.
Multi-Cloud	Uso de múltiplos provedores de nuvem.

🧠 Benefícios da Cloud para microsserviços
Elasticidade: escale serviços conforme a demanda.
Resiliência: zonas de disponibilidade, failover automático.
Custo sob demanda: pague pelo que usa.
Automação: deploys, backups, observabilidade.
Agilidade: criação rápida de ambientes de teste e produção.

☁️ Principais provedores de Cloud
AWS (Amazon Web Services)
Microsoft Azure
Google Cloud Platform (GCP)
Oracle Cloud, IBM Cloud, etc.

✅ Conclusão
Cloud computing é a base moderna para rodar aplicações em microsserviços, pois permite:
- Automatizar o ciclo de vida da aplicação,
- Escalar rapidamente,
- Isolar serviços,
- E reduzir custos operacionais.

3.11. Microservices Patterns: não reinvente a roda

Livros:
Microservices Patterns (Chris Richardson)
Microservices.io (Chris Richardson)
Enterprise Integration Patterns - EIP
Enterprise Integration Patterns - EIP (Gregor Hohpe e Bobby Woolf)
Patterns of Distributed Systems (Unmesh Joshi)
Catalog of Patterns of Distributed Systems (Unmesh Joshi)
Microsoft Azure Architecture Center - Cloud Design Patterns
AWS Prescriptive Guidance
The Ultimate Guide to Event-Driven Architecture Patterns (Solace)
Event Streaming Patterns (Confluent)

Ao projetar uma arquitetura baseada em microsserviços, não é necessário (nem recomendado) criar tudo do zero. 
Existem padrões amplamente adotados que ajudam a resolver desafios comuns de forma segura, escalável e já testada na prática.

🧱 O que são Microservices Patterns?
São soluções reutilizáveis para problemas recorrentes em arquiteturas de microsserviços, como:

Comunicação entre serviços
Consistência de dados
Autenticação e autorização
Deploys independentes
Tolerância a falhas
Monitoramento e observabilidade

🧰 Principais padrões que você deve conhecer:

🔄 API Gateway
- Ponto único de entrada para chamadas externas.
- Centraliza autenticação, roteamento, throttling, etc.

🎛 Service Discovery
- Permite que microsserviços encontrem uns aos outros dinamicamente.
- Exemplos: Eureka, Consul, Kubernetes DNS.

🧩 Database per Service
- Cada serviço tem seu próprio banco de dados.
- Evita acoplamento entre microsserviços.

🔀 CQRS (Command Query Responsibility Segregation)
- Separa operações de leitura e escrita.
- Melhora performance e escalabilidade.

⛓ Choreography vs Orchestration
- Choreography: eventos e reações descentralizadas (event-driven).
- Orchestration: um serviço central coordena os outros.

🧾 Saga Pattern
- Gerencia transações distribuídas com rollback entre microsserviços.
- Usado quando não é possível usar transações ACID entre bancos diferentes.

💬 Event Sourcing
- Eventos representam mudanças de estado no sistema.
- Útil para auditoria e reconstrução de estado.

🚨 Circuit Breaker
- Impede que falhas em um serviço se propaguem para outros.
- Exemplo: Hystrix, Resilience4j.

⏳ Retry e Timeout
- Repetição automática de chamadas com falha.
- Define um limite de tempo para chamadas entre serviços.

📦 Bulkhead Pattern
- Isola falhas em uma parte do sistema para que não afetem outras.

🔐 Centralized Authentication
- Uso de tokens JWT, OAuth2, Keycloak, etc.

Usar padrões prontos é uma decisão estratégica. Eles são o atalho mais seguro para construir microsserviços que sejam resilientes, escaláveis, bem organizados e com baixo acoplamento.

3.13. Microservice Chassis com Spring Boot e Spring Cloud

📌 O que é um Microservice Chassis?
Um microservice chassis é uma base reutilizável que contém os componentes e configurações comuns que cada microsserviço precisa, como:

- Logging
- Segurança
- Tracing distribuído
- Configuração externa
- Health checks
- Comunicação entre serviços

💡 Objetivo: padronizar e acelerar a criação de microsserviços, evitando duplicação de código e garantindo boas práticas arquiteturais.

🛠️ Spring Boot + Spring Cloud: a combinação ideal
✅ Spring Boot
- Framework para criar aplicações Java prontas para produção com o mínimo de configuração.
- Ideal para construir microsserviços leves e independentes.

🔧 Spring Cloud
Conjunto de bibliotecas para resolver problemas comuns em arquiteturas distribuídas, como:

- Descoberta de serviços (Eureka)
- Roteamento (Zuul/Gateway)
- Configuração centralizada (Spring Cloud Config)
- Circuit breaker (Resilience4j)
- Mensageria (Stream, Kafka, RabbitMQ)
- Observabilidade (Sleuth, Zipkin, Micrometer)

📦 Exemplo de componentes em um Chassis com Spring Cloud
Componente	Função
Spring Cloud Config	Configuração externa e centralizada
Eureka (Service Discovery)	Registro e descoberta de serviços
Spring Cloud Gateway ou Zuul	API Gateway com roteamento inteligente
Resilience4j	Circuit breaker, retries e fallback
Spring Security + OAuth2	Autenticação e autorização centralizadas
Sleuth + Zipkin	Tracing distribuído e análise de chamadas
Micrometer + Prometheus	Métricas e monitoramento
Spring Cloud Stream	Integração com Kafka/RabbitMQ

📁 Organização do Chassis
O chassis pode ser um starter project ou um módulo Maven compartilhado, contendo:

/chassis
  ├── logging-config/
  ├── exception-handling/
  ├── security-config/
  ├── tracing-config/
  ├── actuator-config/
  └── starter-dependencies/

Cada microsserviço então apenas importa esse chassis como uma dependência.

🚀 Vantagens do Microservice Chassis
Redução de boilerplate
Padronização entre times
Ganho de velocidade no onboarding
Melhoria de governança e segurança
Escalabilidade organizacional

3.14. Ecossistema de projetos da (CNCF)[https://landscape.cncf.io/]

A CNCF (Cloud Native Computing Foundation) é uma fundação que promove e sustenta tecnologias cloud-native modernas, abertas e escaláveis.

Ela mantém um ecossistema rico de projetos que ajudam empresas a construir, executar e gerenciar aplicações distribuídas em ambientes de nuvem.

São soluções que seguem os princípios:

Contêineres
Microsserviços
Orquestração
Observabilidade
Resiliência
Escalabilidade automática

🧱 Categorias do Ecossistema CNCF
A CNCF organiza seus projetos em várias categorias funcionais. Aqui estão as principais:

1. Orquestração e Gerenciamento
Kubernetes (✅ Graduado): orquestração de contêineres.
K3s: Kubernetes leve para edge computing.
Helm: gerenciador de pacotes para Kubernetes.

2. Observabilidade e Monitoramento
Prometheus (✅ Graduado): monitoramento e alertas.
Grafana (em colaboração): visualização de métricas.
OpenTelemetry: padronização de logs, métricas e traces.

3. Networking e Service Mesh
Envoy: proxy de alto desempenho.
Istio: service mesh para controle de tráfego, segurança e observabilidade.
Linkerd: service mesh leve e simples.

4. Runtime (Execução de Aplicações)
containerd / CRI-O: runtimes de contêiner.
runc: runtime em baixo nível (OCI).

5. Armazenamento e Databases
Rook: orquestração de storage distribuído.
Longhorn: storage nativo em Kubernetes.

6. Segurança
SPIFFE/SPIRE: identidade segura para serviços.
Falco: detecção de ameaças em tempo real em containers.
OPA (Open Policy Agent): política como código.

7. Entrega Contínua e GitOps
ArgoCD: entrega contínua declarativa com GitOps.
Flux: outro projeto GitOps muito popular.
Tekton: pipelines de CI/CD nativas em Kubernetes.

📈 Maturidade dos Projetos CNCF
Os projetos são classificados em três níveis:

Nível	Significado
🍼 Sandbox	Projetos experimentais ou em estágio inicial
🚀 Incubating	Projetos com adoção em crescimento e comunidade ativa
🏆 Graduated	Projetos maduros, amplamente usados e bem suportados

A CNCF é um pilar central da arquitetura moderna cloud-native, com dezenas de projetos que cobrem todo o ciclo de vida de aplicações distribuídas, desde build até monitoramento, segurança e entrega contínua.


4.1. Conhecendo os principais desafios e desvantagens

Embora a arquitetura de microsserviços ofereça muitos benefícios, ela não é uma bala de prata. Migrar ou adotar esse modelo exige considerar complexidades técnicas, organizacionais e operacionais.

⚠️ 1. Complexidade Distribuída
Cada serviço é um sistema separado — isso aumenta a complexidade de deploy, testes e monitoramento.
Problemas de rede, latência, timeouts e perda de conexão tornam-se comuns.
É necessário lidar com eventual consistency em vez de transações ACID simples.

🔐 2. Autenticação e Autorização
Segurança entre serviços (ex: JWT, mTLS).
Verificação de escopo, acesso e expiração de tokens.
Propagação de identidade entre serviços é desafiadora.

🧪 3. Testes e QA mais difíceis
Testes end-to-end são mais complexos e frágeis.
Testes de integração exigem múltiplos serviços em execução.
Ambiente de testes completo pode ser caro e difícil de manter.

🧰 4. Observabilidade e Depuração
Logs, métricas e rastreamento distribuído (tracing) são obrigatórios.
Depurar um bug pode exigir consultar vários serviços, bancos de dados e logs.
Ferramentas como Prometheus, Grafana, Jaeger e ELK são necessárias.

📦 5. DevOps e Deploys
Cada microserviço pode ter sua própria pipeline CI/CD.
Gerenciar deploys independentes exige automação robusta.
Rollbacks podem ser difíceis se a base de dados foi alterada.

🧠 6. Curva de Aprendizado e Cultura
Requer maturidade de equipe: DevOps, GitOps, cultura de ownership.
Equipes devem ser autônomas, multifuncionais e com forte colaboração.

🔁 7. Comunicação entre serviços
Requisições via HTTP/gRPC ou eventos assíncronos com filas (RabbitMQ, Kafka).
Lidar com fallbacks, retries, circuit breakers.
Propagação de contexto entre chamadas distribuídas.

🏷️ 8. Versionamento e Compatibilidade
Difícil manter compatibilidade entre versões de APIs.
Requer estratégia clara de API versioning.
Deploys desacoplados precisam garantir retrocompatibilidade.

💰 9. Custo Operacional
Mais serviços = mais containers, pipelines, monitoramento, storage.
Necessidade de orquestradores (como Kubernetes).
Gestão de infraestrutura mais cara e complexa.

⚖️ 10. Overhead de Gerenciamento
Descoberta de serviços, contratos de interface, e governança.
Monitoramento de dependências e falhas em cascata.
Pode resultar em “microsserviços demais” (overengineering).

✅ Quando NÃO usar microsserviços
Evite esse modelo quando:
O sistema ainda está em fase inicial ou pequena escala.
A equipe tem pouca experiência com DevOps e arquitetura distribuída.
A complexidade não compensa os benefícios de independência e escala.


4.2. Complexidade na modelagem de serviços e o risco do monólito distribuído

📌 Modelar microsserviços não é só dividir código, é dividir responsabilidades de forma coesa, independente e orientada ao negócio.

⚠️ Riscos da má modelagem: o Monólito Distribuído
O que é isso?
➡ É quando você “espalha” um monólito em vários serviços, mas eles continuam fortemente acoplados e dependentes uns dos outros.

🔥 Sintomas:
Muitos serviços precisam ser atualizados juntos.
Requisições em cascata entre serviços para processar uma única ação.
Falha de um serviço derruba toda a aplicação.
Deploys e testes se tornam lentos e complexos.
Excesso de chamadas REST/gRPC entre serviços.

🎯 Causas Comuns
Modelagem baseada em camadas técnicas (ex: um serviço só para "usuários", outro para "pedidos", sem pensar no domínio).
Separação prematura sem entender o domínio.
Equipes organizadas em silos técnicos.
Ausência de Bounded Contexts (conceito do DDD).
Falta de visão de produto e experiência do usuário.

📌 ATENÇÃO: Domínio antes da tecnologia: modele com base em domínios de negócio (Domain-Driven Design).

4.3. Dificuldade na refatoração de fronteiras dos serviços

Quando começamos a dividir um sistema em microsserviços, tentamos delimitar bem as "fronteiras" — ou seja, o que pertence a qual serviço.

Porém, com o tempo, percebemos que:

- Algumas regras de negócio estão no serviço errado;
- Determinadas decisões foram precipitadas;
- Surgem dependências cruzadas que antes não existiam.

🛠️ Como mitigar esse problema?
1. Comece monolítico, module bem
- Antes de quebrar, modularize. Evita criar microsserviços antes de entender os limites naturais do domínio.

2. Use o DDD (Domain-Driven Design)
- Ajuda a identificar os bounded contexts corretos.

3. Evite decisões prematuras
- Espere o domínio amadurecer antes de separar em serviços.

4. Use eventos para transição
Ao mover dados de um serviço para outro:
- Publique eventos que os dois serviços escutam;
- Migre gradualmente.

5. Tenha contratos bem definidos
- Refatorar com APIs versionadas e contratos de comunicação desacoplados (como eventos) facilita mudanças.

ATENÇÃO: Antes de iniciar o desenvolvimento modele bem, pois o trablho de refatoração é tenso

4.4. Complexidade da computação distribuída

A computação distribuída, base dos microsserviços, traz muitas vantagens — como escalabilidade e autonomia — mas também muita complexidade.

Aqui estão os principais desafios da computação distribuída:

🧩 1. Falhas são inevitáveis
Serviços caem, a rede falha, pacotes se perdem.

Você precisa lidar com:

- Timeouts
- Retentativas
- Circuit Breakers
- Mensagens duplicadas

🔧 Exemplo: Um Serviço de Pagamento chama o Serviço de Entrega. Se a chamada falhar, você precisa decidir: tentar de novo? Reverter o pagamento?

🔄 2. Comunicação entre serviços
Chamadas HTTP entre serviços são lentas, falham ou travam.
APIs precisam ser versionadas, resilientes, seguras.
Pode-se usar filas (mensageria), mas isso complica ainda mais.
🔐 Você também precisa lidar com autenticação e autorização entre microsserviços (ex: JWT, mTLS).

🧠 3. Consistência eventual
Como cada serviço tem seu banco, não existe transação distribuída confiável.
Você precisa usar estratégias como:
Sagas (coordenadas ou coreografadas)
Eventual consistency
Event sourcing (em casos mais extremos)
🧨 Difícil garantir que "pagou → entregou" sem uma transação. Precisamos confiar em eventos e orquestrações.

🕵️ 4. Observabilidade
Como entender o que está acontecendo em dezenas de serviços?
Log centralizado (ex: ELK, Grafana Loki)
Tracing distribuído (ex: OpenTelemetry, Zipkin, Jaeger)
Métricas (ex: Prometheus, Grafana)
📊 "O pedido travou" — onde? Sem observabilidade, é impossível saber.

📉 5. Performance
Microsserviços geralmente têm mais latência que monólitos.
Cada salto de rede consome tempo.
Excesso de comunicação entre serviços (chamadas encadeadas) vira gargalo.

🧪 6. Testes e ambientes
Testar um fluxo end-to-end requer vários serviços funcionando juntos.
Ambientes de homologação devem simular o ambiente real distribuído.
Testes automatizados exigem mock, contrato, e cuidado com dependências.

Desafio	Soluções comuns
Falhas e latência:	Timeouts, retries, circuit breakers
Comunicação entre serviços:	APIs resilientes, mensageria
Consistência eventual:	Sagas, eventos, CQRS
Observabilidade:	Tracing, métricas, logs
Performance:	Otimização de chamadas, cache, batch
Testabilidade:	Testes de contrato, mocks, ambientes integrados


4.5. Teorema CAP e consistência eventual

O Teorema CAP é um conceito fundamental para entender os trade-offs em sistemas distribuídos, como microsserviços.
Ele nos diz que em qualquer sistema distribuído, só é possível garantir no máximo dois dos três elementos a seguir ao mesmo tempo:

C	- Consistência:	          Todos os nós veem os mesmos dados ao mesmo tempo.
A	- Disponibilidade:	      O sistema sempre responde (com sucesso ou erro).
P	- Tolerância à Partição:  O sistema continua funcionando mesmo que haja falhas de comunicação entre nós.

⚖️ Trade-offs (escolha dois):
Tipo de sistema	                                      Garante	                                        Sacrifica
CP (Consistência + Partição)            :	Dados sempre consistentes mesmo com falhas de rede  :	Pode ficar indisponível
AP (Alta disponibilidade + Partição)	  : Sempre responde	                                    : Pode haver dados desatualizados (inconsistência eventual)
CA (Consistência + Disponibilidade)	    : Coerência e resposta	                              : ❌ Não tolera falhas de rede – irreal em sistemas distribuídos

Consistência Eventual
- É o modelo adotado por muitos sistemas distribuídos (ex: bancos NoSQL, microsserviços).
- Os dados podem estar temporariamente inconsistentes, mas eventualmente convergem.

- É comum quando usamos:
  - Mensageria (eventos assíncronos)
  - Replicação de dados entre serviços
  - Sagas coreografadas

📘 Exemplo: Um pedido é feito e o serviço de pagamento recebe o evento depois de alguns segundos. Os dados “ficam certos” com o tempo.


4.7. Aumento de custos de infraestrutura e operação

A adoção da arquitetura de microsserviços traz muitas vantagens — como escalabilidade, resiliência e autonomia dos times — mas também aumenta significativamente os custos, especialmente em comparação com um monólito simples.

1. Mais instâncias e serviços
Em vez de um único deploy, você passa a ter dezenas (ou centenas) de serviços rodando individualmente.
Cada serviço requer recursos de CPU, memória, armazenamento, rede etc.

2. Ambiente de execução mais complexo
Precisa de containers (Docker), orquestração (Kubernetes), service mesh (Istio, Linkerd), gateways, proxies, etc.
Toda essa infraestrutura consome recursos mesmo quando o tráfego é baixo.

3. Observabilidade
É necessário investir em ferramentas como:
Log centralizado (ELK, Loki, Datadog)
Tracing distribuído (Jaeger, Zipkin)
Monitoramento (Prometheus, Grafana)
Essas ferramentas também rodam em containers e geram custo computacional.

4. Comunicação em rede
Microsserviços se comunicam via rede, o que pode gerar:
Latência
Erros de rede
Tráfego elevado, impactando a conta da nuvem

5. Múltiplos pipelines e deploys
Cada serviço precisa de um pipeline de CI/CD separado.
A automação se torna essencial, o que exige engenharia de plataforma e ferramentas específicas.

6. Time de plataforma/SRE/DevOps
Para operar uma arquitetura distribuída, muitas empresas precisam de um time dedicado para manter a infraestrutura (monitoramento, deploys, scripts de recuperação, segurança etc.).

☁️ Na nuvem, paga-se por:
Quantidade de instâncias ou pods em execução
Uso de CPU e memória
Volume de tráfego entre zonas/serviços
Armazenamento e logs
Serviços gerenciados (ex: Kafka, bancos, tracing)

4.8. Riscos de segurança

Superfície de ataque ampliada
Vários serviços = mais pontos de entrada = mais vulnerabilidades potenciais.

Comunicação entre serviços exposta
Dados trafegam via rede (HTTP/gRPC), podendo ser interceptados sem criptografia (use HTTPS/TLS).

Autenticação e autorização distribuídas
Cada serviço precisa validar tokens e permissões corretamente. Se mal implementado, vira brecha.

Gestão de segredos
Tokens, chaves de API, credenciais… precisam ser bem protegidos e rotacionados (ex: usar Vault).

Dependências externas vulneráveis
Muitos serviços = mais bibliotecas = maior chance de vulnerabilidades conhecidas.

Configuração incorreta
Erros de CORS, permissões excessivas, portas abertas, etc., são comuns em ambientes mal gerenciados.

Falhas no isolamento
Falta de sandboxing ou containers mal configurados podem permitir acesso indevido entre serviços.

4.9. Conformidade com regulamentações de privacidade (LGPD/GDPR)

Microsserviços devem seguir regras de proteção de dados como LGPD (Brasil) e GDPR (Europa), o que traz desafios específicos:

🔐 Principais exigências:

Consentimento do usuário
Os serviços que coletam dados devem registrar e respeitar o consentimento.

Finalidade e minimização de dados
Cada serviço deve tratar apenas os dados estritamente necessários.

Direito de acesso, correção e exclusão
O sistema deve permitir que usuários consultem e solicitem remoção/alteração de seus dados (ex: “Direito ao esquecimento”).

Segurança no tratamento
Dados pessoais devem ser armazenados e transmitidos com segurança (criptografia, mascaramento, etc).

Auditoria e rastreabilidade
Microsserviços devem registrar logs e ter trilhas auditáveis sobre como os dados foram manipulados.

Compartilhamento com terceiros
Deve haver controle e transparência sobre para quem os dados são enviados (outros serviços, parceiros etc.).

Solução: 
- Centralizar políticas de privacidade
- Ter um serviço de conformidade (ex: Privacy Service)
- Automatizar anonimização, deleção e exportação de dados
- Documentar e revisar rotas sensíveis

4.10. Hype Driven Development e Technology Sprawl

🚀 Hype Driven Development (Desenvolvimento guiado por modinha)
Escolher tecnologias porque estão na moda, sem avaliar se resolvem o problema real.
Exemplo: usar Kubernetes, Kafka, GraphQL ou microsserviços sem necessidade.

⚠️ Consequência: Complexidade desnecessária, curva de aprendizado alta e desperdício de tempo e dinheiro.

🌪️ Technology Sprawl (Dispersão tecnológica)
Cada time escolhe stacks, libs e ferramentas diferentes, gerando um ecossistema caótico.
Exemplo: 10 microsserviços com 5 linguagens, 4 bancos de dados e 3 frameworks web diferentes.

⚠️ Consequência: Difícil manter, testar, contratar, versionar, monitorar e integrar.

5.1. Fuja de microsserviços: quando não vale a pena a adoção

A adoção de microsserviços tem se tornado uma tendência em arquiteturas modernas, mas nem sempre é a melhor escolha. Abaixo estão alguns cenários onde "fugir" de microsserviços é a decisão mais inteligente:

🚫 1. Projetos pequenos ou com escopo bem definido
Microsserviços introduzem uma complexidade significativa em termos de:

Deploys independentes
Comunicação entre serviços (REST, mensageria, etc.)
Monitoramento, logging e rastreamento distribuído
Tolerância a falhas e consistência de dados
Quando não há demanda real por essa complexidade, um monólito bem estruturado é mais eficiente.

📌 Exemplo: Um sistema de controle de tarefas para uma equipe pequena.

⚠️ 2. Falta de maturidade da equipe
Microsserviços exigem uma série de práticas avançadas:

DevOps maduro
Observabilidade (logs, métricas, tracing)
CI/CD automatizado
Design orientado a domínios (DDD)
Equipes inexperientes podem transformar a arquitetura distribuída em um caos técnico difícil de manter.

🔄 3. Necessidade de consistência forte entre dados
Quando as transações exigem consistência estrita entre múltiplas operações, microsserviços são desafiadores:
Transações distribuídas são difíceis de manter e escalar
Você terá que lidar com Sagas, eventuais inconsistências, compensações, etc.
📌 Exemplo: Sistemas bancários de movimentação financeira com múltiplas validações simultâneas.

💸 4. Infraestrutura limitada
Rodar microsserviços requer:

Orquestradores (como Kubernetes)
Balanceadores de carga
Gateways de API
Alta disponibilidade dos serviços
Se você não tem recursos para investir nisso, o custo de manutenção pode ser proibitivo.

🛑 5. Prematura separação de serviços
Evite cair no erro do "pré-otimizar":
Muitos sistemas podem começar como monólitos modulares e só depois se dividirem em microsserviços.
Separar cedo demais pode levar a dependências cruzadas mal definidas, serviços anêmicos ou altamente acoplados.

🧠 Monólito modular > Microsserviço mal projetado

✅ Quando um monólito é melhor:
Projeto novo sem necessidade clara de escalabilidade independente
Sistema com equipe reduzida
Time sem experiência em microsserviços
Requisitos técnicos simples ou de médio porte
Foco em entrega rápida e validação de produto (MVP)

5.2 Abrace os microsserviços quando realmente faz sentido 

Embora os microsserviços adicionem complexidade, em determinados contextos, eles são altamente vantajosos. O segredo está em reconhecer quando o custo da complexidade compensa os ganhos de autonomia, escalabilidade e resiliência.

✔️ Recapitulando: Quando vale a pena adotar microsserviços?
Critério	Indício que justifica
Domínio	: Vários contextos bem definidos
Escalabilidade:	Carga desigual entre componentes
Equipes	Múltiplos: times com foco em partes distintas
Resiliência:	Precisa isolar falhas e manter o sistema funcional
Frequência de deploy:	Mudanças constantes em partes isoladas do sistema

5.3 Monólito Modular: Alternativa aos microsserviços 

Quando microsserviços não são a melhor escolha, mas o sistema ainda precisa de organização, escalabilidade interna e separação de responsabilidades, o monólito modular surge como uma solução estratégica.

🧠 O que é um monólito modular?
É uma aplicação única (um deploy, um processo), mas com sua estrutura interna dividida por módulos independentes e coesos, que:

Encapsulam suas regras de negócio
Não se acoplam diretamente entre si (ou fazem isso por contratos bem definidos)
Mantêm separação lógica clara, mesmo estando no mesmo binário

🔍 É pensar como microsserviços, mas sem distribuir.

✅ Quando optar por monólito modular?
Projeto está começando e pode crescer
Equipe ainda pequena ou em fase de aprendizado
Há clareza de domínios e responsabilidade, mas sem necessidade de deploys independentes
Requisitos de escalabilidade são limitados ou futuros

🔧 Benefícios do monólito modular
Vantagem	Descrição
🧩 Organização	Cada módulo representa um bounded context da aplicação
🧪 Testabilidade	Fica mais fácil testar partes isoladas do sistema
🚀 Evolução	Facilita uma futura extração para microsserviços
🧱 Simplicidade operacional	Apenas um deploy, uma infraestrutura, menos sobrecarga
👥 Autonomia parcial	Equipes podem cuidar de módulos diferentes, mesmo num repositório único


5.4 Estratégias Greenfield: Microservices First e Monolith First

Projetos greenfield (iniciados do zero) oferecem a rara oportunidade de escolher uma arquitetura sem amarras do legado. Mas com essa liberdade vem a responsabilidade:
adotar a abordagem certa desde o início pode acelerar — ou comprometer — o sucesso do projeto.

Duas abordagens comuns se destacam:

⚙️ Microservices First
Começar diretamente com microsserviços, projetando o sistema como um conjunto de serviços distribuídos desde o início.

✅ Quando usar:
A empresa já tem experiência sólida com microsserviços
Domínios bem definidos desde o início
Equipe multidisciplinar e infraestrutura madura (DevOps, CI/CD, observabilidade, mensageria)
Escalabilidade e resiliência são requisitos críticos desde o MVP

🔍 Exemplo prático:
Uma fintech com squads separados para onboarding, transações e antifraude decide começar com três serviços distintos e independentes, pois o volume e a criticidade são altos desde o primeiro dia.

⚠️ Riscos:
Superengenharia desnecessária
Complexidade técnica precoce
Dificuldade de mudar o design se os domínios forem mal compreendidos

🧱 Monolith First
Começar com um monólito bem estruturado e modular, com o objetivo de extrair microsserviços quando (e se) for necessário.

✅ Quando usar:
Equipe reduzida ou com pouca experiência em arquiteturas distribuídas
Domínios ainda estão sendo descobertos (fase de exploração e validação)
MVP rápido é uma prioridade
A complexidade da infraestrutura deve ser mantida ao mínimo no início

🔍 Exemplo prático:
Uma startup quer validar rapidamente uma plataforma de educação online. Escolhe construir um monólito modular com contextos bem separados (usuário, curso, pagamento), com possibilidade futura de extração de microsserviços.

🎯 Vantagens:
Menor custo de operação e deploy
Simplicidade no início
Base sólida para modularização e futura transição

5.5 Anti-patterns organizacionais: Big Bang, Modularização incremental e Strangler Fig Pattern

Migrar um sistema legado para microsserviços ou modularizar um monólito exige mais que decisões técnicas: é também um desafio organizacional. E nesse processo, algumas armadilhas são recorrentes.

❌ Big Bang Rewrite
“Vamos reescrever tudo do zero, agora do jeito certo.”

🧱 O que é?
É a tentativa de substituir o sistema legado inteiro por uma nova arquitetura — geralmente microsserviços — em um único grande movimento.

⚠️ Problemas:
Altíssimo custo, risco e tempo de execução
Pouco feedback real durante o processo
Dificuldade de reproduzir todos os comportamentos e integrações legadas
Produto pode nunca ser entregue antes de se tornar obsoleto

💡 Alternativa:
Evite! Prefira abordagens incrementais, como o Strangler Fig Pattern, que veremos a seguir.

❌ Modularização incremental mal orientada
“Vamos modularizando aos poucos, conforme der...”

🧱 O que é?
A ideia de migrar ou modularizar sem uma visão clara de domínios, fronteiras ou objetivos técnicos, apenas reorganizando classes ou pacotes superficialmente.

⚠️ Problemas:
Falsa sensação de modularidade
Módulos altamente acoplados
Dificuldade de extração futura para microsserviços
Falta de alinhamento entre times

💡 Alternativa:
Use DDD (Domain-Driven Design) para guiar a separação de módulos.
Estabeleça contratos claros e independência entre os módulos desde o início.
Acompanhe com métricas técnicas (acoplamento, coesão, cobertura de testes, etc).

🌱 Strangler Fig Pattern (padrão da figueira estranguladora)
“Vamos substituir o sistema aos poucos, mantendo o legado vivo até que tudo tenha migrado.”

🧱 O que é?
Inspirado numa planta que cresce ao redor de outra até substituí-la, este padrão consiste em envolver o sistema legado com uma nova arquitetura, redirecionando funcionalidades para novos serviços à medida que forem reconstruídas.

✅ Vantagens:
Permite feedback rápido
Reduz risco ao manter funcionalidades legadas ativas
Favorece evolução por prioridades reais (uso, valor de negócio, urgência)

🔍 Exemplo:
Um endpoint /api/clientes continua atendido pelo legado.
O endpoint /api/pedidos é redirecionado para um novo microsserviço.
Gradualmente, mais endpoints migram até que o sistema legado seja aposentado.

6.1 Padrões de comunicações entre microsserviços

  1. Comunicação Síncrona (Request/Response)
  Protocolo comum: HTTP/HTTPS (REST, gRPC).

  Características:
  O serviço que chama espera a resposta.
  Mais simples de implementar.
  Pode causar acoplamento e problemas de escalabilidade se muitos serviços dependerem uns dos outros diretamente.
  Exemplo: Um serviço de pedido chama o serviço de pagamento via REST para processar o pagamento.

  2. Comunicação Assíncrona (Mensageria)
  Tecnologias comuns: RabbitMQ, Apache Kafka, Amazon SQS.

  Características:
  Comunicação baseada em eventos ou mensagens.
  O emissor envia a mensagem e não espera resposta.
  Permite baixo acoplamento e alta escalabilidade.
  Exemplo: O serviço de pedido envia um evento “pedido criado” e o serviço de estoque consome esse evento para reservar os produtos.

  3. Event-Driven Architecture (Arquitetura Orientada a Eventos)
  Eventos são disparados por serviços e outros serviços reagem a eles.

  Padrões comuns:
  Event Notification: Apenas sinaliza que algo ocorreu.
  Event-Carried State Transfer: O evento já carrega todos os dados necessários.
  Event Sourcing: O estado do sistema é reconstruído com base em eventos.
  Vantagem: Escalabilidade, auditabilidade, e histórico claro de mudanças.

  4. API Gateway
  Um ponto de entrada para o sistema.
  Pode rotear requisições, aplicar autenticação, balanceamento de carga e transformação de protocolos.
  Exemplo de ferramenta: Kong, Zuul, Spring Cloud Gateway.
  Benefício: Centraliza e padroniza a comunicação com os microsserviços.

  6. Comunicação por Chaveamento (Choreography x Orchestration)
  Choreography: Cada serviço sabe o que fazer e reage a eventos (mais desacoplado).
  Orchestration: Um serviço central coordena o fluxo (mais controle, porém mais acoplamento).

6.2 Introdução ao Request-response Pattern (Request-reply)
O padrão Request-Response, também conhecido como Request-Reply, é um dos padrões de comunicação mais comuns em sistemas distribuídos.
Ele consiste em uma interação onde um cliente envia uma requisição (request) para um servidor, e espera receber uma resposta (response).
Esse padrão pode ser implementado de duas formas principais: síncrona e assíncrona.

# Na comunicação síncrona, o cliente aguarda a resposta do servidor antes de continuar sua execução.

Exemplo:
Um cliente HTTP envia uma requisição GET para uma API REST e espera a resposta antes de continuar.

Características:
Bloqueante: o cliente fica inativo até receber a resposta.
Baixa latência esperada: usado quando a resposta é rápida.
Exemplo de tecnologia: HTTP/REST, gRPC síncrono, chamadas diretas via métodos.

# Na comunicação assíncrona, o cliente não espera pela resposta imediatamente. Em vez disso, a resposta pode chegar depois, via outro canal, ou ser tratada por meio de callbacks, futuros/promessas ou mensageria.

Exemplo:
Um serviço envia uma mensagem para uma fila (como RabbitMQ ou Kafka) e continua seu processamento. O consumidor processa a mensagem e envia a resposta posteriormente, talvez por outra fila ou endpoint.

Características:
Não bloqueante: permite maior escalabilidade.
Resiliência: desacopla produtor e consumidor.
Exemplo de tecnologia: JMS, RabbitMQ, Apache Kafka, gRPC assíncrono, WebSockets, Promises (JavaScript), CompletableFuture (Java).

Use Síncrono quando:

- Precisa da resposta imediata.
- As operações são rápidas e confiáveis.
- Há menor volume de requisições simultâneas.

Use Assíncrono quando:

- Deseja escalar melhor.
- Lida com operações demoradas ou interdependentes.
- Precisa de resiliência contra falhas temporárias.

6.3 Comunicação bloqueante e não bloqueante 

🔒 Bloqueante (Blocking) Síncrono
- O processo espera a resposta antes de continuar.
- Fica parado até terminar.
✅ Simples, mas menos eficiente em grande escala.
🧱 Exemplo: REST com Spring MVC.

🔓 Não Bloqueante (Non-blocking) Assíncrono
- O processo não espera; continua executando.
- A resposta é tratada depois (callback, evento, future).
🚀 Melhor para alta escalabilidade.
⚙️ Exemplo: Spring WebFlux, Node.js, CompletableFuture.

6.4 O que são contratos

Um contrato é um acordo formal que define como os microsserviços devem se comunicar entre si. Ele especifica o formato das mensagens, os dados esperados, os tipos de requisição, as respostas e possíveis erros.

Por que é importante?
- Garante que serviços diferentes entendam corretamente as mensagens trocadas.
- Permite que equipes trabalhem de forma independente, sem quebrar a comunicação.
- Facilita a manutenção, evolução e testes dos serviços.

Exemplos de contratos
- APIs REST com definição via OpenAPI/Swagger.
- Eventos com schemas (ex: Avro, JSON Schema).
- Mensagens em filas com formatos padronizados.

Caracteristicas:
- schema
- protocolo de comunicação
- formatos de dados suportados (serialização)
- pontos de interface
- versão do contrato 
- regras de evolução

Documentar Contratos:
- OpenAPI: RestAPI
- AsyncAPI: Definir Contratos de comunicação assincrona

6.5 Serialização 

Serialização é o processo de converter uma estrutura de dados ou objeto em uma sequência de bytes, para que possa ser transmitida, armazenada ou reconstruída depois.

Componentes principais
Formato: Como os dados são organizados no arquivo ou mensagem (ex: JSON, XML, Protobuf).
Schema / IDL (Interface Definition Language): Descreve a estrutura dos dados (ex: Avro, Protobuf .proto files). Garante que remetente e receptor entendam os dados da mesma forma.
Codificação: A maneira de converter os dados em bytes (ex: binário compacto, texto legível).

Exemplo rápido:
JSON é um formato de serialização texto, sem schema fixo.
Protobuf usa schema definido e codificação binária, mais eficiente.

6.6 Acoplamento e microsserviços

🔗 O que é acoplamento?
Acoplamento é o nível de dependência entre dois módulos ou serviços.
- Alto acoplamento: serviços muito dependentes entre si → difíceis de mudar, testar e escalar.
- Baixo acoplamento: serviços independentes → mais flexíveis, fáceis de evoluir.

🤝 Microsserviços e o baixo acoplamento
Microsserviços devem ser:
- Independentes para evoluir e implantar separadamente.
- Bem definidos por contratos (APIs, mensagens).
- Fracos acoplamentos, mas fortes coesões (fazem bem uma tarefa específica).

6.7 Messaging Patterns e mensageria 

📦 O que é mensageria?
Mensageria é um modelo de comunicação entre sistemas usando mensagens trocadas por meio de filas ou brokers (ex: RabbitMQ, Kafka).
Em vez de chamadas diretas, um serviço envia uma mensagem e o outro a processa de forma assíncrona.

🔁 Principais Messaging Patterns

Point-to-Point (Ponto a Ponto)
- Um remetente envia para uma fila.
- Um único consumidor processa a mensagem.
🧾 Ex: Fila de pedidos.

Publish/Subscribe (Pub/Sub)
- Um remetente publica uma mensagem.
- Vários consumidores inscritos recebem cópias.
🧾 Ex: Notificações para múltiplos serviços.

Request/Reply (Requisição/Resposta)
- Um serviço envia uma mensagem e espera uma resposta.
- Pode ser síncrono ou assíncrono.

Fan-out
- Parecido com Pub/Sub, mas todas as mensagens são replicadas para várias filas.
- Útil para replicar eventos para múltiplos destinos.

Competing Consumers
- Vários consumidores escutam a mesma fila e competem para processar mensagens.
- Ajuda na escalabilidade.

📬 Exemplo de ferramentas de mensageria
- RabbitMQ: baseado em filas, fácil de usar.
- Apache Kafka: ideal para eventos em larga escala e persistência.
- ActiveMQ, Amazon SQS, Azure Service Bus, etc.

Messaging patterns definem como os serviços trocam mensagens em sistemas distribuídos.
Eles aumentam a desacoplagem, a resiliência e a escalabilidade dos microsserviços.

6.8 Producer-consumer Pattern

É um padrão de design usado quando um ou mais produtores geram dados (ou tarefas) e colocam em uma fila, e um ou mais consumidores retiram esses dados para processar.

👥 Quem são:
Producer (Produtor):
Cria e envia mensagens/tarefas para uma fila (ex: novo pedido, evento, log).

Consumer (Consumidor):
Lê da fila e processa a mensagem (ex: salva no banco, envia e-mail, gera relatório).

📦 Onde é usado?
Em mensageria assíncrona
Para desacoplar serviços e melhorar a escalabilidade.
Quando o processamento pode ser feito de forma independente e paralela.

✅ Benefícios
Evita sobrecarga no consumidor.
Permite escalabilidade (vários consumidores).
Torna o sistema mais resiliente (mensagens não se perdem).

🧾 Exemplo simples
Serviço A (produtor) envia pedidos para uma fila.
Serviço B (consumidor) retira da fila e processa os pedidos.

🎯 Resumo
O Producer-Consumer Pattern é ideal para comunicação assíncrona entre microsserviços, promovendo desacoplamento, performance e escalabilidade.

6.9 Publisher-subscriber Pattern

É um padrão de comunicação onde um publicador (publisher) envia mensagens sem saber quem vai receber, e um ou mais assinantes (subscribers) recebem essas mensagens se estiverem inscritos.

👥 Quem são:
Publisher (Publicador):
Envia eventos ou mensagens para um canal ou tópico.

Subscriber (Assinante):
Escuta o canal/tópico e recebe mensagens que forem publicadas ali.

📦 Como funciona?
O publicador envia uma mensagem para um tópico.
Todos os assinantes daquele tópico recebem uma cópia da mensagem.
Não há ligação direta entre publicador e assinantes → desacoplamento total.

🧾 Exemplo real:
- Um serviço publica o evento "Usuário criado".
- Vários serviços ouvem esse evento:
  - Serviço de e-mail envia mensagem de boas-vindas.
  - Serviço de analytics registra novo usuário.
  - Serviço de auditoria grava o evento.

✅ Benefícios
Desacoplamento entre remetente e receptores.
Fácil adicionar/remover assinantes.
Ideal para event-driven architecture.

🎯 Resumo
Pub/Sub permite que múltiplos serviços escutem eventos de forma desacoplada, ajudando na escalabilidade e evolução independente dos microsserviços.


7.1. Introdução à modelagem de microsserviços

A modelagem de microsserviços trata da forma como dividimos um sistema grande em pequenos serviços independentes, cada um responsável por uma função específica do negócio.

✅ Principais conceitos:
Microsserviço: é um módulo pequeno, autônomo, que executa uma função específica.

Desacoplamento: cada microsserviço funciona de forma independente dos outros.

Foco no domínio: os microsserviços são modelados com base em áreas do negócio (ex: faturamento, cadastro de clientes).

Comunicação via API: microsserviços se comunicam entre si por meio de interfaces bem definidas, geralmente com HTTP/REST ou mensageria.

Independência de deploy: cada serviço pode ser atualizado ou implantado sem afetar os demais.

🎯 Objetivo:
Tornar o sistema mais flexível, escalável e fácil de manter, permitindo que equipes diferentes trabalhem em serviços diferentes ao mesmo tempo.


7.2 Baixo Acomplamento: Reduza as dependencias entre serviços

Baixo acoplamento significa que os microsserviços devem ser o mais independentes possível uns dos outros.

✅ Por que isso é importante?
Facilita a manutenção e evolução do sistema.
Permite que serviços sejam implantados separadamente.
Reduz o risco de erros se propagarem entre serviços.
Melhora a escalabilidade e a resiliência do sistema.

🧩 Como alcançar baixo acoplamento?
Use APIs bem definidas para comunicação.
Evite acesso direto ao banco de dados de outro serviço.
Troque dados essenciais, não objetos complexos.
Utilize mensageria (eventos) quando possível, em vez de chamadas diretas.

👉 Em resumo: cada serviço deve saber o mínimo necessário sobre os outros para funcionar corretamente.

⚠️ Sintomas de serviços muito acoplados

🔗 1. Mudança em um serviço quebra outros: Se você altera um serviço e precisa mudar vários outros juntos, isso indica forte dependência.
🚫 2. Deploys sincronizados: É preciso atualizar vários serviços ao mesmo tempo, o que dificulta entregas rápidas.
🔍 3. Conhecimento excessivo entre serviços: Um serviço "sabe demais" sobre a estrutura interna de outro (ex: conhece classes ou tabelas do outro serviço).
🐌 4. Baixa autonomia das equipes: Equipes não conseguem trabalhar de forma independente, pois sempre dependem de alterações em outros serviços.
🔁 5. Reutilização indevida de banco de dados: Um serviço acessa diretamente o banco de dados de outro, criando forte acoplamento entre dados.
🧩 6. Falhas em cascata: Quando um serviço cai, vários outros deixam de funcionar também.

👉 Esses sinais indicam que o sistema precisa ser refatorado para ter melhor isolamento e independência entre os microsserviços. 

7.3 Acoplamento por domínio

  Quando dois ou mais serviços compartilham a mesma lógica de negócio ou responsabilidade.

  ❌ Problema: os serviços ficam muito ligados e não seguem bem o princípio de separação por contexto.

  💡 Solução: usar Bounded Contexts da modelagem DDD (Domain-Driven Design), garantindo que cada serviço cuide apenas do seu domínio específico.

  Ex: um serviço de vendas que depende de regras internas do serviço de pagamentos para funcionar.

7.4 Acoplamento por repasse de dados

  Acontece quando um serviço precisa repassar dados que não são dele, apenas para ajudar outro serviço.

  ❌ Problema: o serviço vira um "mensageiro", ficando inchado e responsável por dados que não fazem parte do seu domínio.

  💡 Solução: permitir que o serviço que realmente precisa dos dados os busque diretamente ou use uma mensageria/eventos.

  Ex: o serviço A recebe uma requisição, repassa dados para B, que repassa para C — sendo que só C realmente precisa da informação.


7.5 Acoplamento por recurso comum

  Ocorre quando vários serviços compartilham o mesmo recurso, como um banco de dados, cache ou arquivo.

  ❌ Problema: se um serviço altera o recurso, pode impactar os outros.

  💡 Solução: cada serviço deve ter seu próprio recurso isolado. Dados em comum podem ser replicados ou sincronizados por eventos.

  Ex: dois serviços usam a mesma tabela no banco de dados.

7.6 Acoplamento por estrutura interna e Information hiding

  Acontece quando um serviço expõe detalhes da sua estrutura interna para outros.

  ❌ Problema: se a estrutura mudar, todos os serviços dependentes quebram.

  💡 Solução: usar encapsulamento e contratos claros (como DTOs e APIs estáveis), escondendo os detalhes internos.

  Ex: outro serviço acessa diretamente os campos de uma entidade interna, ao invés de usar uma API ou DTO.

  Information Hiding: Um serviço não deve expor detalhes internos para outro

7.7 Alta coesão, Single Resposability Principle e Common Clousure Principle

Organize seus serviços para que cada um tenha uma única responsabilidade, alta coesão interna e mude o mínimo possível com mudanças externas.

🔹 Alta coesão
  Cada serviço deve ter responsabilidades relacionadas e bem definidas.
  Um serviço faz bem uma coisa específica, sem misturar funcionalidades.
  Benefício: código mais organizado, fácil de entender, testar e manter

🔹 SRP (Single Responsibility Principle)
  (Princípio da Responsabilidade Única)
  Um módulo (ou serviço) deve ter apenas um motivo para mudar.
  Ele resolve um único problema ou função dentro do sistema.
  Ex: um serviço que só gerencia usuários — não cuida de autenticação, relatórios, etc.

🔹 CCP (Common Closure Principle)
  (Princípio do Fechamento Comum)
  Classes (ou funcionalidades) que mudam pelos mesmos motivos devem estar juntas no mesmo módulo.
  Isso minimiza o impacto de mudanças e facilita a evolução do sistema.
  Ex: tudo que muda quando há uma alteração nas regras de pagamento deve estar no mesmo serviço.


7.8. Lei de Constantine: Equilibrando entre acoplamento e coesão

"A estrutura de um sistema de software deve ser tal que minimize o acoplamento entre os módulos e maximize a coesão dentro dos módulos",
ou seja: "Alta coesão e baixo acoplamento"

🔗 Acoplamento
Definição: Grau de dependência entre módulos.
Desejável: Baixo acoplamento.
Por quê? Sistemas com baixo acoplamento são mais fáceis de manter, testar e evoluir.

🧱 Coesão
Definição: Grau em que os elementos de um módulo estão relacionados entre si.
Desejável: Alta coesão.
Por quê? Um módulo coeso é mais compreensível e realiza uma única responsabilidade bem definida.

7.9. Decompondo por capacidades de negócio (Business Capabilities)

Capacidades de negócio são as habilidades fundamentais que uma organização possui para gerar valor. Elas representam o "o que a empresa faz", de maneira estável, independente de processos, pessoas ou tecnologias.

Exemplos de capacidades:
Cadastro de Clientes
Gerenciamento de Pedidos
Faturamento
Controle de Estoque
Pagamento de Royalties

🧠 Pense nelas como "blocos funcionais autônomos" que existem mesmo se a tecnologia ou processos mudarem.

Decompor sistemas por capacidades de negócio é uma prática que:

Reduz o acoplamento entre módulos
Aumenta a coesão dentro dos módulos
Reforça a autonomia das equipes
Acelera a entrega de valor

Ela representa um passo maduro na direção da arquitetura orientada ao negócio, ideal para organizações que desejam escalar com segurança, clareza e eficiência.

7.10. Refinando fronteiras por subcapacidades e requisitos não funcionais

Após decompor o sistema em capacidades de negócio, o próximo passo natural é refinar essas divisões para que reflitam subcapacidades mais específicas e
requisitos não funcionais (RFNs) relevantes — como desempenho, escalabilidade, segurança e disponibilidade.

Esse refinamento permite maior granularidade, clareza arquitetural e alinhamento com restrições técnicas e operacionais.

🧱 O que são Subcapacidades?
Subcapacidades são desdobramentos especializados de uma capacidade de negócio, representando partes coesas e reutilizáveis de seu comportamento.

Exemplo:
Capacidade: Distribuir Recebimentos

Subcapacidades possíveis:
Calcular valores de repasse
Aplicar regras de rateio por contrato
Gerar extratos de distribuição
Validar dados antes do repasse

Cada subcapacidade pode representar uma fronteira lógica para um módulo, componente ou microserviço.

⚙️ E os Requisitos Não Funcionais?
Requisitos não funcionais afetam como o sistema deve se comportar,
independentemente da lógica de negócio. Eles têm um impacto direto sobre a forma como refinamos ou isolamos partes do sistema.

Exemplos comuns:
RFN	Impacto no refinamento
Desempenho	Separar partes críticas para otimização específica
Escalabilidade	Isolar componentes para escalar horizontalmente
Segurança	Conter dados sensíveis em serviços restritos
Tolerância a falhas	Separar fluxos críticos de fluxos não essenciais
Auditabilidade	Criar módulos especializados para rastreabilidade

7.11. Reconhecendo bad smells na modelagem de microsserviços

Na jornada de modelagem de microsserviços, é comum cometer erros que, embora não causem falhas imediatas,
resultam em sistemas difíceis de manter, escalar ou evoluir. Esses sintomas são conhecidos como "bad smells" (ou "maus odores arquiteturais").
Reconhecê-los cedo permite realizar ajustes antes que se tornem problemas sistêmicos.

1. Serviços com nomes genéricos
⚠️ UserService, DataService, InfoService, etc.
❌ Indica falta de alinhamento com capacidades de negócio.
✅ Prefira nomes como CadastroDeClientesService ou DistribuicaoDeRecebimentosService.

2. Modelos de dados compartilhados
⚠️ Vários serviços acessando a mesma tabela ou esquema de banco.
❌ Viola o princípio de autonomia do microserviço.
✅ Cada serviço deve ter seu próprio modelo de dados e, idealmente, sua própria base.

3. Orquestração centralizada excessiva
⚠️ Um serviço "controlador" que decide tudo o que os outros fazem.
❌ Cria acoplamento entre fluxos e perda de resiliência.
✅ Use coreografia por eventos quando possível para manter os serviços desacoplados.

4. Serviços que fazem “tudo”
⚠️ Um serviço que cuida de autenticação, negócios, relatórios e mais.
❌ Alto acoplamento interno, baixa coesão.
✅ Divida por subcapacidades ou bounded contexts.

5. Comunicação síncrona entre todos os serviços
⚠️ Serviços chamando outros via HTTP em cadeia.
❌ Cria dependência de disponibilidade em tempo real (cascata de falhas).
✅ Use mensageria assíncrona (Kafka, RabbitMQ) quando possível.

6. Inconsistência de contratos de API
⚠️ Mudanças em uma API quebram outros serviços.
❌ Falta de versionamento ou contratos bem definidos.
✅ Use OpenAPI/Swagger com versionamento e controle de compatibilidade.

7. Repetição de lógica de negócio entre serviços
⚠️ Mesmas validações ou cálculos espalhados em vários pontos.
❌ Quebra o princípio DRY e gera divergência com o tempo.
✅ Centralize essa lógica em um serviço único ou extrato comum com versionamento.

8. Dependência circular entre serviços
⚠️ Serviço A chama B que chama C que chama A.
❌ Dificulta testes, manutenção e implantação.
✅ Reavalie a modelagem de fronteiras; talvez o domínio não esteja bem particionado.

9. Dependência excessiva de gateways ou proxies
⚠️ Todos os acessos passam por um único gateway que contém lógica demais.
❌ Gera um novo "monolito disfarçado".
✅ Gateways devem ser finos, delegando lógica aos serviços.

10. Falta de ownership claro
⚠️ Equipe A cuida do backend, B do frontend, C do banco.
❌ Ninguém é dono de ponta a ponta da capacidade.
✅ Use o modelo "You build it, you run it" com times alinhados por capacidade.

Reconhecer bad smells na modelagem de microsserviços é uma habilidade essencial para manter a arquitetura limpa, escalável e sustentável.
Eles indicam pontos de atenção, não falhas absolutas — mas ignorá-los tende a levar a um "microlito": um monolito fragmentado que combina o pior dos dois mundos.


7.12. Projeto AlgaSensors: Entendendo o negócio da empresa

- Monitoramento remoto de temperaturas (Ramo da Empresa)
- Usam sensores inteligentes (Sensores enviam os dados via internet)
- Existem modelos de sensores, e cada modelo de sensor trabalha com 1 protocolo de comunicação (HTTP, TCP, GRPC)
- A gestão dos sensores são feitas via planilha excel
- Dados de um sensor (nome, endereço, ip, modelo, protocolo)
- Para instalar um sensor 
  - O cliente informa a localidade
  - Escolhe o modelo e cadastra o sensor
  - O tecnico vai e instala o sensor
- Monitoramento do sensor:
  - Os colaboradores utilizam um dashboard 
  - Conseguem ver a temperatura em tempo real
- A empresa possui cerca de 500 sensores e querem expandir
- O intervalo de tempo idela para registrar as temperaturas seria a cada 5 segundos
- Dois alarmes por sensor (temperatura minima e maxima)

- Problemas:
  - Não é possível desativar um sensor a distancia, porém pode ser feito remoto pois o sensor aceita
  - A dashboard não suporta todo tipo de sensor
  - A dashboard só exibe os dados, porém não envia alertas
  - A dashboard não possui histórico
  - A dashboard ficou lenta após cadastro dos sensores

Requisitos Funcionais:
RF1 - Receber e armazenar os dados de temperatura
RF2 - Cadastrar sensores
RF3 - Ativar os desativar sensores remotamente
RF4 - Concsultar temperaturas registradas
RF5 - Alertar quando as temperaturas estiverem fora dos limites

Requisitos Não Funcionais
RNF1 - Capacidade de processar um grande volume de dados (A cada 5 segundos receberemos atualização sobre temperaturas e o dashboard necessita de atençaõ)

Objetos de negócio:
Sensor (Nome, Protocolo, Modelo, Localização, IP, tempMax, temMin, Ativo, TemperaturaAtual)
Registro Temperatura (Sensor, Valor da temperatura, Data Registro) 

Modulos:

Gestão de sensores:
  - Instalar Sensores
  - Realizar Manutenção
  - Cadastrar 
  - Ativar / Desativar

Monitoramento de temperaturas:
  - Monitorar temperatura
  - Registro de temperatura
  - Alertar
  - registrar
  - Histórico


7.13 Projeto AlgaSensors: Modelando um monolito

Ferramente: https://whimsical.com/

https://whimsical.com/algasensors-projeto-1-monolitico-CoJRjNz2cZmu5JsC3ve3LY

7.14. Projeto AlgaSensors: Modelando microsserviços por capacidades de negócio

https://whimsical.com/algasensors-projeto-2-ms-por-capacidade-de-negocio-SPG4WbrTtSMRxKvQA5feFy


7.15: Melhorando microsserviços

https://whimsical.com/algasensors-projeto-3-ms-por-capacidade-de-negocio-quebra-tecnic-WYzsyeWfajy9vFMswiRQTN

7.17. Decomposição por subdomínios: como DDD pode ajudar?

Como o DDD ajuda na decomposição por subdomínios?

1. Entendimento profundo do domínio
  DDD enfatiza a colaboração entre especialistas do negócio (domain experts) e desenvolvedores. Isso permite:
  Identificar as partes distintas do domínio.
  Compreender melhor os limites, regras e objetivos de cada área.
  Evitar suposições erradas ou generalizações perigosas.

2. Identificação de subdomínios
  DDD classifica os subdomínios em três tipos principais:
  Core Domain (Domínio Central): É o coração do negócio. Onde está o maior diferencial competitivo. Deve ter atenção máxima.
  Supporting Subdomain (Domínio de Suporte): Apoia o domínio central, mas não é exclusivo. Pode ser implementado sob medida.
  Generic Subdomain (Domínio Genérico): São necessidades comuns, que não diferenciam a empresa (ex: autenticação, envio de e-mail) — podem ser terceirizadas ou reutilizadas.

3. Delimitação com Bounded Contexts
  Um Bounded Context (Contexto Delimitado) é o contêiner lógico onde um modelo faz sentido. DDD propõe que cada subdomínio tenha seu próprio modelo, isolado em um bounded context:
  Evita conflitos semânticos (ex: “Cliente” no contexto de cobrança ≠ “Cliente” no contexto de CRM).
  Permite escolher arquiteturas, tecnologias e estratégias de modelagem diferentes conforme a necessidade.
  Facilita a evolução independente de partes do sistema.

4. Base para arquitetura modular
  Com subdomínios bem definidos e bounded contexts claros, você pode:
  Criar microserviços coesos (um por contexto).
  Aplicar modularização com menos acoplamento.
  Ter times autônomos por contexto, promovendo escalabilidade organizacional.

5. Melhor alinhamento com o negócio
  Ao decompor com base em subdomínios, você modela o sistema de acordo com a realidade do negócio e não com a estrutura técnica. Isso gera:
  Mais valor entregue ao negócio.
  Menos retrabalho e mais clareza nas funcionalidades.
  Possibilidade de adaptação mais rápida às mudanças.

8.3. Maven ou Gradle?

Ferramentas para Build

Java
  - Maven
    - XML
    - Dependencias Maven
    - Build Linear (passo a passo)
    - Customização via Plugins
  - Gradle
    - Groovy
    - Dependencias Maven
    - Build incremental
    - Cosutmização via plugins e tasks com groovy

8.4. Git Repository: Monorepo vs multirepo

🧱 O que é Monorepo?
Um monorepo (monolithic repository) é um único repositório Git que contém o código de múltiplos projetos, módulos ou serviços, geralmente relacionados entre si.

✅ Vantagens do Monorepo
Visão unificada: Todo o código está no mesmo lugar, facilitando a navegação e o entendimento do sistema como um todo.
Refatorações entre projetos: Alterações coordenadas em várias bibliotecas e serviços ficam mais fáceis (ex: atualizar uma interface usada por vários módulos).
Padronização: Ferramentas, estilos de código, CI/CD e dependências podem ser centralizados.
Atomic commits: Possibilita commits que afetam múltiplos serviços ao mesmo tempo de forma consistente.

❌ Desvantagens do Monorepo
Escalabilidade do Git: Repositórios muito grandes podem ficar lentos, especialmente sem ferramentas específicas (como Nx, Lage, Bazel, git sparse-checkout, etc).
Gerenciamento de permissões: Pode ser difícil restringir o acesso a apenas uma parte do código.
Builds mais complexos: Requer ferramentas para evitar builds e testes desnecessários.


📦 O que é Multirepo?
No multirepo, cada projeto, biblioteca ou serviço tem seu próprio repositório Git separado.

✅ Vantagens do Multirepo
Isolamento claro: Cada equipe ou projeto trabalha de forma independente, com menos risco de impactos cruzados.
Controle de acesso mais simples: Pode restringir o acesso por repositório.
Histórico e CI/CD separados: Cada repositório tem sua pipeline e versionamento específicos.

❌ Desvantagens do Multirepo
Complexidade na orquestração: Alterações que afetam múltiplos repositórios exigem mais coordenação.
Gerenciamento de dependências: Pode gerar conflitos de versão ou retrabalho em atualizações.
Menos visibilidade: Difícil ter uma visão global do sistema.

📌 O que são Git Submodules?
Um Git Submodule permite que você adicione um repositório Git dentro de outro repositório Git, funcionando como uma espécie de ponte entre múltiplos repositórios.

🔁 Submodule = um repositório "filho" referenciado dentro de um repositório "pai".

🧱 Quando usar?
Use submodules quando:
Você quer reaproveitar um projeto existente (ex: uma biblioteca ou serviço).
Os projetos têm ciclos de vida diferentes e não devem estar no mesmo repositório.
Você não quer copiar código, mas também não quer que tudo esteja num único monorepo.

🔄 Comandos úteis com Submodules
Ação	Comando
Clonar repositório com submodules:  	$ git clone --recurse-submodules <url>
Atualizar todos os submodules: 	      $ git submodule update --init --recursive
Puxar mudanças dos submodules:        $ cd services/email-service && git pull
Remover um submodule:               	Editar .gitmodules, remover a pasta, e git rm

8.5. Criando Git Repository dos serviços

ems algasensors

serviço pai: 
  - ems-algasensors-meta
filhos: 
  - ems-algasensors-temperature-processing
  - ems-algasensors-device-management
  - ems-algasensors-temperature-monitoring

8.6. Configurando Git submodules

Configurando dentro do super project 

- clone o repository pai
- dentro do repository pai crie uma pasta /microservices
- $ git submodule add git@github.com:LucianoFraga27/ems-algasensors-temperature-monitoring.git /microservices temperature-monitoring
- $ git pull --recurse-submodules | git pull de todos os modulos
- $ git clone --recurse-submodules -j8 <ulr-repository-pai> | clonando todos os repositorios pai e filhos

8.7. Criando microsserviços com Spring Boot e Gradle

8.9. Gradle: Estrutura do projeto

build: 
bootJar -> JAR
build -> realiza os testes + bootJar
check : realiza todos os testes
test : testes

8.10. Instalando o plugin do Lombok na IntelliJ IDEA

- instalar plugin Lombok
- enable annotations processors

8.12. Adicionando plugins do Gradle

8.13. Adicionando novas dependências no Gradle

https://mvnrepository.com/artifact/org.apache.commons/commons-lang3

implementation 'org.apache.commons:commons-lang3:3.17.0'

8.14. Gerenciando serviços na IntelliJ IDEA

Executando multiplos serviços no IntelliJ IDEA

Passo 1: Alterar a porta dos serviços

Passo 2: Configure a execução da aplicação
  - vm options: -XX:MaxRAM=256m
  - working directory: deixe apontando para o microserviço dele
  - store as project file : guarde a configuração como um arquivo do projeto

Passo 3: Add Services
  - Applications

8.15. O que é SonarQube?

Sast (Static Application Security Test)
Clean as you code [Limpar o código durante o desenvolvimento]

é uma plataforma open-source usada para análise (estática) contínua da qualidade de código. Ele permite inspecionar automaticamente o código-fonte para detectar:

- Bugs
- Vulnerabilidades de segurança
- "Code smells" (más práticas de codificação)
- Cobertura de testes
- Duplicações de código
- Problemas de manutenibilidade

Principais características:
- Suporte a múltiplas linguagens: Java, JavaScript, C#, Python, TypeScript, entre outras.
- Integração com CI/CD: Pode ser integrado com Jenkins, GitLab CI, GitHub Actions etc.
- Dashboards interativos: Fornece relatórios visuais e métricas de qualidade do código.
- Qualidade de código como critério de aprovação: Pode bloquear builds se o código não atender a um padrão mínimo de qualidade.
- Extensível: Suporta plugins e possui uma versão comercial com recursos extras (SonarQube Developer, Enterprise, etc.).

- O código-fonte é analisado por um scanner (como o sonar-scanner).
- Os resultados são enviados ao servidor do SonarQube.
- A interface web do SonarQube exibe os problemas encontrados e orientações para resolvê-los.

Banco de Regras:
- OWASP
- Clean Code
- SonarSource
- Code Conventions
- Regras Costumizadas

Segurabilidade, Confiabilidade e Manutenibilidade

Beneficios:
- Evita bugs
- Busca vunerabilidades de segurança
- Evita code Smals

SonarQube Cloud, SonarQube Server, SonarQube IDE (LINT)

8.16. Instalando o SonarQube plugin na IntelliJ IDEA

https://plugins.jetbrains.com/plugin/7973-sonarqube-for-ide


9.1. O problema dos identificadores nos sistemas distribuídos

O ID serve para:
- Referencia unicidade
- Organização dos Dados
- Integridade dos Dados
- Relacionamentos
- Rastreabilidade

Em sistemas distribuídos, identificadores únicos são essenciais para distinguir entidades como usuários, sessões, objetos, transações, arquivos e recursos de rede.
No entanto, garantir unicidade e consistência desses identificadores em um ambiente distribuído apresenta desafios específicos.

🧩 Desafios principais
1. Ausência de um ponto central
  - Em sistemas distribuídos, não há um servidor único controlando a geração de IDs.
  - Cada nó pode operar de forma independente, o que dificulta a coordenação para evitar duplicatas.
2. Colisões de identificadores
  - Dois nós diferentes podem gerar o mesmo identificador se não houver um mecanismo de distinção, como namespace ou prefixos únicos.
3. Sincronização de relógios
  - Identificadores baseados em timestamp podem gerar duplicações ou ordem incorreta se os relógios dos servidores não estiverem sincronizados.
4. Latência e particionamento
  - A comunicação entre nós pode ser lenta ou falhar temporariamente (ex: partições de rede), impedindo o consenso global.
5. Escalabilidade
  - Sistemas precisam gerar bilhões de identificadores únicos sem se tornarem um gargalo ou depender de um coordenador central.

🔧 Soluções comuns
1. UUID (Universally Unique Identifier)
  - Exemplo: 550e8400-e29b-41d4-a716-446655440000
  - Gerado localmente com base em timestamp, MAC address, aleatoriedade ou uma combinação disso.
  - Muito usado, mas não ordenado e pode ser "grande" para certas aplicações.
2. Snowflake IDs (Twitter)
  - IDs de 64 bits que incluem timestamp + ID do datacenter + ID do worker + contador.
  - São únicos, ordenáveis e eficientes para sistemas distribuídos.
3. Banco centralizado de IDs
  - Um serviço único que gera e distribui identificadores.
  - Funciona, mas introduz um ponto único de falha e limita a escalabilidade.
4. Pré-alocação de faixas
  - Cada nó recebe uma faixa de números (ex: 1000 a 1999) e gera IDs dentro dela.
  - Reduz colisões, mas exige coordenação prévia e pode desperdiçar IDs.
5. Hashing com sal único
  - Nós aplicam funções hash com sementes únicas para evitar colisões mesmo com entradas parecidas.
6. TSID (Time-Sortable Identifier)
  - Um identificador único que incorpora informações de tempo, permitindo que seja ordenado cronologicamente, ao mesmo tempo em que permanece único em ambientes distribuídos.
  - Inspirado no Snowflake ID do Twitter, mas é mais simples, mais eficiente e com foco em linguagens como Java, Kotlin, etc.

9.2. Entendendo o UUID v4 e v7

# 📊 UUID v4 — Aleatório puro
 - Base Aleatória
 - Não ordenavel pelo tempo
 - Alta aleatoriedade 
 - Identificadores únicos não ordenados
 - Gerado com números totalmente aleatórios (exceto por alguns bits reservados).
 - Tem 122 bits efetivamente aleatórios (de um total de 128 bits).
 - Exemplo: f47ac10b-58cc-4372-a567-0e02b2c3d479
 - Vantagem: Simples, universal, compatível com qualquer linguagem.
 - Vantagem: Alta entropia: baixa chance de colisão.
 - Desvantagem: Não ordenável por tempo → dificulta buscas ou indexação eficiente em bancos de dados.
 - Desvantagem: Pode prejudicar o desempenho de índices (por serem aleatórios e causarem fragmentação).
 - Implementação Nativa no Java: java.util.UUID.randomUUID(); 
 
# 🆕 UUID v7 — Ordenado por tempo (novo padrão)
  - Base Tempo + Rand
  - Ordenavel pelo tempo
  - Aleatório
  - Substituição moderna e ordenavel do V4
  - Combina timestamp no início (em milissegundos) com bits aleatórios no final.
  - Garante unicidade + ordenação temporal.
  - Foi padronizado pelo IETF como evolução natural ao UUID v1 (que tinha problemas com MAC address e privacidade).
  - Exemplo: 01890f5e-a3b1-7ccd-91e5-d00e2b4733e4
  - Os primeiros bits representam o tempo → o UUID é naturalmente ordenável.
  - Isso é ideal para logs, mensagens, bancos de dados, etc.
  - Vantagem: Unicidade com base em tempo + aleatoriedade.
  - Vantagem: Ideal para sistemas distribuídos com necessidade de ordenar eventos.
  - Vantagem: Melhor para indexação em bancos de dados.
  - Desvantagem: Ainda não suportado por 100% das bibliotecas nativas em todas as linguagens (mas está se espalhando rapidamente).
  - Desvantagem: Não é "puro aleatório", então não serve para casos onde se quer entropia máxima.
  - Implementação Java pela biblioteca : Faster:XML
    - com.fasterxml.uuid.TimeBasedEpochRandomGenerator

Colisões
- 18 quintilhões por ms antes de uma colisão

Vantagens:
  - Unicidade global, São únicos em escala global, probabilidade de colisão praticamente zero
  - Geração Descentralizada, Independência de banco de dados, flexibilidade de uso
  - Valores Imprevisiveis, mais seguro em diversos aspectos
  - Suporte Universal, usado por diversos tipos de tecnologia

Desvantagens:
  - tamanho (ocupa 128bits)
  - legibilidade por humanos
  - Ordenação e indexação: Custam mais para o banco de dados (v4 não ordenável, v7 ordenavel e indexavel)

Quando usar? 
- Sistemas Distribuidos
- Indentificadores publicos ou expostos
- geração descentralizada
- evitar vazamento de informações

Quando não usar?
- Quando a legebilidade é necessária
- Em sistemas pequenos e centralizados
- Quando a aleatorieadade não é necessária
- Quando o desempenho do banco de dados é critico

9.3. Entendendo o TSID (Time-Sortable Identifier)

Um identificador único que incorpora informações de tempo, permitindo que seja ordenado cronologicamente,
ao mesmo tempo em que permanece único em ambientes distribuídos.

Ele foi inspirado no Snowflake ID do Twitter, mas é mais simples, mais eficiente e com foco em linguagens como Java, Kotlin, etc.

🧬 Estrutura de um TSID (geralmente 64 bits)
Bits	Campo 	            Descrição
42	  Timestamp	          Tempo em milissegundos desde uma época customizada (geralmente 2020-01-01)
22	  Entropia/Aleatório	Bits de entropia para garantir unicidade entre nós ou processos simultâneos

Exemplo de TSID:
TSID: 1928781481899251712  
Base36: 3S5Z8DVBTM3

Implementação no Java: io.hypersistence.tsid.TSID

Vantagens:
  - Eficiencia no banco de dados (64 bits)
  - Ordenação temporal
  - Geração descentralizada
  - Boa legebilidade (string de 13 caracteres)

Desvantanges:
  - Não são únicos em escala global
  - São unicos em escala local, um cluster, um nó
  - Maior Complexidade na implementação
    - relogio do sistema
    - numero do nó, tamanho do cluster
    - sincronização de data e hora entre nós
  - Valores Previsiveis

Quando Usar?
  - Sistemas Distribuidos
  - Identificadores para banco de dados relacionais
  - URLs e exibição em telas

Quando não usar?
  - Quando a imprevisibilidade é critica
  - Em sistemas pequenos e centralizados
  - Quando a ordenação temporal não é necessária
  - Quando a unicdade global é necessária

9.4. Usando o UUID v4 e v7 com Java

https://mvnrepository.com/artifact/com.fasterxml.uuid/java-uuid-generator

implementation 'com.fasterxml.uuid:java-uuid-generator:5.1.0'

9.5. Usando o TSID com Java

https://github.com/vladmihalcea/hypersistence-tsid?tab=readme-ov-file

https://mvnrepository.com/artifact/io.hypersistence/hypersistence-tsid

implementation 'io.hypersistence:hypersistence-tsid:2.1.4'

9.6. Outros tipos e abordagens: Snowflake ID, Ticket Server e Dual Identifier

1. Snowflake ID (Twitter)
- Estrutura: ID de 64 bits, inclui timestamp, data center, worker e sequência.
- Formato: Geralmente um número inteiro longo.
- Exemplo de ID: 1537200203577346048
- Vantagem: Ordenado por tempo, único em sistemas distribuídos.

2. Ticket Server (ou Centralized ID Generator)
- Estrutura: Um servidor central gera IDs incrementais.
- Formato: Simples e sequencial.
- Exemplo de ID: 1001, 1002, 1003
- Vantagem: Fácil de entender e depurar.
- Desvantagem: Ponto único de falha e gargalo.

3. Dual Identifier
- Estrutura: Dois identificadores — um interno (sequencial) e outro externo (público, geralmente UUID ou hash).
- Exemplo:
  Interno: 54783
  Externo: 3fa85f64-5717-4562-b3fc-2c963f66afa6
  Vantagem: Permite expor um ID não sequencial/publicamente amigável mantendo controle interno.

10.1. O que vamos implementar?

Design Doc: https://www.notion.so/algaworks1/Design-Doc-Ado-o-da-Arquitetura-de-Microsservi-os-no-AlgaSensors-1a5731beea3580489501f870ac7f3c3e?pvs=4
Modelagem: https://whimsical.com/ems-01-07-15-projeto-algasensors-refinando-modelagem-PL457CGTiNJAY3FGqg5oJE

10.8. YAML ou Properties: qual usar?

A escolha entre YAML (application.yml) e Properties (application.properties) no Spring Boot (versão 10.8 ou qualquer outra) 
depende de alguns critérios como legibilidade, estrutura, preferência da equipe e casos de uso específicos.

- Use YAML para configurações complexas e com estrutura hierárquica.
- Use Properties para configurações simples e diretas.


12.2 O message broker RabbitMQ


Um "message broker" (também chamado de corretor de mensagens) é um sistema que facilita a comunicação entre diferentes componentes de um sistema,
seja ele um aplicativo, serviço ou microserviço. Ele atua como um intermediário, permitindo que os remetentes de mensagens, ou "produtores",
enviem informações para um local centralizado, e os receptores, ou "consumidores", as recebam conforme necessário


O RabbitMQ é um message broker open-source que atua como um intermediador de mensagens entre sistemas.
Ele permite que produtores enviem mensagens para consumidores de forma assíncrona, confiável e desacoplada.

🧠 Por que usar um Message Broker como o RabbitMQ?

🔗 Desacoplamento entre serviços (produtor e consumidor não precisam estar disponíveis ao mesmo tempo)
⏳ Alta disponibilidade e confiabilidade
🧵 Suporte a mensagens assíncronas
🎯 Roteamento inteligente de mensagens
📦 Persistência de mensagens até serem consumidas
🧩 Escalabilidade fácil: múltiplos produtores/consumidores

💡 Quando usar RabbitMQ?
Integração entre microserviços
Processamento em segundo plano
Fila de tarefas assíncronas
Controle de fluxo de eventos (event-driven architecture)
Reprocessamento automático em caso de falha (com DLQ)

12.3 Componentes do RabbitMQ

O RabbitMQ funciona com base em alguns componentes fundamentais. Aqui está um resumo prático:

1. Producer: Quem envia a mensagem para o broker. (Pode ser uma API, serviço, script, etc.)
2. Queue (Fila): Onde a mensagem fica armazenada até ser consumida, Pode ser persistente ou temporária. Cada fila pode ter vários consumidores.
  - name
  - durable: se é para ser permanete
  - exclusive: se é exclusiva de um consumidor
  - arguments (config/features)
  - Estilos de consumo : Push e pull
    - PUSH: Queue ------> Consumer [As mensagens são enviadas para o consumirdor assim que chegam]
    - PULL: Queue <------ Consumer [O consumidor solicita as mensagens]
3. Consumer: Quem recebe/processa a mensagem da fila. (Pode haver múltiplos consumidores por fila.)
4. Exchange: Roteia mensagens recebidas dos produtores para uma ou mais filas. (Decide como entregar com base no tipo e na routing key.)
  - direct:	Roteia baseado em uma routing key exata
  - fanout:	Ignora routing key e envia a todas as filas ligadas
  - topic:	Roteia baseado em padrões de routing key com * e #
  - headers:	Roteia baseado nos headers da mensagem em vez de routing key
5. Routing Key: Uma chave que o producer envia junto com a mensagem. (Usada pela exchange para decidir para qual fila enviar.)
6. Binding: A ligação entre uma exchange e uma fila. (Define a routing key que ativa a entrega.)
7. Dead Letter Queue (DLQ): Uma fila especial onde mensagens com falhas de processamento (ou rejeitadas) são redirecionadas. (Útil para análise e reprocessamento manual.)
8- Message:
  - Metadata: Content type / Routing Key
  - Headers: Versão, ids etc
  - Payload: xml, json, string etc.. (payloads grandes causam problemas)

[Producer]
    |
    V
[Exchange] --(Routing Key)--> [Queue] --> [Consumer]

12.4. Nomenclaturas e versionamento

Queues & Exchanges. Como nomear ?

Quando trabalhamos com diversos serviços publicando e consumindo mensagens, uma boa nomenclatura evita:

Conflitos e colisões
Dificuldade de rastreabilidade
Ambiguidade entre ambientes ou versões
Acoplamento indesejado entre serviços

Você deve definir uma padronização clara para:
- Exchange:   <producer-name>.<business-process>.<message-version>.e ou . exchange
- Queue:      <consumer-name>.<business-process>.<message-version>.q ou .queue
- Routing Key: 

Convenção Recomendada: <domínio>.<evento>.<versão>[.tipo]

Quando versionar?
Mudança no formato da mensagem
Mudança na semântica do evento
Introdução de novos campos obrigatórios
Quebra de compatibilidade com consumidores antigos

Como versionar?
Inclua o sufixo v1, v2, etc. no nome da exchange, fila, e/ou routing key
Mantenha versões antigas ativas se houver consumidores legados

12.5 simulado do rabbit: https://tryrabbitmq.com/

12.x Fluxo simples

🧱 O que existe no RabbitMQ?
Exchange – como uma "central de distribuição"
Fila (Queue) – onde a mensagem fica esperando
Binding – conexão entre a Exchange e a fila

🔁 Qual a ordem correta?
1. Exchange: Você precisa primeiro criar uma exchange, porque é para ela que o produtor envia a mensagem.
* direct – envia para uma fila específica baseada em uma “chave de roteamento” (routingKey)
* fanout – envia para todas as filas conectadas
* topic – envia baseado em padrões (ex: email.*)

2. Fila (Queue): Depois, você cria uma fila, que é onde a mensagem vai “ficar esperando”.
- A aplicação consumidora escuta essa fila.

3. Binding: Aí você faz a ligação entre a exchange e a fila, usando uma routingKey (ou não)

⚙️ O que o produtor faz? Ele envia uma mensagem para uma exchange, dizendo: "Aqui está a mensagem, envie para a fila X (routingKey: ‘mensagens.teste’)"
⚙️ O que o consumidor faz? Ele fica escutando uma fila (por exemplo: fila.teste) e quando uma mensagem chega lá, ele processa.

1. Manualmente no painel do RabbitMQ
Vá em Queues > Add a new queue → fila.teste
Vá em Exchanges > Add a new exchange → exchange.teste
Vá em Bindings > Ligue a exchange na fila com uma routing key (ex: mensagens.teste)

12.19 Direct Exchange

 Direct Exchange é um dos quatro tipos de exchanges padrão no RabbitMQ 
 e seu funcionamento é baseado em uma regra simples e poderosa: roteamento por correspondência exata.

Quando um produtor (Producer) envia uma mensagem para uma Direct Exchange,
ele anexa uma "etiqueta" chamada Routing Key (Chave de Roteamento). Essa chave é uma string, por exemplo, "pdf" ou "relatorio_financeiro".

Você tem uma ou mais filas (Queues) que querem receber mensagens. Para receber mensagens de uma exchange, uma fila precisa estar "ligada" a ela.

Ao ligar uma fila a uma Direct Exchange, você especifica uma Binding Key (Chave de Ligação). Essa chave define qual o "endereço" que aquela fila está escutando.

A exchange entregará uma cópia da mensagem para todas as filas cuja Binding Key seja exatamente igual à Routing Key da mensagem.

Se a Routing Key da mensagem não corresponder exatamente a nenhuma Binding Key, a mensagem é descartada (a menos que existam configurações alternativas, como uma Alternate Exchange).

vs. Fanout Exchange: A Fanout ignora completamente a Routing Key e envia a mensagem para todas as filas ligadas a ela (broadcast).


12.19 Topic Exchange


Se a Direct Exchange é sobre entregar uma carta para um "endereço exato",
a Topic Exchange é como um serviço de assinatura de revistas e jornais, onde você pode assinar categorias de notícias muito específicas ou muito amplas.

A Topic Exchange roteia mensagens com base em uma correspondência de padrão entre a Routing Key da mensagem e a Binding Key que liga a exchange à fila.

As chaves são uma lista de palavras separadas por pontos (.). Por exemplo: br.sp.temperatura ou log.error.database.

A exchange entrega uma cópia da mensagem para todas as filas cuja Binding Key (com seus curingas) corresponda à Routing Key da mensagem.


12.21. Headers Exchange

Se a Direct Exchange usa uma "etiqueta de endereço" (a routing key) e a Topic Exchange usa uma "etiqueta de categoria" hierárquica (também a routing key),
a Headers Exchange ignora completamente a routing key. Em vez disso, ela funciona como um inspetor de alfândega,
olhando para as propriedades da mensagem, conhecidas como headers (cabeçalhos).

Ao ligar (bind) uma fila a uma Headers Exchange, você fornece um ou mais argumentos de cabeçalho. O mais importante desses argumentos é o x-match.

O x-match define como os outros argumentos da ligação devem ser comparados com os cabeçalhos da mensagem. Ele pode ter dois valores:

all (E / AND): A mensagem só é enviada para a fila se TODOS os pares chave-valor definidos na ligação estiverem presentes e corresponderem exatamente nos cabeçalhos da mensagem.
any (OU / OR): A mensagem é enviada para a fila se PELO MENOS UM dos pares chave-valor definidos na ligação corresponder a um cabeçalho na mensagem.
A Routing Key, se enviada pelo produtor, é completamente ignorada.


13.1. Retry Pattern

O Retry Pattern (Padrão de Repetição) é um padrão de resiliência usado em sistemas distribuídos para lidar com falhas temporárias em chamadas de rede, como:
É muito usado em sistemas distribuídos, onde falhas intermitentes podem ocorrer ao acessar serviços externos, bancos de dados, filas de mensagens, etc.

- chamadas a serviços REST,
- acesso a banco de dados,
- leitura de arquivos remotos,
- Exceções momentâneas em um serviço

Quando ocorre uma falha, o padrão instrui o sistema a tentar novamente a operação depois de um pequeno intervalo, em vez de falhar imediatamente.

🧠 Quando usar?
Use o Retry Pattern quando as falhas forem transitórias, ou seja, provavelmente se resolvem sozinhas em pouco tempo. Exemplos:

- Latência momentânea da rede
- Timeouts intermitentes
- Serviço de terceiros temporariamente indisponível

⚠️ Quando não usar?
Evite usar quando:

- A falha for permanente (ex: dados inválidos, permissão negada)
- O retry pode causar efeitos colaterais indesejados (ex: duplicação de dados em requisições não idempotentes)
- Quando a operação não for idempotente, podendo causar efeitos colaterais (ex: envio duplicado de email, criação de registros múltiplos)

🔁 Estratégias Comuns
- Retry Fixo: tenta novamente após um tempo fixo.
- Exponential Backoff: tempo de espera cresce exponencialmente (ex: 1s, 2s, 4s…).
- Jitter: adiciona aleatoriedade ao tempo de espera para evitar congestionamento.

✅ Benefícios
- Aumenta a resiliência da aplicação.
- Evita falhas causadas por problemas passageiros.
- Melhora a experiência do usuário ao reduzir erros imediatos.

⚠️ Idempotência e Transações
O Retry Pattern é mais seguro quando aplicado a operações idempotentes ou envoltas em transações.

Idempotente: operação que pode ser executada múltiplas vezes sem efeitos colaterais (ex: GET, PUT).
Transacional: operações envoltas em transações podem ser revertidas em caso de erro, garantindo consistência.

🔒 Exemplo seguro: PUT /usuario/1234  {"nome": "Renan"} ✅ Idempotente
⚠️ Exemplo perigoso: POST /pagamento {"valor": 100}  ❌ Não idempotente — pode cobrar duas vezes!

🧩 Retry Pattern em Microserviços


🔗 1. Comunicação REST
Serviços podem estar temporariamente indisponíveis.

Use Retry + Timeout + Circuit Breaker para aumentar a resiliência.

Bibliotecas comuns:
  Resilience4j (Java)
  Spring Retry
  Hystrix (legado)
  Axios Retry (JavaScript)
  Polly (.NET)

✉️ 2. Comunicação por Mensageria (ex: RabbitMQ, Kafka)
Mensagens podem falhar no consumo ou no processamento.

Retry pode ser:
  Automático via reentrega da mensagem (DLQ, retry queues)
  Manual com tentativas controladas no código do consumidor
  Ideal em consumidores idempotentes (ex: atualização de status)

🧷 Dica:
  Use Dead Letter Queues (DLQ) para mensagens que falham após N tentativas.
  Em Kafka, considere reprocessamento com controle de offset.

❓ Retry Pattern é melhor para chamadas síncronas ou assíncronas?

🔁 1. Em chamadas SÍNCRONAS
Por exemplo, você faz uma chamada HTTP (REST) para outro serviço e quer tentar de novo caso ele falhe.

🔗 Exemplo: RESTTemplate, FeignClient, WebClient no Spring.
  ⏱️ O cliente espera pela resposta e o retry acontece no mesmo fluxo.
  💡 Cuidado com o tempo total de espera!
    Se você fizer 3 tentativas com 2 segundos cada, o tempo total pode ser de até 6 segundos antes de falhar de vez.

✅ Usos comuns síncronos:
Comunicação entre microserviços via REST
Acesso a banco de dados
Consumo de APIs externas
Leitura de arquivos remotos

🔁 2. Em chamadas ASSÍNCRONAS
✅ Sim, também é útil — especialmente com mensageria.
Aqui, o processamento acontece de forma desacoplada, por exemplo:
📩 Você publica uma mensagem numa fila (RabbitMQ, Kafka).
🛠️ Um consumidor processa essa mensagem — e se falhar, pode tentar novamente.

Assíncrono é ideal para:
  Retries automáticos com baixo impacto no usuário
  Desacoplamento e tolerância a falhas mais robusta
  Reprocessamento de mensagens com Dead Letter Queues (DLQ)

💡 Dica final:
Em síncrono, você “trava” a resposta esperando.
Em assíncrono, você deixa o sistema mais elástico e resiliente — mas precisa lidar com reprocessamento e ordenação.


Uasndo no Spring boot:

----

<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

Adicionar na main : @EnableRetry

----

@Service
public class ExternalService {

    private int attempt = 0;

    @Retryable(
        value = { RuntimeException.class },
        maxAttempts = 3,
        backoff = @Backoff(delay = 2000)
    )
    public String callService() {
        attempt++;
        System.out.println("Attempt #" + attempt);

        if (attempt < 3) {
            throw new RuntimeException("Service failed temporarily");
        }

        return "Service response OK";
    }

    @Recover
    public String recover(RuntimeException e) {
        System.out.println("Recovery method called after retries");
        return "Default fallback response";
    }
}

----

@Retryable: Indica que o método pode ser reexecutado automaticamente ao lançar uma exceção especificada.
  value: tipos de exceções a capturar.
  maxAttempts: número máximo de tentativas.
  backoff: tempo entre as tentativas (em milissegundos).
@Recover: método que será chamado após todas as tentativas falharem.


13.3. Dead Letter Channel Pattern e Dead Letter Queue Pattern

Esses dois padrões são usados para tratar mensagens que falham ao ser processadas.
A diferença principal está em como e onde elas são redirecionadas quando falham.

 1. Dead Letter Queue Pattern (DLQ)
 Uma fila separada usada para armazenar mensagens que não puderam ser processadas corretamente após várias tentativas (ou por rejeição explícita).

 ✅ Quando usar:
Quando você quer preservar a mensagem com erro para futura análise, correção ou reprocessamento.
Quando falhas não são recuperáveis no momento.

✅ Exemplo (RabbitMQ):
Mensagem vai para a fila pedido.processamento.
O consumidor tenta processar e falha várias vezes.
A mensagem é rejeitada ou expira.
A mensagem é redirecionada automaticamente para a fila pedido.dlq.


2. Dead Letter Channel Pattern
Um canal lógico (não necessariamente uma fila) para onde mensagens problemáticas são enviadas imediatamente após falha.
Esse canal pode ser uma fila, um log, um serviço REST, etc.

✅ Quando usar:
Quando você quer manter separação clara entre mensagens válidas e com erro.
Quando você quer tomar uma ação personalizada (ex: logar, notificar, reencaminhar).
É mais comum em integrações com Apache Camel, Spring Integration, ou Enterprise Integration Patterns.

✅ Conclusão:
Use DLQ quando trabalha com filas de mensagens e precisa guardar mensagens com erro.
Use Dead Letter Channel quando está em um fluxo de integração (como Spring Integration) e quer mais controle sobre o que fazer com a mensagem com erro.

13.6. Mensageria não acaba por aqui

